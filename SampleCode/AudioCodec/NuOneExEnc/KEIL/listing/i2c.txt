; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\i2c.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\i2c.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\i2c.crf ..\..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;66       */
;;;67     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;68     {
;;;69         i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;70     }
000008  4770              BX       lr
;;;71     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;49       */
;;;50     void I2C_Close(I2C_T *i2c)
000000  490b              LDR      r1,|L2.48|
;;;51     {
;;;52         /* Reset SPI */
;;;53         if((uint32_t)i2c == I2C0_BASE) {
000002  4288              CMP      r0,r1
000004  d10e              BNE      |L2.36|
;;;54             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000006  2105              MOVS     r1,#5
000008  0709              LSLS     r1,r1,#28
00000a  68c9              LDR      r1,[r1,#0xc]
00000c  1582              ASRS     r2,r0,#22
00000e  4311              ORRS     r1,r1,r2
000010  2205              MOVS     r2,#5
000012  0712              LSLS     r2,r2,#28
000014  60d1              STR      r1,[r2,#0xc]
;;;55             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
000016  4611              MOV      r1,r2
000018  68c9              LDR      r1,[r1,#0xc]
00001a  1582              ASRS     r2,r0,#22
00001c  4391              BICS     r1,r1,r2
00001e  2205              MOVS     r2,#5
000020  0712              LSLS     r2,r2,#28
000022  60d1              STR      r1,[r2,#0xc]
                  |L2.36|
;;;56         }
;;;57     
;;;58         /* Disable I2C */
;;;59         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
000024  6801              LDR      r1,[r0,#0]
000026  2240              MOVS     r2,#0x40
000028  4391              BICS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
;;;60     }
00002c  4770              BX       lr
;;;61     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40020000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;102      */
;;;103    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;106    }
000008  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;266      */
;;;267    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;268    {
;;;269        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;270    }
000008  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;112      */
;;;113    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;114    {
;;;115        i2c->CTL |= I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;116    }
000008  4770              BX       lr
;;;117    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;251      */
;;;252    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2900              CMP      r1,#0
;;;253    {
;;;254        if(u8LongTimeout)
000002  d004              BEQ      |L6.14|
;;;255            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
000004  6942              LDR      r2,[r0,#0x14]
000006  2302              MOVS     r3,#2
000008  431a              ORRS     r2,r2,r3
00000a  6142              STR      r2,[r0,#0x14]
00000c  e003              B        |L6.22|
                  |L6.14|
;;;256        else
;;;257            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
00000e  6942              LDR      r2,[r0,#0x14]
000010  2302              MOVS     r3,#2
000012  439a              BICS     r2,r2,r3
000014  6142              STR      r2,[r0,#0x14]
                  |L6.22|
;;;258    
;;;259        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000016  6942              LDR      r2,[r0,#0x14]
000018  2304              MOVS     r3,#4
00001a  431a              ORRS     r2,r2,r3
00001c  6142              STR      r2,[r0,#0x14]
;;;260    }
00001e  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;122      */
;;;123    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125        uint32_t u32Divider = i2c->CLKDIV;
000004  6925              LDR      r5,[r4,#0x10]
;;;126    
;;;127        return ( SystemCoreClock / ((u32Divider+1)<<2) );
000006  1c68              ADDS     r0,r5,#1
000008  0081              LSLS     r1,r0,#2
00000a  4802              LDR      r0,|L7.20|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  f7fffffe          BL       __aeabi_uidivmod
;;;128    }
000012  bd70              POP      {r4-r6,pc}
;;;129    
                          ENDP

                  |L7.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;172      */
;;;173    uint32_t I2C_GetData(I2C_T *i2c)
000000  4601              MOV      r1,r0
;;;174    {
;;;175        return ( i2c->DAT );
000002  6888              LDR      r0,[r1,#8]
;;;176    }
000004  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;152      */
;;;153    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  4601              MOV      r1,r0
;;;154    {
;;;155        return ( (i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1:0 );
000002  6808              LDR      r0,[r1,#0]
000004  2208              MOVS     r2,#8
000006  4010              ANDS     r0,r0,r2
000008  08c0              LSRS     r0,r0,#3
;;;156    }
00000a  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;162      */
;;;163    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  4601              MOV      r1,r0
;;;164    {
;;;165        return ( i2c->STATUS );
000002  68c8              LDR      r0,[r1,#0xc]
;;;166    }
000004  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;31       */
;;;32     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;33     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;34         uint32_t u32Div;
;;;35     
;;;36         u32Div = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000006  00a9              LSLS     r1,r5,#2
000008  4a0c              LDR      r2,|L11.60|
00000a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00000c  230a              MOVS     r3,#0xa
00000e  435a              MULS     r2,r3,r2
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       __aeabi_uidivmod
000016  1d47              ADDS     r7,r0,#5
000018  210a              MOVS     r1,#0xa
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  1e46              SUBS     r6,r0,#1
;;;37         i2c->CLKDIV = u32Div;
000022  6126              STR      r6,[r4,#0x10]
;;;38     
;;;39         /* Enable I2C */
;;;40         i2c->CTL |= I2C_CTL_I2CEN_Msk;
000024  6820              LDR      r0,[r4,#0]
000026  2140              MOVS     r1,#0x40
000028  4308              ORRS     r0,r0,r1
00002a  6020              STR      r0,[r4,#0]
;;;41     
;;;42         return ( SystemCoreClock / ((u32Div+1)<<2) );
00002c  1c70              ADDS     r0,r6,#1
00002e  0081              LSLS     r1,r0,#2
000030  4802              LDR      r0,|L11.60|
000032  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000034  f7fffffe          BL       __aeabi_uidivmod
;;;43     }
000038  bdf8              POP      {r3-r7,pc}
;;;44     
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;135      */
;;;136    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;137    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;138        uint32_t u32Div;
;;;139    
;;;140        u32Div = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000006  00a9              LSLS     r1,r5,#2
000008  4a0a              LDR      r2,|L12.52|
00000a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00000c  230a              MOVS     r3,#0xa
00000e  435a              MULS     r2,r3,r2
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       __aeabi_uidivmod
000016  1d47              ADDS     r7,r0,#5
000018  210a              MOVS     r1,#0xa
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  1e46              SUBS     r6,r0,#1
;;;141        i2c->CLKDIV = u32Div;
000022  6126              STR      r6,[r4,#0x10]
;;;142    
;;;143        return ( SystemCoreClock / ((u32Div+1)<<2) );
000024  1c70              ADDS     r0,r6,#1
000026  0081              LSLS     r1,r0,#2
000028  4802              LDR      r0,|L12.52|
00002a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;144    }
000030  bdf8              POP      {r3-r7,pc}
;;;145    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;183      */
;;;184    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;185    {
;;;186        i2c->DAT = u8Data;
;;;187    }
000002  4770              BX       lr
;;;188    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;198      */
;;;199    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  b510              PUSH     {r4,lr}
;;;200    {
;;;201        switch (u8SlaveNo) {
000002  2900              CMP      r1,#0
000004  d006              BEQ      |L14.20|
000006  2901              CMP      r1,#1
000008  d008              BEQ      |L14.28|
00000a  2902              CMP      r1,#2
00000c  d00a              BEQ      |L14.36|
00000e  2903              CMP      r1,#3
000010  d110              BNE      |L14.52|
000012  e00b              B        |L14.44|
                  |L14.20|
;;;202        case 0:
;;;203            i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000014  0054              LSLS     r4,r2,#1
000016  431c              ORRS     r4,r4,r3
000018  6044              STR      r4,[r0,#4]
;;;204            break;
00001a  e00f              B        |L14.60|
                  |L14.28|
;;;205        case 1:
;;;206            i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
00001c  0054              LSLS     r4,r2,#1
00001e  431c              ORRS     r4,r4,r3
000020  6184              STR      r4,[r0,#0x18]
;;;207            break;
000022  e00b              B        |L14.60|
                  |L14.36|
;;;208        case 2:
;;;209            i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
000024  0054              LSLS     r4,r2,#1
000026  431c              ORRS     r4,r4,r3
000028  61c4              STR      r4,[r0,#0x1c]
;;;210            break;
00002a  e007              B        |L14.60|
                  |L14.44|
;;;211        case 3:
;;;212            i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
00002c  0054              LSLS     r4,r2,#1
00002e  431c              ORRS     r4,r4,r3
000030  6204              STR      r4,[r0,#0x20]
;;;213            break;
000032  e003              B        |L14.60|
                  |L14.52|
;;;214        default:
;;;215            i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000034  0054              LSLS     r4,r2,#1
000036  431c              ORRS     r4,r4,r3
000038  6044              STR      r4,[r0,#4]
00003a  bf00              NOP                            ;201
                  |L14.60|
00003c  bf00              NOP                            ;204
;;;216        }
;;;217    }
00003e  bd10              POP      {r4,pc}
;;;218    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;225      */
;;;226    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  2900              CMP      r1,#0
;;;227    {
;;;228        switch (u8SlaveNo) {
000002  d006              BEQ      |L15.18|
000004  2901              CMP      r1,#1
000006  d007              BEQ      |L15.24|
000008  2902              CMP      r1,#2
00000a  d008              BEQ      |L15.30|
00000c  2903              CMP      r1,#3
00000e  d10c              BNE      |L15.42|
000010  e008              B        |L15.36|
                  |L15.18|
;;;229        case 0:
;;;230            i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
000012  0053              LSLS     r3,r2,#1
000014  6243              STR      r3,[r0,#0x24]
;;;231            break;
000016  e00b              B        |L15.48|
                  |L15.24|
;;;232        case 1:
;;;233            i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
000018  0053              LSLS     r3,r2,#1
00001a  6283              STR      r3,[r0,#0x28]
;;;234            break;
00001c  e008              B        |L15.48|
                  |L15.30|
;;;235        case 2:
;;;236            i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
00001e  0053              LSLS     r3,r2,#1
000020  62c3              STR      r3,[r0,#0x2c]
;;;237            break;
000022  e005              B        |L15.48|
                  |L15.36|
;;;238        case 3:
;;;239            i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
000024  0053              LSLS     r3,r2,#1
000026  6303              STR      r3,[r0,#0x30]
;;;240            break;
000028  e002              B        |L15.48|
                  |L15.42|
;;;241        default:
;;;242            i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
00002a  0053              LSLS     r3,r2,#1
00002c  6243              STR      r3,[r0,#0x24]
00002e  bf00              NOP                            ;228
                  |L15.48|
000030  bf00              NOP                            ;231
;;;243        }
;;;244    }
000032  4770              BX       lr
;;;245    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;80       */
;;;81     void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b5f0              PUSH     {r4-r7,lr}
;;;82     {
000002  4604              MOV      r4,r0
;;;83         uint32_t u32Reg = 0;
000004  2000              MOVS     r0,#0
;;;84         uint32_t u32Val = i2c->CTL & ~(I2C_STA | I2C_STO | I2C_AA);
000006  6826              LDR      r6,[r4,#0]
000008  2734              MOVS     r7,#0x34
00000a  43be              BICS     r6,r6,r7
00000c  4635              MOV      r5,r6
;;;85     
;;;86         if (u8Start)
00000e  2900              CMP      r1,#0
000010  d001              BEQ      |L16.22|
;;;87             u32Reg |= I2C_STA;
000012  2620              MOVS     r6,#0x20
000014  4330              ORRS     r0,r0,r6
                  |L16.22|
;;;88         if (u8Stop)
000016  2a00              CMP      r2,#0
000018  d001              BEQ      |L16.30|
;;;89             u32Reg |= I2C_STO;
00001a  2610              MOVS     r6,#0x10
00001c  4330              ORRS     r0,r0,r6
                  |L16.30|
;;;90         if (u8Si)
00001e  2b00              CMP      r3,#0
000020  d001              BEQ      |L16.38|
;;;91             u32Reg |= I2C_SI;
000022  2608              MOVS     r6,#8
000024  4330              ORRS     r0,r0,r6
                  |L16.38|
;;;92         if (u8Ack)
000026  9e05              LDR      r6,[sp,#0x14]
000028  2e00              CMP      r6,#0
00002a  d001              BEQ      |L16.48|
;;;93             u32Reg |= I2C_AA;
00002c  2604              MOVS     r6,#4
00002e  4330              ORRS     r0,r0,r6
                  |L16.48|
;;;94     
;;;95         i2c->CTL = u32Val | u32Reg;
000030  462e              MOV      r6,r5
000032  4306              ORRS     r6,r6,r0
000034  6026              STR      r6,[r4,#0]
;;;96     }
000036  bdf0              POP      {r4-r7,pc}
;;;97     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 132
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
