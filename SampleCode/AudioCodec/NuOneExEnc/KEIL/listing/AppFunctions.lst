L 1 "..\AppFunctions.c"
N/*---------------------------------------------------------------------------------------------------------*/
N/*																										   */
N/* Copyright (c) Nuvoton Technology	Corp. All rights reserved.											   */
N/*																										   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N// ---------------------------------------------------------------------------------------------------------
N//	Functions:
N//		- Functions to handle main operations:
N//			* Initiate application.
N//			* Start audio playback.
N//			* Stop  audio playback.
N//			* Produce PCM data for audio playback.
N//			* Start audio recording.
N//			* Stop  audio recording.
N//			* Use recorded data to do:
N//				a. encoding
N//				b. doing voice effect
N//				c. write to storage
N//				d. etc.
N//		- The above functions use codes in "xxxApp" folder and "Utility" folder to complete necessary operations.
N//
N//	Reference "Readme.txt" for more information.
N// ---------------------------------------------------------------------------------------------------------
N
N#include "App.h"
L 1 "..\App.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                              */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef _APP_H_
N#define _APP_H_	  	 
N
N#include "ConfigApp.h"
L 1 "..\ConfigApp.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                              */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __CONFIGAPP_H__
N#define __CONFIGAPP_H__	  	 
N									
N//%{CodeGen_Block_Start}
N//ISD9300
N#include "Platform.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\Platform.h" 1
N/****************************************************************
N *                                                              *
N * Copyright (c) Nuvoton Technology Corp. All rights reserved.  *
N *                                                              *
N ****************************************************************/
N
N#ifndef __PLATFORM_H__
N#define __PLATFORM_H__
N
N#include "ISD9100.h"		/* H/W SFR definition */
L 1 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 1
N/**************************************************************************//**
N * @file     ISD9100.h
N * @version  V3.0
N * $Revision: 32 $
N * $Date: 14/07/11 11:06a $
N * @brief    ISD9100 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of ISD9100 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_DIR Directory Structure
N  * 
N  * Please refer to Readme.pdf under BSP root directory for the BSP directory structure. 
N  *
N  * \page PG_REV Revision History
N  *
N  *
N  * <b>Revision 3.00.001</b>
N  * \li Updated to support new API
N*/
N
N#ifndef __ISD9100_H__
N#define __ISD9100_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N*/
N
N/** @addtogroup ISD93XX_CMSIS Device Definitions for CMSIS
N  ISD93XX Interrupt Number Definition and Configurations for CMSIS
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
N
Ntypedef enum IRQn
N    {
N        /******  Cortex-M0 Processor Exceptions Numbers *************************************************/
N        NonMaskableInt_IRQn       = -14,    /*!< 2 Non Maskable Interrupt                               */
N        HardFault_IRQn		      = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N        SVCall_IRQn               = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                         */
N        PendSV_IRQn               = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                         */
N        SysTick_IRQn              = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                     */
N        /******  ARMIKMCU Swift specific Interrupt Numbers **********************************************/
N        BOD_IRQn                  = 0,      /*!< 16 Brown Out Detector Device Interrupt               */
N        WDT_IRQn                  = 1,      /*!< 17 Watchdog Timer Device Interrupt                   */
N        EINT0_IRQn                = 2,      /*!< 18 External Interrupt PB0 Interrupt                  */
N        EINT1_IRQn                = 3,      /*!< 19 External Interrupt PB1 Interrupt                  */
N        GPAB_IRQn                 = 4,      /*!< 20 GPIO Interrupt                                    */
N        ALC_IRQn                  = 5,      /*!< 21 ALC Interrupt                                     */
N        PWM0_IRQn                 = 6,      /*!< 22 PWM 0 Peripheral Device Interrupt                 */
N        IRQ7n                     = 7,
N        TMR0_IRQn                 = 8,      /*!< 24 Timer 0 Interrupt                                 */
N        TMR1_IRQn                 = 9,      /*!< 25 Timer 1 Interrupt                                 */
N        IRQ10n                    = 10,
N        IRQ11n                    = 11,
N        UART0_IRQn                = 12,     /*!< 28 UART Device Interrupt                            */
N        IRQ13n                    = 13,
N        SPI0_IRQn                 = 14,     /*!< 30 SPI Interface Interrupt                          */
N        IRQ15n                    = 15,
N        IRQ16n                    = 16,
N        IRQ17n                    = 17,
N        I2C0_IRQn                 = 18,     /*!< 34 I2C Interface Interrupt                          */
N        IRQ19n                    = 19,
N        IRQ20n                    = 20,
N        TALARM_IRQn               = 21,     /*!< 37 Temperature Alaram Interrupt                     */
N        IRQ22n                    = 22,
N        IRQ23n                    = 23,
N        IRQ24n                    = 24,
N        ACMP_IRQn                 = 25,     /*!< 41 Analog Comparator Interrupt                      */
N        PDMA_IRQn                 = 26,     /*!< 42 Peripheral DMA Interrupt                         */
N        I2S0_IRQn                  = 27,    /*!< 43 I2S Interface Device Interrupt                   */
N        CAPS_IRQn                 = 28,     /*!< 44 CapSense Device Interrupt                        */
N        ADC_IRQn                  = 29,     /*!< 45 Audio ADC Device Interrupt                       */
N        IRQ30n                    = 30,
N        RTC_IRQn                  = 31      /*!< 47 Real Time Clock Interrupt                        */
N
N        /*!< maximum of 32 Interrupts are possible                */
N    } IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N/*@}*/ /* end of group ISD9100_CMSIS */
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     13. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060002
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 116 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060061 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMINSTR_H */
L 117 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060061 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMFUNC_H */
L 118 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
L 123 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "system_ISD9100.h"              /* ISD9xx System include file                             */
L 1 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\system_ISD9100.h" 1
N/**************************************************************************//**
N * @file     system_ISD9100.h
N * @brief    CMSIS Cortex-M0 Device System Header File
N *           for CM0 Device Series
N * @version  V1.03
N * @date     17. July 2014
N *
N * @note
N * Copyright (C) 2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_ISD9100_H__
N#define __SYSTEM_ISD9100_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/*----------------------------------------------------------------------------
N  Define system clocks sources
N *----------------------------------------------------------------------------*/
N#define __HXT         (0UL)         /*!< High Speed External Crystal Clock Frequency */
N#define __LXT         (32768UL)     /*!< Low Speed External Crystal Clock Frequency 32.768kHz */
N#define __HIRC        (49152000UL)  /*!< High Speed Internal 48MHz RC Oscillator Frequency */
N#define __LIRC        (16000UL)     /*!< Low Speed Internal 16kHz RC Oscillator Frequency */
N#define __HSI         (__HIRC)      /* Factory Default is internal 48MHz */
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
Nextern uint32_t CyclesPerUs;         /*!< Cycles per micro second              */
Nextern uint32_t gau32HiRCSrcTbl[];   /*!< HIRC(OSC48)Frequency Selection Table */
N
N/**
N * Initialize the system
N * @return none
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N * @return none
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_ISD9100_H__ */
L 124 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#elif  ( defined (__ICCARM__) )
S// IAR C compiler detected
S  #define __wfi       __WFI
S  #ifndef __STATIC_INLINE
S    #define __STATIC_INLINE  static inline
S  #endif
S/*
SUsage of #define
S  #define A(x)  T_##x
S  #define B]x) #@x
S  #define C]x) #x
S
S  A(1)------>T_1
S  B(1)------>'1'
S  C(1)------>"1"
S*/
S  #define __quote(n)      #n
S  #define __iar_align(n)  __quote(data_alignment=##n)
S  #define __align(n)      _Pragma(__iar_align(n))
N#endif
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/** @addtogroup REGISTER Control Register
N
N  @{
N
N*/
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller(ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL0
N     * ===================================================================================================
N     * Offset: 0x00  Analog Comparator 0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPEN    |Comparator Enable
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |[1]     |ACMPIE    |CMP0 Interrupt Enable
N     * |        |          |0 = Disable CMP0 interrupt function
N     * |        |          |1 = Enable CMP0 interrupt function
N     * |[4]     |NEGSEL    |Comparator0 Negative Input Select
N     * |        |          |0 = VBG, Bandgap reference voltage = 1.2V
N     * |        |          |1 = VMID reference voltage = VCCA/2
N */
N    __IO uint32_t CTL0;                  
X    volatile uint32_t CTL0;                  
N
N    /**
N     * CTL1
N     * ===================================================================================================
N     * Offset: 0x04  Analog Comparator 1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPEN    |Comparator Enable
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |[1]     |ACMPIE    |CMP1 Interrupt Enable
N     * |        |          |0 = Disable CMP1interrupt function
N     * |        |          |1 = Enable CMP1 interrupt function
N     * |[4]     |NEGSEL    |Comparator1 Negative Input Select
N     * |        |          |0 = GPIOB[7]
N     * |        |          |1 = VBG, Bandgap reference voltage = 1.2V 
N */
N    __IO uint32_t CTL1;                  
X    volatile uint32_t CTL1;                  
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x08  Comparator Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPIF0   |Compare 0 Flag
N     * |        |          |This bit is set by hardware whenever the comparator output changes state.
N     * |        |          |This bit will cause a hardware interrupt if enabled.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[1]     |ACMPIF1   |Compare 1 Flag
N     * |        |          |This bit is set by hardware whenever the comparator output changes state.
N     * |        |          |This bit will cause a hardware interrupt if enabled.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[2]     |ACMPO0    |Comparator0 Output
N     * |        |          |Synchronized to the APB clock to allow reading by software.
N     * |        |          |Cleared when the comparator is disabled (CMP0EN = 0).
N     * |[3]     |ACMPO1    |Comparator1 Output
N     * |        |          |Synchronized to the APB clock to allow reading by software.
N     * |        |          |Cleared when the comparator is disabled (CMP1EN = 0).
N */
N    __IO uint32_t STATUS;                
X    volatile uint32_t STATUS;                
N
N    /**
N     * POSSEL
N     * ===================================================================================================
N     * Offset: 0x0C  Comparator Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |POSSEL    |Comparator0 GPIO Selection
N     * |        |          |GPIOB[POSSEL] is the active analog GPIO input selected to Comparator 0 positive input. 
N */
N    __IO uint32_t POSSEL;                
X    volatile uint32_t POSSEL;                
N
N} ACMP_T;
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N#define ACMP_CTL0_ACMPEN_Pos             (0)                                               /*!< ACMP CTL0: ACMPEN Position             */
N#define ACMP_CTL0_ACMPEN_Msk             (0x1ul << ACMP_CTL0_ACMPEN_Pos)                   /*!< ACMP CTL0: ACMPEN Mask                 */
N
N#define ACMP_CTL0_ACMPIE_Pos             (1)                                               /*!< ACMP CTL0: ACMPIE Position             */
N#define ACMP_CTL0_ACMPIE_Msk             (0x1ul << ACMP_CTL0_ACMPIE_Pos)                   /*!< ACMP CTL0: ACMPIE Mask                 */
N
N#define ACMP_CTL0_NEGSEL_Pos             (4)                                               /*!< ACMP CTL0: NEGSEL Position             */
N#define ACMP_CTL0_NEGSEL_Msk             (0x1ul << ACMP_CTL0_NEGSEL_Pos)                   /*!< ACMP CTL0: NEGSEL Mask                 */
N
N#define ACMP_CTL1_ACMPEN_Pos             (0)                                               /*!< ACMP CTL1: ACMPEN Position             */
N#define ACMP_CTL1_ACMPEN_Msk             (0x1ul << ACMP_CTL1_ACMPEN_Pos)                   /*!< ACMP CTL1: ACMPEN Mask                 */
N
N#define ACMP_CTL1_ACMPIE_Pos             (1)                                               /*!< ACMP CTL1: ACMPIE Position             */
N#define ACMP_CTL1_ACMPIE_Msk             (0x1ul << ACMP_CTL1_ACMPIE_Pos)                   /*!< ACMP CTL1: ACMPIE Mask                 */
N
N#define ACMP_CTL1_NEGSEL_Pos             (4)                                               /*!< ACMP CTL1: NEGSEL Position             */
N#define ACMP_CTL1_NEGSEL_Msk             (0x1ul << ACMP_CTL1_NEGSEL_Pos)                   /*!< ACMP CTL1: NEGSEL Mask                 */
N
N#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP STATUS: ACMPIF0 Position          */
N#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP STATUS: ACMPIF0 Mask              */
N
N#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP STATUS: ACMPIF1 Position          */
N#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP STATUS: ACMPIF1 Mask              */
N
N#define ACMP_STATUS_ACMPO0_Pos           (2)                                               /*!< ACMP STATUS: ACMPO0 Position           */
N#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP STATUS: ACMPO0 Mask               */
N
N#define ACMP_STATUS_ACMPO1_Pos           (3)                                               /*!< ACMP STATUS: ACMPO1 Position           */
N#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP STATUS: ACMPO1 Mask               */
N
N#define ACMP_POSSEL_POSSEL_Pos           (0)                                               /*!< ACMP POSSEL: POSSEL Position           */
N#define ACMP_POSSEL_POSSEL_Msk           (0x7ul << ACMP_POSSEL_POSSEL_Pos)                 /*!< ACMP POSSEL: POSSEL Mask               */
N
N/**@}*/ /* ACMP_CONST */
N/**@}*/ /* end of ACMP register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x00  ADC FIFO Data Out.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |RESULT    |ADC Audio Data FIFO Read
N     * |        |          |A read of this register will read data from the audio FIFO and increment the read pointer.
N     * |        |          |A read past empty will repeat the last data.
N     * |        |          |Can be used with FIFOINTLV interrupt to determine if valid data is present in FIFO.
N */
N    __I  uint32_t DAT;                   
X    volatile const  uint32_t DAT;                   
N
N    /**
N     * CHEN
N     * ===================================================================================================
N     * Offset: 0x04  ADC Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN      |ADC Enable
N     * |        |          |0 = Conversion stopped and ADC is reset including FIFO pointers.
N     * |        |          |1 = ADC Conversion enabled.
N */
N    __IO uint32_t CHEN;                  
X    volatile uint32_t CHEN;                  
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x08  ADC Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |CLKDIV    |ADC Clock Divider
N     * |        |          |This register determines the clock division ration between the incoming ADC_CLK (= HCLK by default) and the Delta-Sigma sampling clock of the ADC.
N     * |        |          |This together with the over-sampling ratio (OSR) determines the audio sample rate of the converter.
N     * |        |          |CLKDIV should be set to give a SD_CLK frequency in the range of 1.024-6.144MHz.
N     * |        |          |CLKDIV must be greater than 2.
N     * |        |          |SD_CLK frequency = HCLK / CLKDIV
N */
N    __IO uint32_t CLKDIV;                
X    volatile uint32_t CLKDIV;                
N
N    /**
N     * DCICTL
N     * ===================================================================================================
N     * Offset: 0x0C  ADC Decimation Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |OVSPLRAT  |Decimation Over-Sampling Ratio
N     * |        |          |This term determines the over-sampling ratio of the decimation filter. Valid values are:
N     * |        |          |0: OVSPLRAT = 64
N     * |        |          |1: OVSPLRAT = 128
N     * |        |          |2: OVSPLRAT = 192
N     * |        |          |3: OVSPLRAT = 384
N     * |[16:19] |GAIN      |CIC Filter Additional Gain
N     * |        |          |This should normally remain default 0.
N     * |        |          |Can be set to non-zero values to provide additional digital gain from the decimation filter.
N     * |        |          |An additional gain is applied to signal of GAIN/2.
N */
N    __IO uint32_t DCICTL;                
X    volatile uint32_t DCICTL;                
N
N    /**
N     * INTCTL
N     * ===================================================================================================
N     * Offset: 0x10  ADC Interrupt Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |FIFOINTLV |FIFO Interrupt Level
N     * |        |          |Determines at what level the ADC FIFO will generate a servicing interrupt to the CPU.
N     * |        |          |Interrupt will be generated when number of words present in ADC FIFO is > FIFOINTLV.
N     * |[31]    |INTEN     |Interrupt Enable
N     * |        |          |If set to '1' an interrupt is generated whenever FIFO level exceeds that set in FIFOINTLV.
N */
N    __IO uint32_t INTCTL;                
X    volatile uint32_t INTCTL;                
N
N    /**
N     * PDMACTL
N     * ===================================================================================================
N     * Offset: 0x14  ADC PDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXDMAEN   |Enable ADC PDMA Receive Channel
N     * |        |          |Enable ADC PDMA. If set, then ADC will request PDMA service when data is available.
N */
N    __IO uint32_t PDMACTL;               
X    volatile uint32_t PDMACTL;               
N
N    /**
N     * CMP0
N     * ===================================================================================================
N     * Offset: 0x18  ADC Comparator 0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADCMPEN   |Compare Enable
N     * |        |          |0 = Disable compare.
N     * |        |          |1 = Enable compare.
N     * |        |          |Set this bit to 1 to enable compare CMPDAT with FIFO data output.
N     * |[1]     |ADCMPIE   |Compare Interrupt Enable
N     * |        |          |0 = Disable compare function interrupt.
N     * |        |          |1 = Enable compare function interrupt.
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, CMPFLAG bit will be asserted, if ADCMPIE is set to 1, a compare interrupt request is generated.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0= Set the compare condition that result is less than CMPDAT
N     * |        |          |1= Set the compare condition that result is greater or equal to CMPDAT
N     * |        |          |Note: When the internal counter reaches the value (CMPMCNT +1), the CMPFLAG bit will be set.
N     * |[7]     |CMPFLAG   |Compare Flag
N     * |        |          |When the conversion result meets condition in ADCMPR0 this bit is set to 1.
N     * |        |          |It is cleared by writing 1 to self.
N     * |[8:11]  |CMPMCNT   |Compare Match Count
N     * |        |          |When the A/D FIFO result matches the compare condition defined by CMPCOND, the internal match counter will increase by 1.
N     * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the CMPFLAG bit will be set.
N     * |[16:31] |CMPDAT    |Comparison Data
N     * |        |          |16 bit value to compare to FIFO output word.
N */
N    __IO uint32_t CMP0;                  
X    volatile uint32_t CMP0;                  
N
N    /**
N     * CMP1
N     * ===================================================================================================
N     * Offset: 0x1C  ADC Comparator 1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADCMPEN   |Compare Enable
N     * |        |          |0 = Disable compare.
N     * |        |          |1 = Enable compare.
N     * |        |          |Set this bit to 1 to enable compare CMPDAT with FIFO data output.
N     * |[1]     |ADCMPIE   |Compare Interrupt Enable
N     * |        |          |0 = Disable compare function interrupt.
N     * |        |          |1 = Enable compare function interrupt.
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, CMPFLAG bit will be asserted, if ADCMPIE is set to 1, a compare interrupt request is generated.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0= Set the compare condition that result is less than CMPDAT
N     * |        |          |1= Set the compare condition that result is greater or equal to CMPDAT
N     * |        |          |Note: When the internal counter reaches the value (CMPMCNT +1), the CMPFLAG bit will be set.
N     * |[7]     |CMPFLAG   |Compare Flag
N     * |        |          |When the conversion result meets condition in ADCMPR0 this bit is set to 1.
N     * |        |          |It is cleared by writing 1 to self.
N     * |[8:11]  |CMPMCNT   |Compare Match Count
N     * |        |          |When the A/D FIFO result matches the compare condition defined by CMPCOND, the internal match counter will increase by 1.
N     * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the CMPFLAG bit will be set.
N     * |[16:31] |CMPDAT    |Comparison Data
N     * |        |          |16 bit value to compare to FIFO output word.
N */
N    __IO uint32_t CMP1;                  
X    volatile uint32_t CMP1;                  
N
N} ADC_T;
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N#define ADC_DAT_RESULT_Pos               (0)                                               /*!< ADC DAT: RESULT Position               */
N#define ADC_DAT_RESULT_Msk               (0xfffful << ADC_DAT_RESULT_Pos)                  /*!< ADC DAT: RESULT Mask                   */
N
N#define ADC_CHEN_CHEN_Pos                (0)                                               /*!< ADC CHEN: CHEN Position                */
N#define ADC_CHEN_CHEN_Msk                (0x1ul << ADC_CHEN_CHEN_Pos)                      /*!< ADC CHEN: CHEN Mask                    */
N
N#define ADC_CLKDIV_CLKDIV_Pos            (0)                                               /*!< ADC CLKDIV: CLKDIV Position            */
N#define ADC_CLKDIV_CLKDIV_Msk            (0xfful << ADC_CLKDIV_CLKDIV_Pos)                 /*!< ADC CLKDIV: CLKDIV Mask                */
N
N#define ADC_DCICTL_OVSPLRAT_Pos          (0)                                               /*!< ADC DCICTL: OVSPLRAT Position          */
N#define ADC_DCICTL_OVSPLRAT_Msk          (0xful << ADC_DCICTL_OVSPLRAT_Pos)                /*!< ADC DCICTL: OVSPLRAT Mask              */
N
N#define ADC_DCICTL_GAIN_Pos              (16)                                              /*!< ADC DCICTL: GAIN Position              */
N#define ADC_DCICTL_GAIN_Msk              (0xful << ADC_DCICTL_GAIN_Pos)                    /*!< ADC DCICTL: GAIN Mask                  */
N
N#define ADC_INTCTL_FIFOINTLV_Pos         (0)                                               /*!< ADC INTCTL: FIFOINTLV Position         */
N#define ADC_INTCTL_FIFOINTLV_Msk         (0x7ul << ADC_INTCTL_FIFOINTLV_Pos)               /*!< ADC INTCTL: FIFOINTLV Mask             */
N
N#define ADC_INTCTL_INTEN_Pos             (31)                                              /*!< ADC INTCTL: INTEN Position             */
N#define ADC_INTCTL_INTEN_Msk             (0x1ul << ADC_INTCTL_INTEN_Pos)                   /*!< ADC INTCTL: INTEN Mask                 */
N
N#define ADC_PDMACTL_RXDMAEN_Pos          (0)                                               /*!< ADC PDMACTL: RXDMAEN Position          */
N#define ADC_PDMACTL_RXDMAEN_Msk          (0x1ul << ADC_PDMACTL_RXDMAEN_Pos)                /*!< ADC PDMACTL: RXDMAEN Mask              */
N
N#define ADC_CMP0_ADCMPEN_Pos             (0)                                               /*!< ADC CMP0: ADCMPEN Position             */
N#define ADC_CMP0_ADCMPEN_Msk             (0x1ul << ADC_CMP0_ADCMPEN_Pos)                   /*!< ADC CMP0: ADCMPEN Mask                 */
N
N#define ADC_CMP0_ADCMPIE_Pos             (1)                                               /*!< ADC CMP0: ADCMPIE Position             */
N#define ADC_CMP0_ADCMPIE_Msk             (0x1ul << ADC_CMP0_ADCMPIE_Pos)                   /*!< ADC CMP0: ADCMPIE Mask                 */
N
N#define ADC_CMP0_CMPCOND_Pos             (2)                                               /*!< ADC CMP0: CMPCOND Position             */
N#define ADC_CMP0_CMPCOND_Msk             (0x1ul << ADC_CMP0_CMPCOND_Pos)                   /*!< ADC CMP0: CMPCOND Mask                 */
N
N#define ADC_CMP0_CMPFLAG_Pos             (7)                                               /*!< ADC CMP0: CMPFLAG Position             */
N#define ADC_CMP0_CMPFLAG_Msk             (0x1ul << ADC_CMP0_CMPFLAG_Pos)                   /*!< ADC CMP0: CMPFLAG Mask                 */
N
N#define ADC_CMP0_CMPMCNT_Pos             (8)                                               /*!< ADC CMP0: CMPMCNT Position             */
N#define ADC_CMP0_CMPMCNT_Msk             (0xful << ADC_CMP0_CMPMCNT_Pos)                   /*!< ADC CMP0: CMPMCNT Mask                 */
N
N#define ADC_CMP0_CMPDAT_Pos              (16)                                              /*!< ADC CMP0: CMPDAT Position              */
N#define ADC_CMP0_CMPDAT_Msk              (0xfffful << ADC_CMP0_CMPDAT_Pos)                 /*!< ADC CMP0: CMPDAT Mask                  */
N
N#define ADC_CMP1_ADCMPEN_Pos             (0)                                               /*!< ADC CMP1: ADCMPEN Position             */
N#define ADC_CMP1_ADCMPEN_Msk             (0x1ul << ADC_CMP1_ADCMPEN_Pos)                   /*!< ADC CMP1: ADCMPEN Mask                 */
N
N#define ADC_CMP1_ADCMPIE_Pos             (1)                                               /*!< ADC CMP1: ADCMPIE Position             */
N#define ADC_CMP1_ADCMPIE_Msk             (0x1ul << ADC_CMP1_ADCMPIE_Pos)                   /*!< ADC CMP1: ADCMPIE Mask                 */
N
N#define ADC_CMP1_CMPCOND_Pos             (2)                                               /*!< ADC CMP1: CMPCOND Position             */
N#define ADC_CMP1_CMPCOND_Msk             (0x1ul << ADC_CMP1_CMPCOND_Pos)                   /*!< ADC CMP1: CMPCOND Mask                 */
N
N#define ADC_CMP1_CMPFLAG_Pos             (7)                                               /*!< ADC CMP1: CMPFLAG Position             */
N#define ADC_CMP1_CMPFLAG_Msk             (0x1ul << ADC_CMP1_CMPFLAG_Pos)                   /*!< ADC CMP1: CMPFLAG Mask                 */
N
N#define ADC_CMP1_CMPMCNT_Pos             (8)                                               /*!< ADC CMP1: CMPMCNT Position             */
N#define ADC_CMP1_CMPMCNT_Msk             (0xful << ADC_CMP1_CMPMCNT_Pos)                   /*!< ADC CMP1: CMPMCNT Mask                 */
N
N#define ADC_CMP1_CMPDAT_Pos              (16)                                              /*!< ADC CMP1: CMPDAT Position              */
N#define ADC_CMP1_CMPDAT_Msk              (0xfffful << ADC_CMP1_CMPDAT_Pos)                 /*!< ADC CMP1: CMPDAT Mask                  */
N
N/**@}*/ /* ADC_CONST */
N/**@}*/ /* end of ADC register group */
N
N
N/*---------------------- Automatic Level Control -------------------------*/
N/**
N    @addtogroup ALC Automatic Level Control(ALC)
N    Memory Mapped Structure for ALC Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  ALC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |NGTHBST   |Noise Gate Threshold
N     * |        |          |Boost disabled: Threshold = (-81+6xNGTHBST) dB
N     * |        |          |Boost enabled: Threshold = (-87+6xNGTHBST) dB
N     * |[3]     |NGEN      |Noise Gate Enable
N     * |        |          |0 = Noise gate disabled
N     * |        |          |1 = Noise gate enabled
N     * |[4:7]   |ATKSEL    |ALC Attack Time
N     * |        |          |(Value: 0~10)
N     * |        |          |When MODESEL = 0, Range: 500us to 512ms
N     * |        |          |When MODESEL = 1,Range: 125us to 128ms (Both ALC time doubles with every step)
N     * |[8:11]  |DECAYSEL  |ALC Decay Time
N     * |        |          |(Value: 0~10)
N     * |        |          |When MODESEL = 0, Range: 125us to 128ms
N     * |        |          |When MODESEL = 1, Range: 31us to 32ms (time doubles with every step)
N     * |[12]    |MODESEL   |ALC Mode
N     * |        |          |0 = ALC normal operation mode
N     * |        |          |1 = ALC limiter mode
N     * |[13:16] |TARGETLV  |ALC Target Level
N     * |        |          |0 = -28.5 dB
N     * |        |          |1 = -27 dB
N     * |        |          |2 = -25.5 dB
N     * |        |          |3 = -24 dB
N     * |        |          |4 = -22.5 dB
N     * |        |          |5 = -21 dB
N     * |        |          |6 = -19.5 dB
N     * |        |          |7 = -18 dB
N     * |        |          |8 = -16.5 dB
N     * |        |          |9 = -15 dB
N     * |        |          |10 = -13.5 dB
N     * |        |          |11 = -12 dB
N     * |        |          |12 = -10.5 dB
N     * |        |          |13 = -9 dB
N     * |        |          |14 = -7.5 dB
N     * |        |          |15 = -6 dB
N     * |[17:20] |HOLDTIME  |ALC Hold Time
N     * |        |          |(Value: 0~10). Hold Time = (2^HOLDTIME) ms
N     * |[21]    |ZCEN      |ALC Zero Crossing
N     * |        |          |0 = zero crossing disabled
N     * |        |          |1 = zero crossing enabled
N     * |[22:24] |MINGAIN   |ALC Minimum Gain
N     * |        |          |0 = -12 dB
N     * |        |          |1 = -6 dB
N     * |        |          |2 = 0 dB
N     * |        |          |3 = 6 dB
N     * |        |          |4 = 12 dB
N     * |        |          |5 = 18 dB
N     * |        |          |6 = 24 dB
N     * |        |          |7 = 30 dB
N     * |[25:27] |MAXGAIN   |ALC Maximum Gain
N     * |        |          |0 = -6.75 dB
N     * |        |          |1 = -0.75 dB
N     * |        |          |2 = +5.25 dB
N     * |        |          |3 = +11.25 dB
N     * |        |          |4 = +17.25 dB
N     * |        |          |5 = +23.25 dB
N     * |        |          |6 = +29.25 dB
N     * |        |          |7 = +35.25 dB
N     * |[28]    |ALCEN     |ALC select
N     * |        |          |0 = ALC disabled (default)
N     * |        |          |1 = ALC enabled
N     * |[29]    |NGPKSEL   |ALC noise gate peak detector select
N     * |        |          |0 = use peak-to-peak value for noise gate threshold determination (default)
N     * |        |          |1 = use absolute peak value for noise gate threshold determination
N     * |[30]    |PKSEL     |ALC gain peak detector select
N     * |        |          |0 = use absolute peak value for ALC training (default)
N     * |        |          |1 = use peak-to-peak value for ALC training
N     * |[31]    |PKLIMEN   |ALC peak limiter enable
N     * |        |          |0 = enable fast decrement when signal exceeds 87.5% of full scale (default)
N     * |        |          |1 = disable fast decrement when signal exceeds 87.5% of full scale
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * STS
N     * ===================================================================================================
N     * Offset: 0x04  ALC status register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CLIPFLAG  |Clipping Flag
N     * |        |          |Asserted when signal level is detected to be above 87.5% of full scale
N     * |[1]     |NOISEF    |Noise Flag
N     * |        |          |Asserted when signal level is detected to be below NGTHBST
N     * |[2:10]  |P2PVAL    |Peak-To-Peak Value
N     * |        |          |9 MSBs of measured peak-to-peak value
N     * |[11:18] |PEAKVAL   |Peak Value
N     * |        |          |9 MSBs of measured absolute peak value
N */
N    __I  uint32_t STS;                   
X    volatile const  uint32_t STS;                   
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x08  ALC interrupt register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTFLAG   |ALC interrupt flag
N     * |        |          |This interrupt flag asserts whenever the interrupt is enabled and the PGA gain is updated, either through an ALC change with the ALC enabled or through a PGA gain write with the ALC disabled.
N     * |        |          |Write a 1 to this register to clear.
N */
N    __IO uint32_t INTSTS;                
X    volatile uint32_t INTSTS;                
N
N    /**
N     * INTCTL
N     * ===================================================================================================
N     * Offset: 0x0C  ALC interrupt enable register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTEN     |ALC Interrupt Enable
N     * |        |          |0 = ALC INT disabled
N     * |        |          |1 = ALC INT enabled
N */
N    __IO uint32_t INTCTL;                
X    volatile uint32_t INTCTL;                
N
N} ALC_T;
N
N/**
N    @addtogroup ALC_CONST ALC Bit Field Definition
N    Constant Definitions for ALC Controller
N@{ */
N
N#define ALC_CTL_NGTHBST_Pos              (0)                                               /*!< ALC CTL: NGTHBST Position              */
N#define ALC_CTL_NGTHBST_Msk              (0x7ul << ALC_CTL_NGTHBST_Pos)                    /*!< ALC CTL: NGTHBST Mask                  */
N
N#define ALC_CTL_NGEN_Pos                 (3)                                               /*!< ALC CTL: NGEN Position                 */
N#define ALC_CTL_NGEN_Msk                 (0x1ul << ALC_CTL_NGEN_Pos)                       /*!< ALC CTL: NGEN Mask                     */
N
N#define ALC_CTL_ATKSEL_Pos               (4)                                               /*!< ALC CTL: ATKSEL Position               */
N#define ALC_CTL_ATKSEL_Msk               (0xful << ALC_CTL_ATKSEL_Pos)                     /*!< ALC CTL: ATKSEL Mask                   */
N
N#define ALC_CTL_DECAYSEL_Pos             (8)                                               /*!< ALC CTL: DECAYSEL Position             */
N#define ALC_CTL_DECAYSEL_Msk             (0xful << ALC_CTL_DECAYSEL_Pos)                   /*!< ALC CTL: DECAYSEL Mask                 */
N
N#define ALC_CTL_MODESEL_Pos              (12)                                              /*!< ALC CTL: MODESEL Position              */
N#define ALC_CTL_MODESEL_Msk              (0x1ul << ALC_CTL_MODESEL_Pos)                    /*!< ALC CTL: MODESEL Mask                  */
N
N#define ALC_CTL_TARGETLV_Pos             (13)                                              /*!< ALC CTL: TARGETLV Position             */
N#define ALC_CTL_TARGETLV_Msk             (0xful << ALC_CTL_TARGETLV_Pos)                   /*!< ALC CTL: TARGETLV Mask                 */
N
N#define ALC_CTL_HOLDTIME_Pos             (17)                                              /*!< ALC CTL: HOLDTIME Position             */
N#define ALC_CTL_HOLDTIME_Msk             (0xful << ALC_CTL_HOLDTIME_Pos)                   /*!< ALC CTL: HOLDTIME Mask                 */
N
N#define ALC_CTL_ZCEN_Pos                 (21)                                              /*!< ALC CTL: ZCEN Position                 */
N#define ALC_CTL_ZCEN_Msk                 (0x1ul << ALC_CTL_ZCEN_Pos)                       /*!< ALC CTL: ZCEN Mask                     */
N
N#define ALC_CTL_MINGAIN_Pos              (22)                                              /*!< ALC CTL: MINGAIN Position              */
N#define ALC_CTL_MINGAIN_Msk              (0x7ul << ALC_CTL_MINGAIN_Pos)                    /*!< ALC CTL: MINGAIN Mask                  */
N
N#define ALC_CTL_MAXGAIN_Pos              (25)                                              /*!< ALC CTL: MAXGAIN Position              */
N#define ALC_CTL_MAXGAIN_Msk              (0x7ul << ALC_CTL_MAXGAIN_Pos)                    /*!< ALC CTL: MAXGAIN Mask                  */
N
N#define ALC_CTL_ALCEN_Pos                (28)                                              /*!< ALC CTL: ALCEN Position                */
N#define ALC_CTL_ALCEN_Msk                (0x1ul << ALC_CTL_ALCEN_Pos)                      /*!< ALC CTL: ALCEN Mask                    */
N
N#define ALC_CTL_NGPKSEL_Pos              (29)                                              /*!< ALC CTL: NGPKSEL Position              */
N#define ALC_CTL_NGPKSEL_Msk              (0x1ul << ALC_CTL_NGPKSEL_Pos)                    /*!< ALC CTL: NGPKSEL Mask                  */
N
N#define ALC_CTL_PKSEL_Pos                (30)                                              /*!< ALC CTL: PKSEL Position                */
N#define ALC_CTL_PKSEL_Msk                (0x1ul << ALC_CTL_PKSEL_Pos)                      /*!< ALC CTL: PKSEL Mask                    */
N
N#define ALC_CTL_PKLIMEN_Pos              (31)                                              /*!< ALC CTL: PKLIMEN Position              */
N#define ALC_CTL_PKLIMEN_Msk              (0x1ul << ALC_CTL_PKLIMEN_Pos)                    /*!< ALC CTL: PKLIMEN Mask                  */
N
N#define ALC_STS_CLIPFLAG_Pos             (0)                                               /*!< ALC STS: CLIPFLAG Position             */
N#define ALC_STS_CLIPFLAG_Msk             (0x1ul << ALC_STS_CLIPFLAG_Pos)                   /*!< ALC STS: CLIPFLAG Mask                 */
N
N#define ALC_STS_NOISEF_Pos               (1)                                               /*!< ALC STS: NOISEF Position               */
N#define ALC_STS_NOISEF_Msk               (0x1ul << ALC_STS_NOISEF_Pos)                     /*!< ALC STS: NOISEF Mask                   */
N
N#define ALC_STS_P2PVAL_Pos               (2)                                               /*!< ALC STS: P2PVAL Position               */
N#define ALC_STS_P2PVAL_Msk               (0x1fful << ALC_STS_P2PVAL_Pos)                   /*!< ALC STS: P2PVAL Mask                   */
N
N#define ALC_STS_PEAKVAL_Pos              (11)                                              /*!< ALC STS: PEAKVAL Position              */
N#define ALC_STS_PEAKVAL_Msk              (0xfful << ALC_STS_PEAKVAL_Pos)                   /*!< ALC STS: PEAKVAL Mask                  */
N
N#define ALC_INTSTS_INTFLAG_Pos           (0)                                               /*!< ALC INTSTS: INTFLAG Position           */
N#define ALC_INTSTS_INTFLAG_Msk           (0x1ul << ALC_INTSTS_INTFLAG_Pos)                 /*!< ALC INTSTS: INTFLAG Mask               */
N
N#define ALC_INTCTL_INTEN_Pos             (0)                                               /*!< ALC INTCTL: INTEN Position             */
N#define ALC_INTCTL_INTEN_Msk             (0x1ul << ALC_INTCTL_INTEN_Pos)                   /*!< ALC INTCTL: INTEN Mask                 */
N
N/**@}*/ /* ALC_CONST */
N/**@}*/ /* end of ALC register group */
N
N
N/*---------------------- Analog Functional Blocks -------------------------*/
N/**
N    @addtogroup ANA Analog Functional Blocks(ANA)
N    Memory Mapped Structure for ANA Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * VMID
N     * ===================================================================================================
N     * Offset: 0x00  VMID Reference Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PULLDOWN  |VMID Pulldown
N     * |        |          |0= Release VMID pin for reference operation.
N     * |        |          |1= Pull VMID pin to ground. Default power down and reset condition.
N     * |[1]     |PDLORES   |Power Down Low (4.8kOhm) Resistance Reference
N     * |        |          |0= Connect the Low Resistance reference to VMID.
N     * |        |          |Use this setting for fast power up of VMID.
N     * |        |          |Can be turned off after 50ms to save power.
N     * |        |          |1= The Low Resistance reference is disconnected from VMID. Default power down and reset condition.
N     * |[2]     |PDHIRES   |Power Down High (360kOhm) Resistance Reference
N     * |        |          |0= Connect the High Resistance reference to VMID. Use this setting for minimum power consumption.
N     * |        |          |1= The High Resistance reference is disconnected from VMID. Default power down and reset condition.
N */
N    __IO uint32_t VMID;                  
X    volatile uint32_t VMID;                  
N         uint32_t RESERVE0[1];
N
N
N    /**
N     * CURCTL0
N     * ===================================================================================================
N     * Offset: 0x08  Current Source Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |CURSRCEN  |Enable Current Source to GPIOB[x]
N     * |        |          |Individually enable current source to GPIOB pins. Each GPIOB pin has a separate current source.
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable current source to pin GPIOB[x]
N     * |[8:9]   |VALSEL    |Current Source Value
N     * |        |          |Select master current for source generation
N     * |        |          |0= 0.5 uA
N     * |        |          |1= 1 uA
N     * |        |          |2= 2.5 uA
N     * |        |          |3= 5 uA
N */
N    __IO uint32_t CURCTL0;               
X    volatile uint32_t CURCTL0;               
N         uint32_t RESERVE1[5];
N
N
N    /**
N     * LDOSEL
N     * ===================================================================================================
N     * Offset: 0x20  LDO Voltage Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |LDOSEL    |Select LDO Output Voltage
N     * |        |          |Note that maximum I/O pad operation speed only specified for voltage >2.4V.
N     * |        |          |0= 3.0V
N     * |        |          |1= 1.8V
N     * |        |          |2= 2.4V
N     * |        |          |3= 3.3V
N */
N    __IO uint32_t LDOSEL;                
X    volatile uint32_t LDOSEL;                
N
N    /**
N     * LDOPD
N     * ===================================================================================================
N     * Offset: 0x24  LDO Power Down Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PD        |Power Down LDO
N     * |        |          |When powered down no current delivered to VD33.
N     * |        |          |0= Enable LDO
N     * |        |          |1= Power Down.
N     * |[1]     |DISCHAR   |Discharge
N     * |        |          |0 = No load on VD33
N     * |        |          |1 = Switch discharge resistor to VD33.
N */
N    __IO uint32_t LDOPD;                 
X    volatile uint32_t LDOPD;                 
N
N    /**
N     * MICBSEL
N     * ===================================================================================================
N     * Offset: 0x28  Microphone Bias Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |VOLSEL    |Select Microphone Bias Voltage
N     * |        |          |MICBMODE = 0
N     * |        |          |0: 90% VCCA
N     * |        |          |1: 65% VCCA
N     * |        |          |2: 75% VCCA
N     * |        |          |3: 50% VCCA
N     * |        |          |MICBMODE = 1
N     * |        |          |0: 2.4V
N     * |        |          |1: 1.7V
N     * |        |          |2: 2.0V
N     * |        |          |3: 1.3V
N     * |[2]     |REFSEL    |Select Reference Source For MICBIAS Generator
N     * |        |          |VMID provides superior noise performance for MICBIAS generation and should be used unless fixed voltage is absolutely necessary, then noise performance can be sacrificed and bandgap voltage used as reference.
N     * |        |          |0= VMID = VCCA/2 is reference source.
N     * |        |          |1= VBG (bandgap voltage reference) is reference source.
N */
N    __IO uint32_t MICBSEL;               
X    volatile uint32_t MICBSEL;               
N
N    /**
N     * MICBEN
N     * ===================================================================================================
N     * Offset: 0x2C  Microphone Bias Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |MICBEN    |Enable Microphone Bias Generator
N     * |        |          |0 = Powered Down.
N     * |        |          |1 = Enabled.
N */
N    __IO uint32_t MICBEN;                
X    volatile uint32_t MICBEN;                
N         uint32_t RESERVE2[8];
N
N
N    /**
N     * MUXCTL
N     * ===================================================================================================
N     * Offset: 0x50  Analog Multiplexer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |NEGINSEL  |Selects Connection Of GPIOB[7:0] To PGA_INN, Negative Input Of PGA
N     * |        |          |If NEGINSEL[n] = 1 then GPIOB[n] is connected to PGA_INN.
N     * |[8:11]  |POSINSEL  |Selects Connection Of GPIOB[7,5,3,1] To PGA_INP, Positive Input Of PGA
N     * |        |          |1000b: GPIOB[7] connected to PGA_INP
N     * |        |          |0100b: GPIOB[5] connected to PGA_INP
N     * |        |          |0010b: GPIOB[3] connected to PGA_INP
N     * |        |          |0001b: GPIOB[1] connected to PGA_INP
N     * |[12]    |PTATCUR   |Select PTAT Current
N     * |        |          |I_PTAT, to PGA_INN, negative input to PGA, for temperature measurement.
N     * |[13]    |PGAINSEL  |Select MICP/MICN To PGA Inputs
N     * |[14]    |MUXEN     |Enable The Analog Multiplexer
N     * |        |          |0 = All channels disabled
N     * |        |          |1 = Selection determined by register setting.
N */
N    __IO uint32_t MUXCTL;                
X    volatile uint32_t MUXCTL;                
N         uint32_t RESERVE3[3];
N
N
N    /**
N     * PGACTL
N     * ===================================================================================================
N     * Offset: 0x60  PGA Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |REFSEL    |Select Reference For Analog Path
N     * |        |          |Signal path is normally referenced to VMID (VCCA/2).
N     * |        |          |To use an absolute reference this can be set to VBG = 1.2V.
N     * |        |          |0 = Select VMID voltage as analog ground reference.
N     * |        |          |1 = Select Bandgap voltage as analog ground reference. 
N     * |[1]     |PUPGA     |Power Up Control For PGA Amplifier
N     * |        |          |This amplifier must be powered up for signal path operation.
N     * |        |          |0 = Power Down.
N     * |        |          |1 = Power up.
N     * |[2]     |PUBOOST   |Power Up Control For Boost Stage Amplifier
N     * |        |          |This amplifier must be powered up for signal path operation.
N     * |        |          |0 = Power Down.
N     * |        |          |1 = Power up.
N     * |[3]     |BSTGAIN   |Boost Stage Gain Setting
N     * |        |          |0 = Gain = 0dB.
N     * |        |          |1 = Gain = 26dB
N */
N    __IO uint32_t PGACTL;                
X    volatile uint32_t PGACTL;                
N
N    /**
N     * SIGCTL
N     * ===================================================================================================
N     * Offset: 0x64  Signal Path Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PUZCDCMP  |Power Up And Enable Control For Zero Cross Detect Comparator
N     * |        |          |When enabled PGA gain settings will only be updated when ADC input signal crosses zero signal threshold.
N     * |        |          |To operate ZCD the ALC peripheral clock (CLK_APBCLK0.BFALCKEN) must also be enabled and BIQ_CTL.DLCOEFF = 1 to allow ZCD clocks to be generated.
N     * |        |          |0 = Power down.
N     * |        |          |1 = Power up and enable zero cross detection. 
N     * |[1]     |PUBUFPGA  |Power Up Control For PGA Reference Buffer
N     * |        |          |This block must be powered up for signal path operation.
N     * |        |          |0 = Power down.
N     * |        |          |1 = Power up.
N     * |[2]     |PUBUFADC  |Power Up Control For ADC Reference Buffer
N     * |        |          |This block must be powered up for signal path operation.
N     * |        |          |0 = Power down.
N     * |        |          |1 = Power up.
N     * |[3]     |PUCURB    |Power Up Control For Current Bias Generation
N     * |        |          |This block must be powered up for signal path operation.
N     * |        |          |0 = Power down.
N     * |        |          |1 = Power up.
N     * |[4]     |PUADCOP   |Power Up ADC Sigma-Delta Modulator
N     * |        |          |This block must be powered up for ADC operation.
N     * |        |          |0 = Power down.
N     * |        |          |1 = Power up.
N     * |[5]     |MUTEPGA   |PGA Mute Control
N     * |        |          |0 = Normal.
N     * |        |          |1 = Signal Muted.
N     * |[6]     |MUTEBST   |Boost Stage Mute Control
N     * |        |          |0 = Normal.
N     * |        |          |1 = Signal Muted. 
N */
N    __IO uint32_t SIGCTL;                
X    volatile uint32_t SIGCTL;                
N
N    /**
N     * PGAGAIN
N     * ===================================================================================================
N     * Offset: 0x68  PGA Gain Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:5]   |GAINSET   |Select The PGA Gain Setting
N     * |        |          |From -12dB to 35.25dB in 0.75dB step size.
N     * |        |          |0x00 is lowest gain setting at -12dB and 0x3F is largest gain at 35.25dB.
N     * |[8:13]  |GAINREAD  |Current PGA Gain
N     * |        |          |Read Only. May be different from GAIN register when AGC is enabled and is controlling the PGA gain.
N */
N    __IO uint32_t PGAGAIN;               
X    volatile uint32_t PGAGAIN;               
N         uint32_t RESERVE4[6];
N
N
N    /**
N     * TRIM
N     * ===================================================================================================
N     * Offset: 0x84  Oscillator Trim Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |OSCTRIM   |Oscillator Trim
N     * |        |          |Reads current oscillator trim setting. Read Only.
N     * |[8:15]  |COARSE    |COARSE
N     * |        |          |Current coarse range setting of the oscillator. Read Only
N     * |[16:23] |SUPERFINE |Superfine
N     * |        |          |The superfine trim setting is an 8bit signed integer.
N     * |        |          |It adjusts the master oscillator by dithering the FINE trim setting between the current setting and one setting above (values 1,127) or below (values -1, -128) the current trim setting.
N     * |        |          |Each step effectively moves the frequency 1/128th of the full FINE trim step size.
N */
N    __IO uint32_t TRIM;                  
X    volatile uint32_t TRIM;                  
N         uint32_t RESERVE5[1];
N
N
N    /**
N     * CAPSCTL
N     * ===================================================================================================
N     * Offset: 0x8C  Capacitive Touch Sensing Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |LOWTIME   |Output Low Time
N     * |        |          |Number of PCLK cycles to discharge external capacitor.
N     * |        |          |0=1cycle
N     * |        |          |1=2cycles
N     * |        |          |2=8cycles
N     * |        |          |3=16cycles
N     * |[2:4]   |CYCLECNT  |Number of Relaxation Cycles
N     * |        |          |Peripheral performs 2^(CYCLECNT) relaxation cycles before generating interrupt.
N     * |[5]     |CLKMODE   |Reference Clock Mode
N     * |        |          |0 = Capacitive Touch Sensing Mode.
N     * |        |          |1 = Circuit is in Reference clock generation mode.
N     * |[8:15]  |CLKDIV    |Reference Clock Divider
N     * |        |          |Circuit can be used to generate a reference clock output of SDCLK/2/(CLKDIV+1) instead of a Capacitive Touch Sensing reset signal.
N     * |[29]    |RSTCNT    |Reset Count
N     * |        |          |0: Release/Activate ANA_CAPSCNT
N     * |        |          |1: Set high to reset ANA_CAPSCNT.
N     * |[30]    |INTEN     |Interrupt Enable
N     * |        |          |0 = Disable/Reset CAPS_IRQ interrupt.
N     * |        |          |1 = Enable CAPS_IRQ interrupt.
N     * |[31]    |CAPSEN    |Enable
N     * |        |          |0 = Disable/Reset block.
N     * |        |          |1 = Enable Block.
N */
N    __IO uint32_t CAPSCTL;               
X    volatile uint32_t CAPSCTL;               
N
N    /**
N     * CAPSCNT
N     * ===================================================================================================
N     * Offset: 0x90  Capacitive Touch Sensing Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:23]  |CAPSCNT   |Counter Read Back Value Of Capacitive Touch Sensing Block
N */
N    __I  uint32_t CAPSCNT;               
X    volatile const  uint32_t CAPSCNT;               
N
N    /**
N     * FQMMCTL
N     * ===================================================================================================
N     * Offset: 0x94  Frequency Measurement Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |CLKSEL    |Reference Clock Source
N     * |        |          |00b: OSC16K,
N     * |        |          |01b: OSC32K (default),
N     * |        |          |1xb: I2S_WS - can be GPIOA[4,8,12] according to SYS_GPA_MFP register, configure I2S in SLAVE mode to enable.
N     * |[2]     |MMSTS     |Measurement Done
N     * |        |          |0 = Measurement Ongoing.
N     * |        |          |1 = Measurement Complete.
N     * |[16:23] |CYCLESEL  |Frequency Measurement Cycles
N     * |        |          |Number of reference clock periods plus one to measure target clock (PCLK).
N     * |        |          |For example if reference clock is OSC32K (T is 30.5175us), set CYCLESEL to 7, then measurement period would be 30.5175*(7+1), 244.1us.
N     * |[31]    |FQMMEN    |FQMMEN
N     * |        |          |0 = Disable/Reset block.
N     * |        |          |1 = Start Frequency Measurement.
N */
N    __IO uint32_t FQMMCTL;               
X    volatile uint32_t FQMMCTL;               
N
N    /**
N     * FQMMCNT
N     * ===================================================================================================
N     * Offset: 0x98  Frequency Measurement Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |FQMMCNT   |Frequency Measurement Count
N     * |        |          |When MMSTS = 1 and G0 = 1, this is number of PCLK periods counted for frequency measurement.
N     * |        |          |The frequency will be PCLK = FQMMCNT * Fref /(CYCLESEL+1) Hz
N     * |        |          |Maximum resolution of measurement is Fref /(CYCLESEL+1)*2 Hz
N */
N    __I  uint32_t FQMMCNT;               
X    volatile const  uint32_t FQMMCNT;               
N
N} ANA_T;
N
N/**
N    @addtogroup ANA_CONST ANA Bit Field Definition
N    Constant Definitions for ANA Controller
N@{ */
N
N#define ANA_VMID_PULLDOWN_Pos            (0)                                               /*!< ANA VMID: PULLDOWN Position            */
N#define ANA_VMID_PULLDOWN_Msk            (0x1ul << ANA_VMID_PULLDOWN_Pos)                  /*!< ANA VMID: PULLDOWN Mask                */
N
N#define ANA_VMID_PDLORES_Pos             (1)                                               /*!< ANA VMID: PDLORES Position             */
N#define ANA_VMID_PDLORES_Msk             (0x1ul << ANA_VMID_PDLORES_Pos)                   /*!< ANA VMID: PDLORES Mask                 */
N
N#define ANA_VMID_PDHIRES_Pos             (2)                                               /*!< ANA VMID: PDHIRES Position             */
N#define ANA_VMID_PDHIRES_Msk             (0x1ul << ANA_VMID_PDHIRES_Pos)                   /*!< ANA VMID: PDHIRES Mask                 */
N
N#define ANA_CURCTL0_CURSRCEN_Pos         (0)                                               /*!< ANA CURCTL0: CURSRCEN Position         */
N#define ANA_CURCTL0_CURSRCEN_Msk         (0xfful << ANA_CURCTL0_CURSRCEN_Pos)              /*!< ANA CURCTL0: CURSRCEN Mask             */
N
N#define ANA_CURCTL0_VALSEL_Pos           (8)                                               /*!< ANA CURCTL0: VALSEL Position           */
N#define ANA_CURCTL0_VALSEL_Msk           (0x3ul << ANA_CURCTL0_VALSEL_Pos)                 /*!< ANA CURCTL0: VALSEL Mask               */
N
N#define ANA_LDOSEL_LDOSEL_Pos            (0)                                               /*!< ANA LDOSEL: LDOSEL Position            */
N#define ANA_LDOSEL_LDOSEL_Msk            (0x3ul << ANA_LDOSEL_LDOSEL_Pos)                  /*!< ANA LDOSEL: LDOSEL Mask                */
N
N#define ANA_LDOPD_PD_Pos                 (0)                                               /*!< ANA LDOPD: PD Position                 */
N#define ANA_LDOPD_PD_Msk                 (0x1ul << ANA_LDOPD_PD_Pos)                       /*!< ANA LDOPD: PD Mask                     */
N
N#define ANA_LDOPD_DISCHAR_Pos            (1)                                               /*!< ANA LDOPD: DISCHAR Position            */
N#define ANA_LDOPD_DISCHAR_Msk            (0x1ul << ANA_LDOPD_DISCHAR_Pos)                  /*!< ANA LDOPD: DISCHAR Mask                */
N
N#define ANA_MICBSEL_VOLSEL_Pos           (0)                                               /*!< ANA MICBSEL: VOLSEL Position           */
N#define ANA_MICBSEL_VOLSEL_Msk           (0x3ul << ANA_MICBSEL_VOLSEL_Pos)                 /*!< ANA MICBSEL: VOLSEL Mask               */
N
N#define ANA_MICBSEL_REFSEL_Pos           (2)                                               /*!< ANA MICBSEL: REFSEL Position           */
N#define ANA_MICBSEL_REFSEL_Msk           (0x1ul << ANA_MICBSEL_REFSEL_Pos)                 /*!< ANA MICBSEL: REFSEL Mask               */
N
N#define ANA_MICBEN_MICBEN_Pos            (0)                                               /*!< ANA MICBEN: MICBEN Position            */
N#define ANA_MICBEN_MICBEN_Msk            (0x1ul << ANA_MICBEN_MICBEN_Pos)                  /*!< ANA MICBEN: MICBEN Mask                */
N
N#define ANA_MUXCTL_NEGINSEL_Pos          (0)                                               /*!< ANA MUXCTL: NEGINSEL Position          */
N#define ANA_MUXCTL_NEGINSEL_Msk          (0xfful << ANA_MUXCTL_NEGINSEL_Pos)               /*!< ANA MUXCTL: NEGINSEL Mask              */
N
N#define ANA_MUXCTL_POSINSEL_Pos          (8)                                               /*!< ANA MUXCTL: POSINSEL Position          */
N#define ANA_MUXCTL_POSINSEL_Msk          (0xful << ANA_MUXCTL_POSINSEL_Pos)                /*!< ANA MUXCTL: POSINSEL Mask              */
N
N#define ANA_MUXCTL_PTATCUR_Pos           (12)                                              /*!< ANA MUXCTL: PTATCUR Position           */
N#define ANA_MUXCTL_PTATCUR_Msk           (0x1ul << ANA_MUXCTL_PTATCUR_Pos)                 /*!< ANA MUXCTL: PTATCUR Mask               */
N
N#define ANA_MUXCTL_PGAINSEL_Pos          (13)                                              /*!< ANA MUXCTL: PGAINSEL Position          */
N#define ANA_MUXCTL_PGAINSEL_Msk          (0x1ul << ANA_MUXCTL_PGAINSEL_Pos)                /*!< ANA MUXCTL: PGAINSEL Mask              */
N
N#define ANA_MUXCTL_MUXEN_Pos             (14)                                              /*!< ANA MUXCTL: MUXEN Position             */
N#define ANA_MUXCTL_MUXEN_Msk             (0x1ul << ANA_MUXCTL_MUXEN_Pos)                   /*!< ANA MUXCTL: MUXEN Mask                 */
N
N#define ANA_PGACTL_REFSEL_Pos            (0)                                               /*!< ANA PGACTL: REFSEL Position            */
N#define ANA_PGACTL_REFSEL_Msk            (0x1ul << ANA_PGACTL_REFSEL_Pos)                  /*!< ANA PGACTL: REFSEL Mask                */
N
N#define ANA_PGACTL_PUPGA_Pos             (1)                                               /*!< ANA PGACTL: PUPGA Position             */
N#define ANA_PGACTL_PUPGA_Msk             (0x1ul << ANA_PGACTL_PUPGA_Pos)                   /*!< ANA PGACTL: PUPGA Mask                 */
N
N#define ANA_PGACTL_PUBOOST_Pos           (2)                                               /*!< ANA PGACTL: PUBOOST Position           */
N#define ANA_PGACTL_PUBOOST_Msk           (0x1ul << ANA_PGACTL_PUBOOST_Pos)                 /*!< ANA PGACTL: PUBOOST Mask               */
N
N#define ANA_PGACTL_BSTGAIN_Pos           (3)                                               /*!< ANA PGACTL: BSTGAIN Position           */
N#define ANA_PGACTL_BSTGAIN_Msk           (0x1ul << ANA_PGACTL_BSTGAIN_Pos)                 /*!< ANA PGACTL: BSTGAIN Mask               */
N
N#define ANA_SIGCTL_PUZCDCMP_Pos          (0)                                               /*!< ANA SIGCTL: PUZCDCMP Position          */
N#define ANA_SIGCTL_PUZCDCMP_Msk          (0x1ul << ANA_SIGCTL_PUZCDCMP_Pos)                /*!< ANA SIGCTL: PUZCDCMP Mask              */
N
N#define ANA_SIGCTL_PUBUFPGA_Pos          (1)                                               /*!< ANA SIGCTL: PUBUFPGA Position          */
N#define ANA_SIGCTL_PUBUFPGA_Msk          (0x1ul << ANA_SIGCTL_PUBUFPGA_Pos)                /*!< ANA SIGCTL: PUBUFPGA Mask              */
N
N#define ANA_SIGCTL_PUBUFADC_Pos          (2)                                               /*!< ANA SIGCTL: PUBUFADC Position          */
N#define ANA_SIGCTL_PUBUFADC_Msk          (0x1ul << ANA_SIGCTL_PUBUFADC_Pos)                /*!< ANA SIGCTL: PUBUFADC Mask              */
N
N#define ANA_SIGCTL_PUCURB_Pos            (3)                                               /*!< ANA SIGCTL: PUCURB Position            */
N#define ANA_SIGCTL_PUCURB_Msk            (0x1ul << ANA_SIGCTL_PUCURB_Pos)                  /*!< ANA SIGCTL: PUCURB Mask                */
N
N#define ANA_SIGCTL_PUADCOP_Pos           (4)                                               /*!< ANA SIGCTL: PUADCOP Position           */
N#define ANA_SIGCTL_PUADCOP_Msk           (0x1ul << ANA_SIGCTL_PUADCOP_Pos)                 /*!< ANA SIGCTL: PUADCOP Mask               */
N
N#define ANA_SIGCTL_MUTEPGA_Pos           (5)                                               /*!< ANA SIGCTL: MUTEPGA Position           */
N#define ANA_SIGCTL_MUTEPGA_Msk           (0x1ul << ANA_SIGCTL_MUTEPGA_Pos)                 /*!< ANA SIGCTL: MUTEPGA Mask               */
N
N#define ANA_SIGCTL_MUTEBST_Pos           (6)                                               /*!< ANA SIGCTL: MUTEBST Position           */
N#define ANA_SIGCTL_MUTEBST_Msk           (0x1ul << ANA_SIGCTL_MUTEBST_Pos)                 /*!< ANA SIGCTL: MUTEBST Mask               */
N
N#define ANA_PGAGAIN_GAINSET_Pos          (0)                                               /*!< ANA PGAGAIN: GAINSET Position          */
N#define ANA_PGAGAIN_GAINSET_Msk          (0x3ful << ANA_PGAGAIN_GAINSET_Pos)               /*!< ANA PGAGAIN: GAINSET Mask              */
N
N#define ANA_PGAGAIN_GAINREAD_Pos         (8)                                               /*!< ANA PGAGAIN: GAINREAD Position         */
N#define ANA_PGAGAIN_GAINREAD_Msk         (0x3ful << ANA_PGAGAIN_GAINREAD_Pos)              /*!< ANA PGAGAIN: GAINREAD Mask             */
N
N#define ANA_TRIM_OSCTRIM_Pos             (0)                                               /*!< ANA TRIM: OSCTRIM Position             */
N#define ANA_TRIM_OSCTRIM_Msk             (0xfful << ANA_TRIM_OSCTRIM_Pos)                  /*!< ANA TRIM: OSCTRIM Mask                 */
N
N#define ANA_TRIM_COARSE_Pos              (8)                                               /*!< ANA TRIM: COARSE Position              */
N#define ANA_TRIM_COARSE_Msk              (0xfful << ANA_TRIM_COARSE_Pos)                   /*!< ANA TRIM: COARSE Mask                  */
N
N#define ANA_TRIM_SUPERFINE_Pos           (16)                                              /*!< ANA TRIM: SUPERFINE Position           */
N#define ANA_TRIM_SUPERFINE_Msk           (0xfful << ANA_TRIM_SUPERFINE_Pos)                /*!< ANA TRIM: SUPERFINE Mask               */
N
N#define ANA_CAPSCTL_LOWTIME_Pos          (0)                                               /*!< ANA CAPSCTL: LOWTIME Position          */
N#define ANA_CAPSCTL_LOWTIME_Msk          (0x3ul << ANA_CAPSCTL_LOWTIME_Pos)                /*!< ANA CAPSCTL: LOWTIME Mask              */
N
N#define ANA_CAPSCTL_CYCLECNT_Pos         (2)                                               /*!< ANA CAPSCTL: CYCLECNT Position         */
N#define ANA_CAPSCTL_CYCLECNT_Msk         (0x7ul << ANA_CAPSCTL_CYCLECNT_Pos)               /*!< ANA CAPSCTL: CYCLECNT Mask             */
N
N#define ANA_CAPSCTL_CLKMODE_Pos          (5)                                               /*!< ANA CAPSCTL: CLKMODE Position          */
N#define ANA_CAPSCTL_CLKMODE_Msk          (0x1ul << ANA_CAPSCTL_CLKMODE_Pos)                /*!< ANA CAPSCTL: CLKMODE Mask              */
N
N#define ANA_CAPSCTL_CLKDIV_Pos           (8)                                               /*!< ANA CAPSCTL: CLKDIV Position           */
N#define ANA_CAPSCTL_CLKDIV_Msk           (0xfful << ANA_CAPSCTL_CLKDIV_Pos)                /*!< ANA CAPSCTL: CLKDIV Mask               */
N
N#define ANA_CAPSCTL_RSTCNT_Pos           (29)                                              /*!< ANA CAPSCTL: RSTCNT Position           */
N#define ANA_CAPSCTL_RSTCNT_Msk           (0x1ul << ANA_CAPSCTL_RSTCNT_Pos)                 /*!< ANA CAPSCTL: RSTCNT Mask               */
N
N#define ANA_CAPSCTL_INTEN_Pos            (30)                                              /*!< ANA CAPSCTL: INTEN Position            */
N#define ANA_CAPSCTL_INTEN_Msk            (0x1ul << ANA_CAPSCTL_INTEN_Pos)                  /*!< ANA CAPSCTL: INTEN Mask                */
N
N#define ANA_CAPSCTL_CAPSEN_Pos           (31)                                              /*!< ANA CAPSCTL: CAPSEN Position           */
N#define ANA_CAPSCTL_CAPSEN_Msk           (0x1ul << ANA_CAPSCTL_CAPSEN_Pos)                 /*!< ANA CAPSCTL: CAPSEN Mask               */
N
N#define ANA_CAPSCNT_CAPSCNT_Pos          (0)                                               /*!< ANA CAPSCNT: CAPSCNT Position          */
N#define ANA_CAPSCNT_CAPSCNT_Msk          (0xfffffful << ANA_CAPSCNT_CAPSCNT_Pos)           /*!< ANA CAPSCNT: CAPSCNT Mask              */
N
N#define ANA_FQMMCTL_CLKSEL_Pos           (0)                                               /*!< ANA FQMMCTL: CLKSEL Position           */
N#define ANA_FQMMCTL_CLKSEL_Msk           (0x3ul << ANA_FQMMCTL_CLKSEL_Pos)                 /*!< ANA FQMMCTL: CLKSEL Mask               */
N
N#define ANA_FQMMCTL_MMSTS_Pos            (2)                                               /*!< ANA FQMMCTL: MMSTS Position            */
N#define ANA_FQMMCTL_MMSTS_Msk            (0x1ul << ANA_FQMMCTL_MMSTS_Pos)                  /*!< ANA FQMMCTL: MMSTS Mask                */
N
N#define ANA_FQMMCTL_CYCLESEL_Pos         (16)                                              /*!< ANA FQMMCTL: CYCLESEL Position         */
N#define ANA_FQMMCTL_CYCLESEL_Msk         (0xfful << ANA_FQMMCTL_CYCLESEL_Pos)              /*!< ANA FQMMCTL: CYCLESEL Mask             */
N
N#define ANA_FQMMCTL_FQMMEN_Pos           (31)                                              /*!< ANA FQMMCTL: FQMMEN Position           */
N#define ANA_FQMMCTL_FQMMEN_Msk           (0x1ul << ANA_FQMMCTL_FQMMEN_Pos)                 /*!< ANA FQMMCTL: FQMMEN Mask               */
N
N#define ANA_FQMMCNT_FQMMCNT_Pos          (0)                                               /*!< ANA FQMMCNT: FQMMCNT Position          */
N#define ANA_FQMMCNT_FQMMCNT_Msk          (0xfffful << ANA_FQMMCNT_FQMMCNT_Pos)             /*!< ANA FQMMCNT: FQMMCNT Mask              */
N
N/**@}*/ /* ANA_CONST */
N/**@}*/ /* end of ANA register group */
N
N
N/*---------------------- Biquad Filter -------------------------*/
N/**
N    @addtogroup BIQ Biquad Filter(BIQ)
N    Memory Mapped Structure for BIQ Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * COEFF0
N     * ===================================================================================================
N     * Offset: 0x00  Coefficient b0 In H(z) Transfer Function
N(3.16 format) - 1st stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF0;                
X    volatile uint32_t COEFF0;                
N
N    /**
N     * COEFF1
N     * ===================================================================================================
N     * Offset: 0x04  Coefficient b1 In H(z) Transfer Function
N(3.16 format) - 1st stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF1;                
X    volatile uint32_t COEFF1;                
N
N    /**
N     * COEFF2
N     * ===================================================================================================
N     * Offset: 0x08  Coefficient b2 In H(z) Transfer Function
N(3.16 format) - 1st stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF2;                
X    volatile uint32_t COEFF2;                
N
N    /**
N     * COEFF3
N     * ===================================================================================================
N     * Offset: 0x0C  Coefficient a1 In H(z) Transfer Function
N(3.16 format) - 1st stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF3;                
X    volatile uint32_t COEFF3;                
N
N    /**
N     * COEFF4
N     * ===================================================================================================
N     * Offset: 0x10  Coefficient a2 In H(z) Transfer Function
N(3.16 format) - 1st stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF4;                
X    volatile uint32_t COEFF4;                
N
N    /**
N     * COEFF5
N     * ===================================================================================================
N     * Offset: 0x14  Coefficient b0 In H(z) Transfer Function
N(3.16 format) - 2nd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF5;                
X    volatile uint32_t COEFF5;                
N
N    /**
N     * COEFF6
N     * ===================================================================================================
N     * Offset: 0x18  Coefficient b1 In H(z) Transfer Function
N(3.16 format) - 2nd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF6;                
X    volatile uint32_t COEFF6;                
N
N    /**
N     * COEFF7
N     * ===================================================================================================
N     * Offset: 0x1C  Coefficient b2 In H(z) Transfer Function
N(3.16 format) - 2nd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF7;                
X    volatile uint32_t COEFF7;                
N
N    /**
N     * COEFF8
N     * ===================================================================================================
N     * Offset: 0x20  Coefficient a1 In H(z) Transfer Function
N(3.16 format) - 2nd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF8;                
X    volatile uint32_t COEFF8;                
N
N    /**
N     * COEFF9
N     * ===================================================================================================
N     * Offset: 0x24  Coefficient a2 In H(z) Transfer Function
N(3.16 format) - 2nd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF9;                
X    volatile uint32_t COEFF9;                
N
N    /**
N     * COEFF10
N     * ===================================================================================================
N     * Offset: 0x28  Coefficient b0 In H(z) Transfer Function
N(3.16 format) - 3rd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF10;               
X    volatile uint32_t COEFF10;               
N
N    /**
N     * COEFF11
N     * ===================================================================================================
N     * Offset: 0x2C  Coefficient b1 In H(z) Transfer Function
N(3.16 format) - 3rd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF11;               
X    volatile uint32_t COEFF11;               
N
N    /**
N     * COEFF12
N     * ===================================================================================================
N     * Offset: 0x30  Coefficient b2 In H(z) Transfer Function
N(3.16 format) - 3rd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF12;               
X    volatile uint32_t COEFF12;               
N
N    /**
N     * COEFF13
N     * ===================================================================================================
N     * Offset: 0x34  Coefficient a1 In H(z) Transfer Function
N(3.16 format) - 3rd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF13;               
X    volatile uint32_t COEFF13;               
N
N    /**
N     * COEFF14
N     * ===================================================================================================
N     * Offset: 0x38  Coefficient a2 In H(z) Transfer Function
N(3.16 format) - 3rd stage BIQ Coefficients
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |COEFFDAT  |Coefficient Data
N */
N    __IO uint32_t COEFF14;               
X    volatile uint32_t COEFF14;               
N         uint32_t RESERVE0[1];
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x40  BIQ Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BIQEN     |BIQ Filter Start To Run
N     * |        |          |0 = BIQ filter is not processing
N     * |        |          |1 = BIQ filter is on.
N     * |[1]     |PATHSEL   |AC Path Selection For BIQ
N     * |        |          |0 = used in ADC path
N     * |        |          |1 = used in DPWM path
N     * |[2]     |PRGCOEFF  |Programming Mode Coefficient Control Bit
N     * |        |          |0 = Coefficient RAM is in normal mode.
N     * |        |          |1 = coefficient RAM is under programming mode.
N     * |        |          |This bit must be turned off when BIQEN in on.
N     * |[3]     |DLCOEFF   |Move BIQ Out Of Reset State
N     * |        |          |0 = BIQ filter is in reset state.
N     * |        |          |1 = When this bit is on, the default coefficients will be downloaded to the coefficient ram automatically in 32 internal system clocks.
N     * |        |          |Processor must delay enough time before changing the coefficients or turn the BIQ on.
N     * |[4:6]   |DPWMPUSR  |DPWM Path Up Sample Rate (From SRDIV Result)
N     * |        |          |This register is only used when PATHSEL is set to 1.
N     * |        |          |The operating sample rate for the biquad filter will be.
N     * |        |          |(DPWMPUSR+1)*HCLK/(SRDIV+1).
N     * |        |          |Default value for this register is 3.
N     * |[16:28] |SRDIV     |Sample Rate Divider
N     * |        |          |This register is used to program the operating sampling rate of the biquad filter.
N     * |        |          |The sample rate is defined as.
N     * |        |          |HCLK/(SRDIV+1).
N     * |        |          |Default to 3071 so the sampling rate is 16K when HCLK is 49.152MHz.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N} BIQ_T;
N
N/**
N    @addtogroup BIQ_CONST BIQ Bit Field Definition
N    Constant Definitions for BIQ Controller
N@{ */
N
N#define BIQ_COEFF0_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF0: COEFFDAT Position          */
N#define BIQ_COEFF0_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF0_COEFFDAT_Pos)         /*!< BIQ COEFF0: COEFFDAT Mask              */
N
N#define BIQ_COEFF1_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF1: COEFFDAT Position          */
N#define BIQ_COEFF1_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF1_COEFFDAT_Pos)         /*!< BIQ COEFF1: COEFFDAT Mask              */
N
N#define BIQ_COEFF2_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF2: COEFFDAT Position          */
N#define BIQ_COEFF2_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF2_COEFFDAT_Pos)         /*!< BIQ COEFF2: COEFFDAT Mask              */
N
N#define BIQ_COEFF3_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF3: COEFFDAT Position          */
N#define BIQ_COEFF3_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF3_COEFFDAT_Pos)         /*!< BIQ COEFF3: COEFFDAT Mask              */
N
N#define BIQ_COEFF4_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF4: COEFFDAT Position          */
N#define BIQ_COEFF4_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF4_COEFFDAT_Pos)         /*!< BIQ COEFF4: COEFFDAT Mask              */
N
N#define BIQ_COEFF5_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF5: COEFFDAT Position          */
N#define BIQ_COEFF5_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF5_COEFFDAT_Pos)         /*!< BIQ COEFF5: COEFFDAT Mask              */
N
N#define BIQ_COEFF6_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF6: COEFFDAT Position          */
N#define BIQ_COEFF6_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF6_COEFFDAT_Pos)         /*!< BIQ COEFF6: COEFFDAT Mask              */
N
N#define BIQ_COEFF7_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF7: COEFFDAT Position          */
N#define BIQ_COEFF7_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF7_COEFFDAT_Pos)         /*!< BIQ COEFF7: COEFFDAT Mask              */
N
N#define BIQ_COEFF8_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF8: COEFFDAT Position          */
N#define BIQ_COEFF8_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF8_COEFFDAT_Pos)         /*!< BIQ COEFF8: COEFFDAT Mask              */
N
N#define BIQ_COEFF9_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF9: COEFFDAT Position          */
N#define BIQ_COEFF9_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF9_COEFFDAT_Pos)         /*!< BIQ COEFF9: COEFFDAT Mask              */
N
N#define BIQ_COEFF10_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF10: COEFFDAT Position         */
N#define BIQ_COEFF10_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF10_COEFFDAT_Pos)        /*!< BIQ COEFF10: COEFFDAT Mask             */
N
N#define BIQ_COEFF11_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF11: COEFFDAT Position         */
N#define BIQ_COEFF11_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF11_COEFFDAT_Pos)        /*!< BIQ COEFF11: COEFFDAT Mask             */
N
N#define BIQ_COEFF12_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF12: COEFFDAT Position         */
N#define BIQ_COEFF12_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF12_COEFFDAT_Pos)        /*!< BIQ COEFF12: COEFFDAT Mask             */
N
N#define BIQ_COEFF13_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF13: COEFFDAT Position         */
N#define BIQ_COEFF13_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF13_COEFFDAT_Pos)        /*!< BIQ COEFF13: COEFFDAT Mask             */
N
N#define BIQ_COEFF14_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF14: COEFFDAT Position         */
N#define BIQ_COEFF14_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF14_COEFFDAT_Pos)        /*!< BIQ COEFF14: COEFFDAT Mask             */
N
N#define BIQ_CTL_BIQEN_Pos                (0)                                               /*!< BIQ CTL: BIQEN Position                */
N#define BIQ_CTL_BIQEN_Msk                (0x1ul << BIQ_CTL_BIQEN_Pos)                      /*!< BIQ CTL: BIQEN Mask                    */
N
N#define BIQ_CTL_PATHSEL_Pos              (1)                                               /*!< BIQ CTL: PATHSEL Position              */
N#define BIQ_CTL_PATHSEL_Msk              (0x1ul << BIQ_CTL_PATHSEL_Pos)                    /*!< BIQ CTL: PATHSEL Mask                  */
N
N#define BIQ_CTL_PRGCOEFF_Pos             (2)                                               /*!< BIQ CTL: PRGCOEFF Position             */
N#define BIQ_CTL_PRGCOEFF_Msk             (0x1ul << BIQ_CTL_PRGCOEFF_Pos)                   /*!< BIQ CTL: PRGCOEFF Mask                 */
N
N#define BIQ_CTL_DLCOEFF_Pos              (3)                                               /*!< BIQ CTL: DLCOEFF Position              */
N#define BIQ_CTL_DLCOEFF_Msk              (0x1ul << BIQ_CTL_DLCOEFF_Pos)                    /*!< BIQ CTL: DLCOEFF Mask                  */
N
N#define BIQ_CTL_DPWMPUSR_Pos             (4)                                               /*!< BIQ CTL: DPWMPUSR Position             */
N#define BIQ_CTL_DPWMPUSR_Msk             (0x7ul << BIQ_CTL_DPWMPUSR_Pos)                   /*!< BIQ CTL: DPWMPUSR Mask                 */
N
N#define BIQ_CTL_SRDIV_Pos                (16)                                              /*!< BIQ CTL: SRDIV Position                */
N#define BIQ_CTL_SRDIV_Msk                (0x1ffful << BIQ_CTL_SRDIV_Pos)                   /*!< BIQ CTL: SRDIV Mask                    */
N
N/**@}*/ /* BIQ_CONST */
N/**@}*/ /* end of BIQ register group */
N
N
N/*---------------------- Brownout Detection and Temperature Alarm -------------------------*/
N/**
N    @addtogroup BODTALM Brownout Detection and Temperature Alarm(BODTALM)
N    Memory Mapped Structure for BODTALM Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * BODSEL
N     * ===================================================================================================
N     * Offset: 0x00  Brown Out Detector Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |BODVL     |BOD Voltage Level
N     * |        |          |111b = 4.6V
N     * |        |          |110b = 3.0V
N     * |        |          |101b = 2.8V
N     * |        |          |100b = 2.625V
N     * |        |          |011b = 2.5V
N     * |        |          |010b = 2.4V
N     * |        |          |001b = 2.2V
N     * |        |          |000b = 2.1V
N     * |[3]     |BODHYS    |BOD Hysteresis
N     * |        |          |0= Hysteresis Disabled.
N     * |        |          |1= Enable Hysteresis of BOD detection.
N */
N    __IO uint32_t BODSEL;                
X    volatile uint32_t BODSEL;                
N
N    /**
N     * BODCTL
N     * ===================================================================================================
N     * Offset: 0x04  Brown Out Detector Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |BODEN     |BOD Enable
N     * |        |          |1xb = Enable continuous BOD detection.
N     * |        |          |01b = Enable time multiplexed BOD detection. See BODTALM_BODDTMR register.
N     * |        |          |00b = Disable BOD Detection.
N     * |[2]     |BODINTEN  |BOD Interrupt Enable
N     * |        |          |0= Disable BOD Interrupt.
N     * |        |          |1= Enable BOD Interrupt.
N     * |[3]     |BODIF     |Current Status Of Interrupt
N     * |        |          |Latched whenever a BOD event occurs and BODINTEN = 1. Write '1' to clear.
N     * |[4]     |BODOUT    |Output of BOD Detection Block
N     * |        |          |This signal can be monitored to determine the current state of the BOD comparator.
N     * |        |          |Read '1' implies that VCC is less than BODVL.
N */
N    __IO uint32_t BODCTL;                
X    volatile uint32_t BODCTL;                
N
N    /**
N     * TALMSEL
N     * ===================================================================================================
N     * Offset: 0x08  Temperature Alarm Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |TALMVL    |Temperature Alarm Sense Level
N     * |        |          |0000:105C
N     * |        |          |0001:115C
N     * |        |          |0010:125C
N     * |        |          |0100:135C
N     * |        |          |1000:145C
N */
N    __IO uint32_t TALMSEL;               
X    volatile uint32_t TALMSEL;               
N
N    /**
N     * TALMCTL
N     * ===================================================================================================
N     * Offset: 0x0C  Temperature Alarm Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TALMEN    |TALARM Enable
N     * |        |          |0 = Disable TALARM Detection
N     * |        |          |1 = Enable TALARM Detection
N     * |[1]     |TALMOUT   |Output of TALARM Block
N     * |        |          |Can be polled to determine whether TALARM active (be 1).
N     * |[2]     |TALMIEN   |TALARM Interrupt Enable
N     * |        |          |0 = Disable TALARM Interrupt
N     * |        |          |1 = Enable TALARM Interrupt
N     * |[3]     |TALMIF    |Current status of interrupt
N     * |        |          |Latched whenever a Temperature Sense event occurs and IE = 1. Write '1' to clear.
N */
N    __IO uint32_t TALMCTL;               
X    volatile uint32_t TALMCTL;               
N
N    /**
N     * BODDTMR
N     * ===================================================================================================
N     * Offset: 0x10  Brown Out Detector Timer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |DURTOFF   |Time BOD Detector Is Off
N     * |        |          |(DURTOFF+1)*100us . Minimum value is 7. (default is 99.6ms)
N     * |[16:19] |DURTON    |Time BOD Detector Is Active
N     * |        |          |(DURTON+1) * 100us. Minimum value is 1. (default is 400us)
N */
N    __IO uint32_t BODDTMR;               
X    volatile uint32_t BODDTMR;               
N
N} BODTALM_T;
N
N/**
N    @addtogroup BODTALM_CONST BODTALM Bit Field Definition
N    Constant Definitions for BODTALM Controller
N@{ */
N
N#define BODTALM_BODSEL_BODVL_Pos         (0)                                               /*!< BODTALM BODSEL: BODVL Position         */
N#define BODTALM_BODSEL_BODVL_Msk         (0x7ul << BODTALM_BODSEL_BODVL_Pos)               /*!< BODTALM BODSEL: BODVL Mask             */
N
N#define BODTALM_BODSEL_BODHYS_Pos        (3)                                               /*!< BODTALM BODSEL: BODHYS Position        */
N#define BODTALM_BODSEL_BODHYS_Msk        (0x1ul << BODTALM_BODSEL_BODHYS_Pos)              /*!< BODTALM BODSEL: BODHYS Mask            */
N
N#define BODTALM_BODCTL_BODEN_Pos         (0)                                               /*!< BODTALM BODCTL: BODEN Position         */
N#define BODTALM_BODCTL_BODEN_Msk         (0x3ul << BODTALM_BODCTL_BODEN_Pos)               /*!< BODTALM BODCTL: BODEN Mask             */
N
N#define BODTALM_BODCTL_BODINTEN_Pos      (2)                                               /*!< BODTALM BODCTL: BODINTEN Position      */
N#define BODTALM_BODCTL_BODINTEN_Msk      (0x1ul << BODTALM_BODCTL_BODINTEN_Pos)            /*!< BODTALM BODCTL: BODINTEN Mask          */
N
N#define BODTALM_BODCTL_BODIF_Pos         (3)                                               /*!< BODTALM BODCTL: BODIF Position         */
N#define BODTALM_BODCTL_BODIF_Msk         (0x1ul << BODTALM_BODCTL_BODIF_Pos)               /*!< BODTALM BODCTL: BODIF Mask             */
N
N#define BODTALM_BODCTL_BODOUT_Pos        (4)                                               /*!< BODTALM BODCTL: BODOUT Position        */
N#define BODTALM_BODCTL_BODOUT_Msk        (0x1ul << BODTALM_BODCTL_BODOUT_Pos)              /*!< BODTALM BODCTL: BODOUT Mask            */
N
N#define BODTALM_TALMSEL_TALMVL_Pos       (0)                                               /*!< BODTALM TALMSEL: TALMVL Position       */
N#define BODTALM_TALMSEL_TALMVL_Msk       (0xful << BODTALM_TALMSEL_TALMVL_Pos)             /*!< BODTALM TALMSEL: TALMVL Mask           */
N
N#define BODTALM_TALMCTL_TALMEN_Pos       (0)                                               /*!< BODTALM TALMCTL: TALMEN Position       */
N#define BODTALM_TALMCTL_TALMEN_Msk       (0x1ul << BODTALM_TALMCTL_TALMEN_Pos)             /*!< BODTALM TALMCTL: TALMEN Mask           */
N
N#define BODTALM_TALMCTL_TALMOUT_Pos      (1)                                               /*!< BODTALM TALMCTL: TALMOUT Position      */
N#define BODTALM_TALMCTL_TALMOUT_Msk      (0x1ul << BODTALM_TALMCTL_TALMOUT_Pos)            /*!< BODTALM TALMCTL: TALMOUT Mask          */
N
N#define BODTALM_TALMCTL_TALMIEN_Pos      (2)                                               /*!< BODTALM TALMCTL: TALMIEN Position      */
N#define BODTALM_TALMCTL_TALMIEN_Msk      (0x1ul << BODTALM_TALMCTL_TALMIEN_Pos)            /*!< BODTALM TALMCTL: TALMIEN Mask          */
N
N#define BODTALM_TALMCTL_TALMIF_Pos       (3)                                               /*!< BODTALM TALMCTL: TALMIF Position       */
N#define BODTALM_TALMCTL_TALMIF_Msk       (0x1ul << BODTALM_TALMCTL_TALMIF_Pos)             /*!< BODTALM TALMCTL: TALMIF Mask           */
N
N#define BODTALM_BODDTMR_DURTOFF_Pos      (0)                                               /*!< BODTALM BODDTMR: DURTOFF Position      */
N#define BODTALM_BODDTMR_DURTOFF_Msk      (0xfffful << BODTALM_BODDTMR_DURTOFF_Pos)         /*!< BODTALM BODDTMR: DURTOFF Mask          */
N
N#define BODTALM_BODDTMR_DURTON_Pos       (16)                                              /*!< BODTALM BODDTMR: DURTON Position       */
N#define BODTALM_BODDTMR_DURTON_Msk       (0xful << BODTALM_BODDTMR_DURTON_Pos)             /*!< BODTALM BODDTMR: DURTON Mask           */
N
N/**@}*/ /* BODTALM_CONST */
N/**@}*/ /* end of BODTALM register group */
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * PWRCTL
N     * ===================================================================================================
N     * Offset: 0x00  System Power Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |LXTEN     |External 32.768 kHz Crystal Enable Bit
N     * |        |          |0 = disable (default)
N     * |        |          |1 = enable
N     * |[2]     |HIRCEN    |OSC49M Oscillator Enable Bit
N     * |        |          |0 = disable
N     * |        |          |1 = enable (default)
N     * |[3]     |LIRCEN    |OSC16K Oscillator Enable Bit
N     * |        |          |0 = disable
N     * |        |          |1 = enable (default)
N     * |[9]     |STOP      |Stop
N     * |        |          |Reserved - do not set to '1'
N     * |[10]    |SPDEN     |Standby Power Down (SPD) Bit
N     * |        |          |Set to '1' and issue WFI/WFE instruction to enter SPD mode.
N     * |[11]    |DPDEN     |Deep Power Down (DPD) Bit
N     * |        |          |Set to '1' and issue WFI/WFE instruction to enter DPD mode.
N     * |[16]    |WKPINEN   |Wakeup Pin Enabled Control
N     * |        |          |Determines whether WAKEUP pin is enabled in DPD mode.
N     * |        |          |0 = enabled
N     * |        |          |1 = disabled
N     * |[17]    |LIRCDPDEN |OSC16K Enabled Control
N     * |        |          |Determines whether OSC16K is enabled in DPD mode.
N     * |        |          |If OSC16K is disabled, device cannot wake from DPD with SELWKTMR delay.
N     * |        |          |0 = enabled
N     * |        |          |1 = disabled
N     * |[20:23] |SELWKTMR  |Select Wakeup Timer
N     * |        |          |SELWKTMR[0] = 1: WAKEUP after 128 OSC16K clocks (12.8 ms)
N     * |        |          |SELWKTMR[1] = 1: WAKEUP after 256 OSC16K clocks (25.6 ms)
N     * |        |          |SELWKTMR[2] = 1: WAKEUP after 512 OSC16K clocks (51.2 ms)
N     * |        |          |SELWKTMR[3] = 1: WAKEUP after 1024 OSC16K clocks (102.4ms)
N     * |[24]    |WKPINWKF  |Pin Wakeup Flag
N     * |        |          |Read Only.
N     * |        |          |This flag indicates that wakeup of device was requested with a high to low transition of the WAKEUP pin.
N     * |        |          |Flag is cleared when DPD mode is entered.
N     * |[25]    |TMRWKF    |Timer Wakeup Flag
N     * |        |          |Read Only.
N     * |        |          |This flag indicates that wakeup of device was requested with TIMER count of the 16Khz oscillator.
N     * |        |          |Flag is cleared when DPD mode is entered.
N     * |[26]    |PORWKF    |POI Wakeup Flag
N     * |        |          |Read Only.
N     * |        |          |This flag indicates that wakeup of device was requested with a power-on reset.
N     * |        |          |Flag is cleared when DPD mode is entered.
N     * |[28:31] |WKTMRSTS  |Current Wakeup Timer Setting
N     * |        |          |Read-Only.
N     * |        |          |Read back of the current WAKEUP timer setting.
N     * |        |          |This value is updated with SELWKTMR upon entering DPD mode.
N */
N    __IO uint32_t PWRCTL;                
X    volatile uint32_t PWRCTL;                
N
N    /**
N     * AHBCLK
N     * ===================================================================================================
N     * Offset: 0x04  AHB Device Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HCLKEN    |CPU Clock Enable (HCLK)
N     * |        |          |Must be left as '1' for normal operation.
N     * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Control
N     * |        |          |0 = To disable the PDMA engine clock
N     * |        |          |1 = To enable the PDMA engine clock.
N     * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Control
N     * |        |          |0 = To disable the Flash ISP engine clock.
N     * |        |          |1 = To enable the Flash ISP engine clock.
N */
N    __IO uint32_t AHBCLK;                
X    volatile uint32_t AHBCLK;                
N
N    /**
N     * APBCLK0
N     * ===================================================================================================
N     * Offset: 0x08  APB Device Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |WDTCKEN   |Watchdog Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[5]     |RTCCKEN   |Real-Time-Clock APB Interface Clock Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[6]     |TMR0CKEN  |Timer0 Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[7]     |TMR1CKEN  |Timer1 Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[8]     |I2C0CKEN  |I2C0 Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[12]    |SPI0CKEN  |SPI0 Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[13]    |DPWMCKEN  |Differential PWM Speaker Driver Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[16]    |UARTCKEN  |UART0 Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[18]    |BFALCKEN  |Biquad Filter And Automatic Level Control Block Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[19]    |CRCCKEN   |Cyclic Redundancy Check Block Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[20]    |PWM0CH01CKEN|PWM0 CH0 and CH1 Block Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[22]    |ACMPCKEN  |Analog Comparator Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[26]    |SBRAMCKEN |Standby RAM Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[28]    |ADCCKEN   |Audio Analog-Digital-Converter (ADC) Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[29]    |I2S0CKEN  |I2S Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[30]    |ANACKEN   |Analog Block Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N */
N    __IO uint32_t APBCLK0;               
X    volatile uint32_t APBCLK0;               
N
N    /**
N     * DPDSTATE
N     * ===================================================================================================
N     * Offset: 0x0C  Deep Power Down State Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |DPDSTSWR  |DPD State Write
N     * |        |          |To set the CLK_DPDSTATE register, write value to this register. Data is latched on next DPD event. 
N     * |[8:15]  |DPDSTSRD  |DPD State Read Back
N     * |        |          |Read back of CLK_DPDSTATE register. This register was preserved from last DPD event . 
N */
N    __IO uint32_t DPDSTATE;              
X    volatile uint32_t DPDSTATE;              
N
N    /**
N     * CLKSEL0
N     * ===================================================================================================
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |HCLKSEL   |HCLK Clock Source Select
N     * |        |          |Ensure that related clock sources (pre-select and new-select) are enabled before updating register.
N     * |        |          |These bits are protected, to write to bits first perform the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
N     * |        |          |000 = clock source from internal OSC48M oscillator.
N     * |        |          |001 = clock source from external 32kHz crystal clock
N     * |        |          |010 = clock source from internal 16 kHz oscillator clock
N     * |        |          |Others = reserved
N     * |[3:5]   |STCLKSEL  |MCU Cortex_M0 SysTick Clock Source Select
N     * |        |          |These bits are protected, to write to bits first perform the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
N     * |        |          |000 = clock source from 16 kHz internal clock
N     * |        |          |001 = clock source from external 32kHz crystal clock
N     * |        |          |010 = clock source from 16 kHz internal oscillator divided by 2
N     * |        |          |011 = clock source from OSC49M internal oscillator divided by 2
N     * |        |          |1xx = clock source from HCLK / 2 (Default)
N     * |        |          |Note that to use STCLKSEL as source of SysTic timer the CLKSRC bit of SYST_CSR must be set to 0.
N     * |[6]     |HIRCFSEL  |OSC48M Frequency Select
N     * |        |          |Determines which trim setting to use for OSC48M internal oscillator.
N     * |        |          |Oscillator is factory trimmed within 1% to:.
N     * |        |          |0= 49.152MHz (Default)
N     * |        |          |1= 32.768MHz
N */
N    __IO uint32_t CLKSEL0;               
X    volatile uint32_t CLKSEL0;               
N
N    /**
N     * CLKSEL1
N     * ===================================================================================================
N     * Offset: 0x14  Clock Source Select Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |WDTSEL    |WDT CLK Clock Source Select
N     * |        |          |00 = clock source from internal OSC48M oscillator clock
N     * |        |          |01 = clock source from external 32kHz crystal clock
N     * |        |          |10 = clock source from HCLK/2048 clock
N     * |        |          |11 = clock source from internal 16 kHz oscillator clock
N     * |[4]     |DPWMCKSEL |Differential Speaker Driver PWM Clock Source Select
N     * |        |          |0 = OSC48M clock
N     * |        |          |1 = 2x OSC48M clock
N     * |[8:10]  |TMR0SEL   |TIMER0 Clock Source Select
N     * |        |          |000 = clock source from internal 16 kHz oscillator
N     * |        |          |001 = clock source from external 32kHz crystal clock
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external pin (GPIOA[14])
N     * |        |          |1xx = clock source from internal OSC48M oscillator clock
N     * |[12:14] |TMR1SEL   |TIMER1 Clock Source Select
N     * |        |          |000 = clock source from internal 16 kHz oscillator
N     * |        |          |001 = clock source from external 32kHz crystal clock
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external pin (GPIOA[15])
N     * |        |          |1xx = clock source from internal OSC48M oscillator clock
N     * |[28:29] |PWM0CH01CKSEL|PWM0 CH0 and CH1 Clock Source Select
N     * |        |          |PWM0 and PWM1 uses the same clock source, and prescaler
N     * |        |          |00 = clock source from internal 16 kHz oscillator
N     * |        |          |01 = clock source from external 32kHz crystal clock
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal OSC48M oscillator clock
N */
N    __IO uint32_t CLKSEL1;               
X    volatile uint32_t CLKSEL1;               
N
N    /**
N     * CLKDIV0
N     * ===================================================================================================
N     * Offset: 0x18  Clock Divider Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
N     * |        |          |The HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1)
N     * |[8:11]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
N     * |        |          |The UART clock frequency = (UART clock source frequency ) / (UARTDIV + 1)
N     * |[16:23] |ADCDIV    |ADC Clock Divide Number From ADC Clock Source
N     * |        |          |The ADC clock frequency = (ADC clock source frequency ) / (ADCDIV + 1)
N */
N    __IO uint32_t CLKDIV0;               
X    volatile uint32_t CLKDIV0;               
N
N    /**
N     * CLKSEL2
N     * ===================================================================================================
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |I2S0SEL   |I2S Clock Source Select
N     * |        |          |00 = clock source from internal 16 kHz oscillator
N     * |        |          |01 = clock source from external 32kHz crystal clock
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal OSC48M oscillator clock
N */
N    __IO uint32_t CLKSEL2;               
X    volatile uint32_t CLKSEL2;               
N
N    /**
N     * SLEEPCTL
N     * ===================================================================================================
N     * Offset: 0x20  Sleep Clock Source Select  Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HCLKEN    |CPU Clock Sleep Enable (HCLK)
N     * |        |          |Must be left as '1' for normal operation.
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[1]     |PDMACKEN  |PDMA Controller Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[2]     |ISPCKEN   |Flash ISP Controller Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[4]     |WDTCKEN   |Watchdog Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[5]     |RTCCKEN   |Real-Time- Sleep Clock APB Interface Clock Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[6]     |TMR0CKEN  |Timer0 Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[7]     |TMR1CKEN  |Timer1 Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[8]     |I2C0CKEN  |I2C0 Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[12]    |SPI0CKEN  |SPI0 Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[13]    |DPWMCKEN  |Differential PWM Speaker Driver Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[16]    |UARTCKEN  |UART0 Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[18]    |BFALCKEN  |Biquad filter/ALC block Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[19]    |CRCCKEN   |Cyclic Redundancy Check Sleep Block Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[20]    |PWM0CH01CKEN|PWM0 CH0 and CH1 Block Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[22]    |ACMPCKEN  |Analog Comparator Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[26]    |SBRAMCKEN |Standby RAM Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[28]    |ADCCKEN   |Audio Analog-Digital-Converter (ADC) Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[29]    |I2S0CKEN  |I2S Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[30]    |ANACKEN   |Analog Block Sleep Clock Enable Control
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N */
N    __IO uint32_t SLEEPCTL;              
X    volatile uint32_t SLEEPCTL;              
N
N    /**
N     * PWRSTSF
N     * ===================================================================================================
N     * Offset: 0x24  Power State Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DSF       |Deep Sleep Flag
N     * |        |          |This flag is set if core logic was placed in Deep Sleep mode. Write '1' to clear flag.
N     * |[1]     |STOPF     |Stop Flag
N     * |        |          |This flag is set if core logic was stopped but not powered down. Write '1' to clear flag.
N     * |[2]     |SPDF      |Powered Down Flag
N     * |        |          |This flag is set if core logic was powered down to Standby (SPD). Write '1' to clear flag.
N */
N    __IO uint32_t PWRSTSF;               
X    volatile uint32_t PWRSTSF;               
N
N    /**
N     * DBGPD
N     * ===================================================================================================
N     * Offset: 0x28  Debug Port Power Down Disable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DISPDREQ  |Disable Power Down
N     * |        |          |0 = Enable power down requests.
N     * |        |          |1 = Disable power down requests.
N     * |[6]     |ICECLKST  |ICE_CLK Pin State
N     * |        |          |Read Only. Current state of ICE_CLK pin.
N     * |[7]     |ICEDATST  |ICE_DAT Pin State
N     * |        |          |Read Only. Current state of ICE_DAT pin.
N */
N    __IO uint32_t DBGPD;                 
X    volatile uint32_t DBGPD;                 
N
N} CLK_T;
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK PWRCTL: LXTEN Position             */
N#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK PWRCTL: LXTEN Mask                 */
N
N#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK PWRCTL: HIRCEN Position            */
N#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK PWRCTL: HIRCEN Mask                */
N
N#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK PWRCTL: LIRCEN Position            */
N#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK PWRCTL: LIRCEN Mask                */
N
N#define CLK_PWRCTL_STOP_Pos              (9)                                               /*!< CLK PWRCTL: STOP Position              */
N#define CLK_PWRCTL_STOP_Msk              (0x1ul << CLK_PWRCTL_STOP_Pos)                    /*!< CLK PWRCTL: STOP Mask                  */
N
N#define CLK_PWRCTL_SPDEN_Pos             (10)                                              /*!< CLK PWRCTL: SPDEN Position             */
N#define CLK_PWRCTL_SPDEN_Msk             (0x1ul << CLK_PWRCTL_SPDEN_Pos)                   /*!< CLK PWRCTL: SPDEN Mask                 */
N
N#define CLK_PWRCTL_DPDEN_Pos             (11)                                              /*!< CLK PWRCTL: DPDEN Position             */
N#define CLK_PWRCTL_DPDEN_Msk             (0x1ul << CLK_PWRCTL_DPDEN_Pos)                   /*!< CLK PWRCTL: DPDEN Mask                 */
N
N#define CLK_PWRCTL_WKPINEN_Pos           (16)                                              /*!< CLK PWRCTL: WKPINEN Position           */
N#define CLK_PWRCTL_WKPINEN_Msk           (0x1ul << CLK_PWRCTL_WKPINEN_Pos)                 /*!< CLK PWRCTL: WKPINEN Mask               */
N
N#define CLK_PWRCTL_LIRCDPDEN_Pos         (17)                                              /*!< CLK PWRCTL: LIRCDPDEN Position         */
N#define CLK_PWRCTL_LIRCDPDEN_Msk         (0x1ul << CLK_PWRCTL_LIRCDPDEN_Pos)               /*!< CLK PWRCTL: LIRCDPDEN Mask             */
N
N#define CLK_PWRCTL_SELWKTMR_Pos          (20)                                              /*!< CLK PWRCTL: SELWKTMR Position          */
N#define CLK_PWRCTL_SELWKTMR_Msk          (0xful << CLK_PWRCTL_SELWKTMR_Pos)                /*!< CLK PWRCTL: SELWKTMR Mask              */
N
N#define CLK_PWRCTL_WKPINWKF_Pos          (24)                                              /*!< CLK PWRCTL: WKPINWKF Position          */
N#define CLK_PWRCTL_WKPINWKF_Msk          (0x1ul << CLK_PWRCTL_WKPINWKF_Pos)                /*!< CLK PWRCTL: WKPINWKF Mask              */
N
N#define CLK_PWRCTL_TMRWKF_Pos            (25)                                              /*!< CLK PWRCTL: TMRWKF Position            */
N#define CLK_PWRCTL_TMRWKF_Msk            (0x1ul << CLK_PWRCTL_TMRWKF_Pos)                  /*!< CLK PWRCTL: TMRWKF Mask                */
N
N#define CLK_PWRCTL_PORWKF_Pos            (26)                                              /*!< CLK PWRCTL: PORWKF Position            */
N#define CLK_PWRCTL_PORWKF_Msk            (0x1ul << CLK_PWRCTL_PORWKF_Pos)                  /*!< CLK PWRCTL: PORWKF Mask                */
N
N#define CLK_PWRCTL_WKTMRSTS_Pos          (28)                                              /*!< CLK PWRCTL: WKTMRSTS Position          */
N#define CLK_PWRCTL_WKTMRSTS_Msk          (0xful << CLK_PWRCTL_WKTMRSTS_Pos)                /*!< CLK PWRCTL: WKTMRSTS Mask              */
N
N#define CLK_AHBCLK_HCLKEN_Pos            (0)                                               /*!< CLK AHBCLK: HCLKEN Position            */
N#define CLK_AHBCLK_HCLKEN_Msk            (0x1ul << CLK_AHBCLK_HCLKEN_Pos)                  /*!< CLK AHBCLK: HCLKEN Mask                */
N
N#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK AHBCLK: PDMACKEN Position          */
N#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK AHBCLK: PDMACKEN Mask              */
N
N#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK AHBCLK: ISPCKEN Position           */
N#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK AHBCLK: ISPCKEN Mask               */
N
N#define CLK_APBCLK0_WDTCKEN_Pos          (4)                                               /*!< CLK APBCLK0: WDTCKEN Position          */
N#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK APBCLK0: WDTCKEN Mask              */
N
N#define CLK_APBCLK0_RTCCKEN_Pos          (5)                                               /*!< CLK APBCLK0: RTCCKEN Position          */
N#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK APBCLK0: RTCCKEN Mask              */
N
N#define CLK_APBCLK0_TMR0CKEN_Pos         (6)                                               /*!< CLK APBCLK0: TMR0CKEN Position         */
N#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK APBCLK0: TMR0CKEN Mask             */
N
N#define CLK_APBCLK0_TMR1CKEN_Pos         (7)                                               /*!< CLK APBCLK0: TMR1CKEN Position         */
N#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK APBCLK0: TMR1CKEN Mask             */
N
N#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK APBCLK0: I2C0CKEN Position         */
N#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK APBCLK0: I2C0CKEN Mask             */
N
N#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK APBCLK0: SPI0CKEN Position         */
N#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK APBCLK0: SPI0CKEN Mask             */
N
N#define CLK_APBCLK0_DPWMCKEN_Pos         (13)                                              /*!< CLK APBCLK0: DPWMCKEN Position         */
N#define CLK_APBCLK0_DPWMCKEN_Msk         (0x1ul << CLK_APBCLK0_DPWMCKEN_Pos)               /*!< CLK APBCLK0: DPWMCKEN Mask             */
N
N#define CLK_APBCLK0_UARTCKEN_Pos         (16)                                              /*!< CLK APBCLK0: UARTCKEN Position         */
N#define CLK_APBCLK0_UARTCKEN_Msk         (0x1ul << CLK_APBCLK0_UARTCKEN_Pos)               /*!< CLK APBCLK0: UARTCKEN Mask             */
N
N#define CLK_APBCLK0_BFALCKEN_Pos         (18)                                              /*!< CLK APBCLK0: BFALCKEN Position         */
N#define CLK_APBCLK0_BFALCKEN_Msk         (0x1ul << CLK_APBCLK0_BFALCKEN_Pos)               /*!< CLK APBCLK0: BFALCKEN Mask             */
N
N#define CLK_APBCLK0_CRCCKEN_Pos          (19)                                              /*!< CLK APBCLK0: CRCCKEN Position          */
N#define CLK_APBCLK0_CRCCKEN_Msk          (0x1ul << CLK_APBCLK0_CRCCKEN_Pos)                /*!< CLK APBCLK0: CRCCKEN Mask              */
N
N#define CLK_APBCLK0_PWM0CH01CKEN_Pos     (20)                                              /*!< CLK APBCLK0: PWM0CH01CKEN Position     */
N#define CLK_APBCLK0_PWM0CH01CKEN_Msk     (0x1ul << CLK_APBCLK0_PWM0CH01CKEN_Pos)           /*!< CLK APBCLK0: PWM0CH01CKEN Mask         */
N
N#define CLK_APBCLK0_ACMPCKEN_Pos         (22)                                              /*!< CLK APBCLK0: ACMPCKEN Position         */
N#define CLK_APBCLK0_ACMPCKEN_Msk         (0x1ul << CLK_APBCLK0_ACMPCKEN_Pos)               /*!< CLK APBCLK0: ACMPCKEN Mask             */
N
N#define CLK_APBCLK0_SBRAMCKEN_Pos        (26)                                              /*!< CLK APBCLK0: SBRAMCKEN Position        */
N#define CLK_APBCLK0_SBRAMCKEN_Msk        (0x1ul << CLK_APBCLK0_SBRAMCKEN_Pos)              /*!< CLK APBCLK0: SBRAMCKEN Mask            */
N
N#define CLK_APBCLK0_ADCCKEN_Pos          (28)                                              /*!< CLK APBCLK0: ADCCKEN Position          */
N#define CLK_APBCLK0_ADCCKEN_Msk          (0x1ul << CLK_APBCLK0_ADCCKEN_Pos)                /*!< CLK APBCLK0: ADCCKEN Mask              */
N
N#define CLK_APBCLK0_I2S0CKEN_Pos         (29)                                              /*!< CLK APBCLK0: I2S0CKEN Position         */
N#define CLK_APBCLK0_I2S0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2S0CKEN_Pos)               /*!< CLK APBCLK0: I2S0CKEN Mask             */
N
N#define CLK_APBCLK0_ANACKEN_Pos          (30)                                              /*!< CLK APBCLK0: ANACKEN Position          */
N#define CLK_APBCLK0_ANACKEN_Msk          (0x1ul << CLK_APBCLK0_ANACKEN_Pos)                /*!< CLK APBCLK0: ANACKEN Mask              */
N
N#define CLK_DPDSTATE_DPDSTSWR_Pos        (0)                                               /*!< CLK DPDSTATE: DPDSTSWR Position        */
N#define CLK_DPDSTATE_DPDSTSWR_Msk        (0xfful << CLK_DPDSTATE_DPDSTSWR_Pos)             /*!< CLK DPDSTATE: DPDSTSWR Mask            */
N
N#define CLK_DPDSTATE_DPDSTSRD_Pos        (8)                                               /*!< CLK DPDSTATE: DPDSTSRD Position        */
N#define CLK_DPDSTATE_DPDSTSRD_Msk        (0xfful << CLK_DPDSTATE_DPDSTSRD_Pos)             /*!< CLK DPDSTATE: DPDSTSRD Mask            */
N
N#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK CLKSEL0: HCLKSEL Position          */
N#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK CLKSEL0: HCLKSEL Mask              */
N
N#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK CLKSEL0: STCLKSEL Position         */
N#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK CLKSEL0: STCLKSEL Mask             */
N
N#define CLK_CLKSEL0_HIRCFSEL_Pos         (6)                                               /*!< CLK CLKSEL0: HIRCFSEL Position         */
N#define CLK_CLKSEL0_HIRCFSEL_Msk         (0x1ul << CLK_CLKSEL0_HIRCFSEL_Pos)               /*!< CLK CLKSEL0: HIRCFSEL Mask             */
N
N#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK CLKSEL1: WDTSEL Position           */
N#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK CLKSEL1: WDTSEL Mask               */
N
N#define CLK_CLKSEL1_DPWMCKSEL_Pos        (4)                                               /*!< CLK CLKSEL1: DPWMCKSEL Position        */
N#define CLK_CLKSEL1_DPWMCKSEL_Msk        (0x1ul << CLK_CLKSEL1_DPWMCKSEL_Pos)              /*!< CLK CLKSEL1: DPWMCKSEL Mask            */
N
N#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK CLKSEL1: TMR0SEL Position          */
N#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK CLKSEL1: TMR0SEL Mask              */
N
N#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK CLKSEL1: TMR1SEL Position          */
N#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK CLKSEL1: TMR1SEL Mask              */
N
N#define CLK_CLKSEL1_PWM0CH01CKSEL_Pos    (28)                                              /*!< CLK CLKSEL1: PWM0CH01CKSEL Position    */
N#define CLK_CLKSEL1_PWM0CH01CKSEL_Msk    (0x3ul << CLK_CLKSEL1_PWM0CH01CKSEL_Pos)          /*!< CLK CLKSEL1: PWM0CH01CKSEL Mask        */
N
N#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK CLKDIV0: HCLKDIV Position          */
N#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK CLKDIV0: HCLKDIV Mask              */
N
N#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK CLKDIV0: UARTDIV Position          */
N#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK CLKDIV0: UARTDIV Mask              */
N
N#define CLK_CLKDIV0_ADCDIV_Pos           (16)                                              /*!< CLK CLKDIV0: ADCDIV Position           */
N#define CLK_CLKDIV0_ADCDIV_Msk           (0xfful << CLK_CLKDIV0_ADCDIV_Pos)                /*!< CLK CLKDIV0: ADCDIV Mask               */
N
N#define CLK_CLKSEL2_I2S0SEL_Pos          (0)                                               /*!< CLK CLKSEL2: I2S0SEL Position          */
N#define CLK_CLKSEL2_I2S0SEL_Msk          (0x3ul << CLK_CLKSEL2_I2S0SEL_Pos)                /*!< CLK CLKSEL2: I2S0SEL Mask              */
N
N#define CLK_SLEEPCTL_HCLKEN_Pos          (0)                                               /*!< CLK SLEEPCTL: HCLKEN Position          */
N#define CLK_SLEEPCTL_HCLKEN_Msk          (0x1ul << CLK_SLEEPCTL_HCLKEN_Pos)                /*!< CLK SLEEPCTL: HCLKEN Mask              */
N
N#define CLK_SLEEPCTL_PDMACKEN_Pos        (1)                                               /*!< CLK SLEEPCTL: PDMACKEN Position        */
N#define CLK_SLEEPCTL_PDMACKEN_Msk        (0x1ul << CLK_SLEEPCTL_PDMACKEN_Pos)              /*!< CLK SLEEPCTL: PDMACKEN Mask            */
N
N#define CLK_SLEEPCTL_ISPCKEN_Pos         (2)                                               /*!< CLK SLEEPCTL: ISPCKEN Position         */
N#define CLK_SLEEPCTL_ISPCKEN_Msk         (0x1ul << CLK_SLEEPCTL_ISPCKEN_Pos)               /*!< CLK SLEEPCTL: ISPCKEN Mask             */
N
N#define CLK_SLEEPCTL_WDTCKEN_Pos         (4)                                               /*!< CLK SLEEPCTL: WDTCKEN Position         */
N#define CLK_SLEEPCTL_WDTCKEN_Msk         (0x1ul << CLK_SLEEPCTL_WDTCKEN_Pos)               /*!< CLK SLEEPCTL: WDTCKEN Mask             */
N
N#define CLK_SLEEPCTL_RTCCKEN_Pos         (5)                                               /*!< CLK SLEEPCTL: RTCCKEN Position         */
N#define CLK_SLEEPCTL_RTCCKEN_Msk         (0x1ul << CLK_SLEEPCTL_RTCCKEN_Pos)               /*!< CLK SLEEPCTL: RTCCKEN Mask             */
N
N#define CLK_SLEEPCTL_TMR0CKEN_Pos        (6)                                               /*!< CLK SLEEPCTL: TMR0CKEN Position        */
N#define CLK_SLEEPCTL_TMR0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_TMR0CKEN_Pos)              /*!< CLK SLEEPCTL: TMR0CKEN Mask            */
N
N#define CLK_SLEEPCTL_TMR1CKEN_Pos        (7)                                               /*!< CLK SLEEPCTL: TMR1CKEN Position        */
N#define CLK_SLEEPCTL_TMR1CKEN_Msk        (0x1ul << CLK_SLEEPCTL_TMR1CKEN_Pos)              /*!< CLK SLEEPCTL: TMR1CKEN Mask            */
N
N#define CLK_SLEEPCTL_I2C0CKEN_Pos        (8)                                               /*!< CLK SLEEPCTL: I2C0CKEN Position        */
N#define CLK_SLEEPCTL_I2C0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_I2C0CKEN_Pos)              /*!< CLK SLEEPCTL: I2C0CKEN Mask            */
N
N#define CLK_SLEEPCTL_SPI0CKEN_Pos        (12)                                              /*!< CLK SLEEPCTL: SPI0CKEN Position        */
N#define CLK_SLEEPCTL_SPI0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_SPI0CKEN_Pos)              /*!< CLK SLEEPCTL: SPI0CKEN Mask            */
N
N#define CLK_SLEEPCTL_DPWMCKEN_Pos        (13)                                              /*!< CLK SLEEPCTL: DPWMCKEN Position        */
N#define CLK_SLEEPCTL_DPWMCKEN_Msk        (0x1ul << CLK_SLEEPCTL_DPWMCKEN_Pos)              /*!< CLK SLEEPCTL: DPWMCKEN Mask            */
N
N#define CLK_SLEEPCTL_UARTCKEN_Pos        (16)                                              /*!< CLK SLEEPCTL: UARTCKEN Position        */
N#define CLK_SLEEPCTL_UARTCKEN_Msk        (0x1ul << CLK_SLEEPCTL_UARTCKEN_Pos)              /*!< CLK SLEEPCTL: UARTCKEN Mask            */
N
N#define CLK_SLEEPCTL_BFALCKEN_Pos        (18)                                              /*!< CLK SLEEPCTL: BFALCKEN Position        */
N#define CLK_SLEEPCTL_BFALCKEN_Msk        (0x1ul << CLK_SLEEPCTL_BFALCKEN_Pos)              /*!< CLK SLEEPCTL: BFALCKEN Mask            */
N
N#define CLK_SLEEPCTL_CRCCKEN_Pos         (19)                                              /*!< CLK SLEEPCTL: CRCCKEN Position         */
N#define CLK_SLEEPCTL_CRCCKEN_Msk         (0x1ul << CLK_SLEEPCTL_CRCCKEN_Pos)               /*!< CLK SLEEPCTL: CRCCKEN Mask             */
N
N#define CLK_SLEEPCTL_PWM0CH01CKEN_Pos    (20)                                              /*!< CLK SLEEPCTL: PWM0CH01CKEN Position    */
N#define CLK_SLEEPCTL_PWM0CH01CKEN_Msk    (0x1ul << CLK_SLEEPCTL_PWM0CH01CKEN_Pos)          /*!< CLK SLEEPCTL: PWM0CH01CKEN Mask        */
N
N#define CLK_SLEEPCTL_ACMPCKEN_Pos        (22)                                              /*!< CLK SLEEPCTL: ACMPCKEN Position        */
N#define CLK_SLEEPCTL_ACMPCKEN_Msk        (0x1ul << CLK_SLEEPCTL_ACMPCKEN_Pos)              /*!< CLK SLEEPCTL: ACMPCKEN Mask            */
N
N#define CLK_SLEEPCTL_SBRAMCKEN_Pos       (26)                                              /*!< CLK SLEEPCTL: SBRAMCKEN Position       */
N#define CLK_SLEEPCTL_SBRAMCKEN_Msk       (0x1ul << CLK_SLEEPCTL_SBRAMCKEN_Pos)             /*!< CLK SLEEPCTL: SBRAMCKEN Mask           */
N
N#define CLK_SLEEPCTL_ADCCKEN_Pos         (28)                                              /*!< CLK SLEEPCTL: ADCCKEN Position         */
N#define CLK_SLEEPCTL_ADCCKEN_Msk         (0x1ul << CLK_SLEEPCTL_ADCCKEN_Pos)               /*!< CLK SLEEPCTL: ADCCKEN Mask             */
N
N#define CLK_SLEEPCTL_I2S0CKEN_Pos        (29)                                              /*!< CLK SLEEPCTL: I2S0CKEN Position        */
N#define CLK_SLEEPCTL_I2S0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_I2S0CKEN_Pos)              /*!< CLK SLEEPCTL: I2S0CKEN Mask            */
N
N#define CLK_SLEEPCTL_ANACKEN_Pos         (30)                                              /*!< CLK SLEEPCTL: ANACKEN Position         */
N#define CLK_SLEEPCTL_ANACKEN_Msk         (0x1ul << CLK_SLEEPCTL_ANACKEN_Pos)               /*!< CLK SLEEPCTL: ANACKEN Mask             */
N
N#define CLK_PWRSTSF_DSF_Pos              (0)                                               /*!< CLK PWRSTSF: DSF Position              */
N#define CLK_PWRSTSF_DSF_Msk              (0x1ul << CLK_PWRSTSF_DSF_Pos)                    /*!< CLK PWRSTSF: DSF Mask                  */
N
N#define CLK_PWRSTSF_STOPF_Pos            (1)                                               /*!< CLK PWRSTSF: STOPF Position            */
N#define CLK_PWRSTSF_STOPF_Msk            (0x1ul << CLK_PWRSTSF_STOPF_Pos)                  /*!< CLK PWRSTSF: STOPF Mask                */
N
N#define CLK_PWRSTSF_SPDF_Pos             (2)                                               /*!< CLK PWRSTSF: SPDF Position             */
N#define CLK_PWRSTSF_SPDF_Msk             (0x1ul << CLK_PWRSTSF_SPDF_Pos)                   /*!< CLK PWRSTSF: SPDF Mask                 */
N
N#define CLK_DBGPD_DISPDREQ_Pos           (0)                                               /*!< CLK DBGPD: DISPDREQ Position           */
N#define CLK_DBGPD_DISPDREQ_Msk           (0x1ul << CLK_DBGPD_DISPDREQ_Pos)                 /*!< CLK DBGPD: DISPDREQ Mask               */
N
N#define CLK_DBGPD_ICECLKST_Pos           (6)                                               /*!< CLK DBGPD: ICECLKST Position           */
N#define CLK_DBGPD_ICECLKST_Msk           (0x1ul << CLK_DBGPD_ICECLKST_Pos)                 /*!< CLK DBGPD: ICECLKST Mask               */
N
N#define CLK_DBGPD_ICEDATST_Pos           (7)                                               /*!< CLK DBGPD: ICEDATST Position           */
N#define CLK_DBGPD_ICEDATST_Msk           (0x1ul << CLK_DBGPD_ICEDATST_Pos)                 /*!< CLK DBGPD: ICEDATST Mask               */
N
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
N/**
N    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
N    Memory Mapped Structure for CRC Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  CRC Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:8]   |PKTLEN    |CRC Packet Length
N     * |        |          |Indicates number of bytes of CRC input to process.
N     * |        |          |CRC calculation will stop once input number of bytes = PKTLEN+1.
N     * |        |          |Maximum packet size is 512 bytes, for PKTLEN = 511.
N     * |        |          |Writing any value to this register will flush all previous calculations and restart a new CRC calculation.
N     * |[16]    |MODE      |CRC LSB mode
N     * |        |          |Determines whether CRC Generator processes input words (32bit/4Bytes) LSB (least significant byte) first or MSB (most significant byte) first.
N     * |        |          |0 = CRC input is MSB first (default).
N     * |        |          |1 = CRC input is LSB first.
N     * |        |          |For example if MODE = 1, and 0x01020304 is written to CRC_DAT, bytes will be processed in order 0x04, 0x03, 0x02, 0x01.
N     * |        |          |If MODE = 0, then order would be 0x01, 0x02, 0x3, 0x04.
N     * |        |          |Writing any value to this register will flush all previous calculations and restart a new CRC calculation.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x04  CRC Input Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |DATA      |CRC Input
N     * |        |          |The string of bytes to perform CRC calculation on.
N     * |        |          |When MODE = 0, CRC performs calculation byte by byte in the order DATA[31:24], DATA[23:16], DATA[15:8], DATA[7:0].
N     * |        |          |When MODE = 1, CRC performs calculation byte by byte in the order DATA[7:0], DATA[15:8], DATA[23:16], DATA[31:24].
N     * |        |          |If number of input bytes exceeds CRC Packet Length (CRC_CTL[8:0]+1), any additional input bytes will be ignored.
N     * |        |          |The CRC generator takes four clock cycles to process the CRC input.
N     * |        |          |Software must ensure that at least four clock cycles occur between writes of CRC_DAT.
N     * |        |          |Compiled assembly language can be examined to ensure this requirement is met.
N */
N    __IO uint32_t DAT;                   
X    volatile uint32_t DAT;                   
N
N    /**
N     * CHECKSUM
N     * ===================================================================================================
N     * Offset: 0x08  CRC Output Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |CHECKSUM  |CRC Output
N     * |        |          |The result of CRC computation.
N     * |        |          |The result is valid four clock cycles after last CRC_DAT input data is written to CRC generator.
N */
N    __I  uint32_t CHECKSUM;              
X    volatile const  uint32_t CHECKSUM;              
N
N} CRC_T;
N
N/**
N    @addtogroup CRC_CONST CRC Bit Field Definition
N    Constant Definitions for CRC Controller
N@{ */
N
N#define CRC_CTL_PKTLEN_Pos               (0)                                               /*!< CRC CTL: PKTLEN Position               */
N#define CRC_CTL_PKTLEN_Msk               (0x1fful << CRC_CTL_PKTLEN_Pos)                   /*!< CRC CTL: PKTLEN Mask                   */
N
N#define CRC_CTL_MODE_Pos                 (16)                                              /*!< CRC CTL: MODE Position                 */
N#define CRC_CTL_MODE_Msk                 (0x1ul << CRC_CTL_MODE_Pos)                       /*!< CRC CTL: MODE Mask                     */
N
N#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC DAT: DATA Position                 */
N#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC DAT: DATA Mask                     */
N
N#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC CHECKSUM: CHECKSUM Position        */
N#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffful << CRC_CHECKSUM_CHECKSUM_Pos)           /*!< CRC CHECKSUM: CHECKSUM Mask            */
N
N/**@}*/ /* CRC_CONST */
N/**@}*/ /* end of CRC register group */
N
N
N/*---------------------- Audio Class D Speaker Driver -------------------------*/
N/**
N    @addtogroup DPWM Audio Class D Speaker Driver(DPWM)
N    Memory Mapped Structure for DPWM Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  DPWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |MODUFRQ   |DPWM Modulation Frequency
N     * |        |          |This parameter controls the carrier modulation frequency of the PWM signal as a proportion of DPWM_CLK.
N     * |        |          |MODUFRQ : DPWM_CLK Division : Frequency for DPWM_CLK = 98.304MHZ
N     * |        |          |0 : 228 : 431158
N     * |        |          |1 : 156 : 630154
N     * |        |          |2 : 76 : 1293474
N     * |        |          |3 : 52 : 1890462
N     * |        |          |4 : 780 : 126031
N     * |        |          |5 : 524 : 187603
N     * |        |          |6 : 396 : 248242
N     * |        |          |7 : 268 : 366806
N     * |[3]     |DEADTIME  |DPWM Driver Deadtime Control
N     * |        |          |Enabling this bit will insert an additional clock cycle deadtime into the switching of PMOS and NMOS driver transistors.
N     * |[4:5]   |DITHEREN  |DPWM Signal Dither Control
N     * |        |          |To prevent structured noise on PWM output due to DC offsets in the input signal it is possible to add random dither to the PWM signal.
N     * |        |          |These bits control the dither:.
N     * |        |          |0 = No dither.
N     * |        |          |1 = +/- 1 bit dither
N     * |        |          |3 = +/- 2 bit dither
N     * |[6]     |DPWMEN    |DPWM Enable
N     * |        |          |0= Disable DPWM, SPK pins are tri-state, CIC filter is reset, FIFO pointers are reset (FIFO data is not reset).
N     * |        |          |1= Enable DPWM, SPK pins are enabled and driven, data is taken from FIFO.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * STS
N     * ===================================================================================================
N     * Offset: 0x04  DPWM FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FULL      |FIFO Full
N     * |        |          |0 = FIFO is not full.
N     * |        |          |1 = FIFO is full.
N     * |[1]     |EMPTY     |FIFO Empty
N     * |        |          |0= FIFO is not empty
N     * |        |          |1= FIFO is empty
N */
N    __I  uint32_t STS;                   
X    volatile const  uint32_t STS;                   
N
N    /**
N     * DMACTL
N     * ===================================================================================================
N     * Offset: 0x08  DPWM PDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DMAEN     |Enable DPWM DMA Interface
N     * |        |          |0= Disable PDMA. No requests will be made to PDMA controller.
N     * |        |          |1= Enable PDMA. Block will request data from PDMA controller whenever FIFO is not empty.
N */
N    __IO uint32_t DMACTL;                
X    volatile uint32_t DMACTL;                
N
N    /**
N     * DATA
N     * ===================================================================================================
N     * Offset: 0x0C  DPWM FIFO Input
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |INDATA    |DPWM FIFO Audio Data Input
N     * |        |          |A write to this register pushes data onto the DPWM FIFO and increments the write pointer.
N     * |        |          |This is the address that PDMA writes audio data to.
N */
N    __O  uint32_t DATA;                  
X    volatile  uint32_t DATA;                  
N
N    /**
N     * ZOHDIV
N     * ===================================================================================================
N     * Offset: 0x10  DPWM Zero Order Hold Division Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |ZOHDIV    |DPWM Zero Order Hold, Down-Sampling Divisor
N     * |        |          |The input sample rate of the DPWM is set by HCLK frequency and the divisor set in this register by the following formula:
N     * |        |          |Fs = HCLK/ZOHDIV/64
N     * |        |          |Valid range is 1 to 255.
N     * |        |          |Default is 48, which gives a sample rate of 16kHz for a 49.152MHz (default) HCLK.
N */
N    __IO uint32_t ZOHDIV;                
X    volatile uint32_t ZOHDIV;                
N
N} DPWM_T;
N
N/**
N    @addtogroup DPWM_CONST DPWM Bit Field Definition
N    Constant Definitions for DPWM Controller
N@{ */
N
N#define DPWM_CTL_MODUFRQ_Pos             (0)                                               /*!< DPWM CTL: MODUFRQ Position             */
N#define DPWM_CTL_MODUFRQ_Msk             (0x7ul << DPWM_CTL_MODUFRQ_Pos)                   /*!< DPWM CTL: MODUFRQ Mask                 */
N
N#define DPWM_CTL_DEADTIME_Pos            (3)                                               /*!< DPWM CTL: DEADTIME Position            */
N#define DPWM_CTL_DEADTIME_Msk            (0x1ul << DPWM_CTL_DEADTIME_Pos)                  /*!< DPWM CTL: DEADTIME Mask                */
N
N#define DPWM_CTL_DITHEREN_Pos            (4)                                               /*!< DPWM CTL: DITHEREN Position            */
N#define DPWM_CTL_DITHEREN_Msk            (0x3ul << DPWM_CTL_DITHEREN_Pos)                  /*!< DPWM CTL: DITHEREN Mask                */
N
N#define DPWM_CTL_DPWMEN_Pos              (6)                                               /*!< DPWM CTL: DPWMEN Position              */
N#define DPWM_CTL_DPWMEN_Msk              (0x1ul << DPWM_CTL_DPWMEN_Pos)                    /*!< DPWM CTL: DPWMEN Mask                  */
N
N#define DPWM_STS_FULL_Pos                (0)                                               /*!< DPWM STS: FULL Position                */
N#define DPWM_STS_FULL_Msk                (0x1ul << DPWM_STS_FULL_Pos)                      /*!< DPWM STS: FULL Mask                    */
N
N#define DPWM_STS_EMPTY_Pos               (1)                                               /*!< DPWM STS: EMPTY Position               */
N#define DPWM_STS_EMPTY_Msk               (0x1ul << DPWM_STS_EMPTY_Pos)                     /*!< DPWM STS: EMPTY Mask                   */
N
N#define DPWM_DMACTL_DMAEN_Pos            (0)                                               /*!< DPWM DMACTL: DMAEN Position            */
N#define DPWM_DMACTL_DMAEN_Msk            (0x1ul << DPWM_DMACTL_DMAEN_Pos)                  /*!< DPWM DMACTL: DMAEN Mask                */
N
N#define DPWM_DATA_INDATA_Pos             (0)                                               /*!< DPWM DATA: INDATA Position             */
N#define DPWM_DATA_INDATA_Msk             (0xfffful << DPWM_DATA_INDATA_Pos)                /*!< DPWM DATA: INDATA Mask                 */
N
N#define DPWM_ZOHDIV_ZOHDIV_Pos           (0)                                               /*!< DPWM ZOHDIV: ZOHDIV Position           */
N#define DPWM_ZOHDIV_ZOHDIV_Msk           (0xfful << DPWM_ZOHDIV_ZOHDIV_Pos)                /*!< DPWM ZOHDIV: ZOHDIV Mask               */
N
N/**@}*/ /* DPWM_CONST */
N/**@}*/ /* end of DPWM register group */
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller(FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * ISPCTL
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable
N     * |        |          |0 = Disable ISP function
N     * |        |          |1 = Enable ISP function
N     * |[1]     |BS        |Boot Select
N     * |        |          |0 = APROM
N     * |        |          |1 = LDROM
N     * |        |          |Modify this bit to select which ROM next boot is to occur.
N     * |        |          |This bit also functions as MCU boot status flag, which can be used to check where MCU booted from.
N     * |        |          |This bit is initialized after power-on reset with the inverse of CBS in Config0; It is not reset for any other reset event.
N     * |[4]     |CFGUEN    |CONFIG Update Enable
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |        |          |When enabled, ISP functions can access the CONFIG address space and modify device configuration area. 
N     * |[5]     |LDUEN     |LDROM Update Enable
N     * |        |          |LDROM update enable bit.
N     * |        |          |0 = LDROM cannot be updated
N     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N     * |[6]     |ISPFF     |ISP Fail Flag
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself.
N     * |        |          |(2) LDROM writes to itself.
N     * |        |          |(3) Destination address is illegal, such as over an available range.
N     * |        |          |Write 1 to clear.
N     * |[7]     |SWRST     |Software Reset
N     * |        |          |Writing 1 to this bit will initiate a software reset. It is cleared by hardware after reset.
N */
N    __IO uint32_t ISPCTL;                
X    volatile uint32_t ISPCTL;                
N
N    /**
N     * ISPADDR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |ISPADDR   |ISP Address Register
N     * |        |          |This is the memory address register that a subsequent ISP command will access.
N     * |        |          |ISP operation are carried out on 32bit words only, consequently ISPARD[1:0] must be 00b for correct ISP operation.
N */
N    __IO uint32_t ISPADDR;               
X    volatile uint32_t ISPADDR;               
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |ISPDAT    |ISP Data Register
N     * |        |          |Write data to this register before an ISP program operation.
N     * |        |          |Read data from this register after an ISP read operation
N */
N    __IO uint32_t ISPDAT;                
X    volatile uint32_t ISPDAT;                
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:5]   |CMD       |ISP Command
N     * |        |          |Operation Mode : CMD
N     * |        |          |Standby : 0x3X
N     * |        |          |Read : 0x00
N     * |        |          |Program : 0x21
N     * |        |          |Page Erase : 0x22
N     * |        |          |Read CID : 0x0B
N     * |        |          |Read DID : 0x0C
N */
N    __IO uint32_t ISPCMD;                
X    volatile uint32_t ISPCMD;                
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  ISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger
N     * |        |          |Write 1 to start ISP operation.
N     * |        |          |This will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |0 = ISP operation is finished
N     * |        |          |1 = ISP is on going
N     * |        |          |After triggering an ISP function M0 instruction pipeline should be flushed with a ISB instruction to guarantee data integrity.
N     * |        |          |This is a protected register, user must first follow the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL)) to gain access.
N */
N    __IO uint32_t ISPTRG;                
X    volatile uint32_t ISPTRG;                
N
N    /**
N     * DFBA
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |DFBA      |Data Flash Base Address
N     * |        |          |This register reports the data flash starting address. It is a read only register.
N     * |        |          |Data flash size is defined by user's configuration; register content is loaded from Config1 when chip is reset.
N */
N    __I  uint32_t DFBA;                  
X    volatile const  uint32_t DFBA;                  
N
N} FMC_T;
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC ISPCTL: ISPEN Position             */
N#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC ISPCTL: ISPEN Mask                 */
N
N#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC ISPCTL: BS Position                */
N#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC ISPCTL: BS Mask                    */
N
N#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC ISPCTL: CFGUEN Position            */
N#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC ISPCTL: CFGUEN Mask                */
N
N#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC ISPCTL: LDUEN Position             */
N#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC ISPCTL: LDUEN Mask                 */
N
N#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC ISPCTL: ISPFF Position             */
N#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC ISPCTL: ISPFF Mask                 */
N
N#define FMC_ISPCTL_SWRST_Pos             (7)                                               /*!< FMC ISPCTL: SWRST Position             */
N#define FMC_ISPCTL_SWRST_Msk             (0x1ul << FMC_ISPCTL_SWRST_Pos)                   /*!< FMC ISPCTL: SWRST Mask                 */
N
N#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC ISPADDR: ISPADDR Position          */
N#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC ISPADDR: ISPADDR Mask              */
N
N#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC ISPDAT: ISPDAT Position            */
N#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC ISPDAT: ISPDAT Mask                */
N
N#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC ISPCMD: CMD Position               */
N#define FMC_ISPCMD_CMD_Msk               (0x3ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC ISPCMD: CMD Mask                   */
N
N#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC ISPTRG: ISPGO Position             */
N#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC ISPTRG: ISPGO Mask                 */
N
N#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC DFBA: DFBA Position                */
N#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC DFBA: DFBA Mask                    */
N
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* end of FMC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * MODE
N     * ===================================================================================================
N     * Offset: 0x00  GPIO Pin I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |MODE0     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[2:3]   |MODE1     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[4:5]   |MODE2     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[6:7]   |MODE3     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[8:9]   |MODE4     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[10:11] |MODE5     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[12:13] |MODE6     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[14:15] |MODE7     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[16:17] |MODE8     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[18:19] |MODE9     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[20:21] |MODE10    |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[22:23] |MODE11    |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[24:25] |MODE12    |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[26:27] |MODE13    |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[28:29] |MODE14    |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |[30:31] |MODE15    |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O type of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
N     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N */
N    __IO uint32_t MODE;               
X    volatile uint32_t MODE;               
N
N    /**
N     * DINOFF
N     * ===================================================================================================
N     * Offset: 0x04  GPIO Pin Digital Input Disable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[16]    |DINOFF16  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[17]    |DINOFF17  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[18]    |DINOFF18  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[19]    |DINOFF19  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[20]    |DINOFF20  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[21]    |DINOFF21  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[22]    |DINOFF22  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[23]    |DINOFF23  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[24]    |DINOFF24  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[25]    |DINOFF25  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[26]    |DINOFF26  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[27]    |DINOFF27  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[28]    |DINOFF28  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[29]    |DINOFF29  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[30]    |DINOFF30  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N     * |[31]    |DINOFF31  |GPIOx Pin[n] OFF Digital Input Path Enable
N     * |        |          |0 = Enable IO digital input path (Default)
N     * |        |          |1 = Disable IO digital input path (low leakage mode)
N */
N    __IO uint32_t DINOFF;             
X    volatile uint32_t DINOFF;             
N
N    /**
N     * DOUT
N     * ===================================================================================================
N     * Offset: 0x08  GPIO Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DOUT0     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[1]     |DOUT1     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[2]     |DOUT2     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[3]     |DOUT3     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[4]     |DOUT4     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[5]     |DOUT5     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[6]     |DOUT6     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[7]     |DOUT7     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[8]     |DOUT8     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[9]     |DOUT9     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[10]    |DOUT10    |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[11]    |DOUT11    |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[12]    |DOUT12    |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[13]    |DOUT13    |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[14]    |DOUT14    |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N     * |[15]    |DOUT15    |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
N     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
N */
N    __IO uint32_t DOUT;               
X    volatile uint32_t DOUT;               
N
N    /**
N     * DATMSK
N     * ===================================================================================================
N     * Offset: 0x0C  GPIO Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DATMSK0   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[1]     |DATMSK1   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[2]     |DATMSK2   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[3]     |DATMSK3   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[4]     |DATMSK4   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[5]     |DATMSK5   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[6]     |DATMSK6   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[7]     |DATMSK7   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[8]     |DATMSK8   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[9]     |DATMSK9   |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[10]    |DATMSK10  |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[11]    |DATMSK11  |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[12]    |DATMSK12  |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[13]    |DATMSK13  |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[14]    |DATMSK14  |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N     * |[15]    |DATMSK15  |Port [A/B] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
N     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
N     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
N     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
N */
N    __IO uint32_t DATMSK;             
X    volatile uint32_t DATMSK;             
N
N    /**
N     * PIN
N     * ===================================================================================================
N     * Offset: 0x10  GPIO Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PIN0      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[1]     |PIN1      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[2]     |PIN2      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[3]     |PIN3      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[4]     |PIN4      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[5]     |PIN5      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[6]     |PIN6      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[7]     |PIN7      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[8]     |PIN8      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[9]     |PIN9      |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[10]    |PIN10     |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[11]    |PIN11     |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[12]    |PIN12     |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[13]    |PIN13     |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[14]    |PIN14     |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N     * |[15]    |PIN15     |Port [A/B] Pin Values
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
N */
N    __I  uint32_t PIN;                
X    volatile const  uint32_t PIN;                
N
N    /**
N     * DBEN
N     * ===================================================================================================
N     * Offset: 0x14  GPIO De-bounce Enable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DBEN0     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[1]     |DBEN1     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[2]     |DBEN2     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[3]     |DBEN3     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[4]     |DBEN4     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[5]     |DBEN5     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[6]     |DBEN6     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[7]     |DBEN7     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[8]     |DBEN8     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[9]     |DBEN9     |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[10]    |DBEN10    |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[11]    |DBEN11    |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[12]    |DBEN12    |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[13]    |DBEN13    |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[14]    |DBEN14    |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N     * |[15]    |DBEN15    |Port [A/B] Input Signal De-bounce Enable
N     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
N     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
N     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
N     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
N     * |        |          |0 = The bit[n] de-bounce function is disabled
N     * |        |          |1 = The bit[n] de-bounce function is enabled 
N */
N    __IO uint32_t DBEN;               
X    volatile uint32_t DBEN;               
N
N    /**
N     * INTTYPE
N     * ===================================================================================================
N     * Offset: 0x18  GPIO Interrupt Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TYPE0     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[1]     |TYPE1     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[2]     |TYPE2     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[3]     |TYPE3     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[4]     |TYPE4     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[5]     |TYPE5     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[6]     |TYPE6     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[7]     |TYPE7     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[8]     |TYPE8     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[9]     |TYPE9     |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[10]    |TYPE10    |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[11]    |TYPE11    |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[12]    |TYPE12    |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[13]    |TYPE13    |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[14]    |TYPE14    |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N     * |[15]    |TYPE15    |Port [A/B] Edge Or Level Detection Interrupt Control
N     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
N     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
N     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
N     * |        |          |0 = Edge triggered interrupt
N     * |        |          |1 = Level triggered interrupt
N     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
N     * |        |          |If both levels are set no interrupt will occur.
N */
N    __IO uint32_t INTTYPE;            
X    volatile uint32_t INTTYPE;            
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x1C  GPIO Interrupt Enable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FLIEN0    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[1]     |FLIEN1    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[2]     |FLIEN2    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[3]     |FLIEN3    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[4]     |FLIEN4    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[5]     |FLIEN5    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[6]     |FLIEN6    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[7]     |FLIEN7    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[8]     |FLIEN8    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[9]     |FLIEN9    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[10]    |FLIEN10   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[11]    |FLIEN11   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[12]    |FLIEN12   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[13]    |FLIEN13   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[14]    |FLIEN14   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[15]    |FLIEN15   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
N     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
N     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
N     * |[16]    |RHIEN0    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[17]    |RHIEN1    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[18]    |RHIEN2    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[19]    |RHIEN3    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[20]    |RHIEN4    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[21]    |RHIEN5    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[22]    |RHIEN6    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[23]    |RHIEN7    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[24]    |RHIEN8    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[25]    |RHIEN9    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[26]    |RHIEN10   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[27]    |RHIEN11   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[28]    |RHIEN12   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[29]    |RHIEN13   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[30]    |RHIEN14   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N     * |[31]    |RHIEN15   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
N     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
N     * |        |          |It also enables the pin wakeup function.
N     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
N     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
N     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
N     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
N     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
N */
N    __IO uint32_t INTEN;              
X    volatile uint32_t INTEN;              
N
N    /**
N     * INTSRC
N     * ===================================================================================================
N     * Offset: 0x20  GPIO Interrupt Trigger Source Indicator
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTSRC0   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[1]     |INTSRC1   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[2]     |INTSRC2   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[3]     |INTSRC3   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[4]     |INTSRC4   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[5]     |INTSRC5   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[6]     |INTSRC6   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[7]     |INTSRC7   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[8]     |INTSRC8   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[9]     |INTSRC9   |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[10]    |INTSRC10  |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[11]    |INTSRC11  |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[12]    |INTSRC12  |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[13]    |INTSRC13  |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[14]    |INTSRC14  |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N     * |[15]    |INTSRC15  |Port [A/B] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
N     * |        |          |0 = No interrupt from GPIOx[n]
N     * |        |          |Write :
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |0 = No action
N */
N    __IO uint32_t INTSRC;                     
X    volatile uint32_t INTSRC;                     
N
N} GPIO_T;
N
N
Ntypedef struct { 
N    /**
N     * GPIO_DBCTL
N     * ===================================================================================================
N     * Offset: 0x000  Interrupt De-bounce Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |DBCLKSEL  |De-bounce Sampling Cycle Selection.
N     * |        |          |For edge level interrupt GPIO state is sampled every 2^(DBCLKSEL) de-bounce clocks.
N     * |        |          |For example if DBCLKSRC = 6, then interrupt is sampled every 2^6 = 64 de-bounce clocks.
N     * |        |          |If DBCLKSRC is 16KHz oscillator this would be a 64ms de-bounce.
N     * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Select
N     * |        |          |0 = De-bounce counter clock source is HCLK
N     * |        |          |1 = De-bounce counter clock source is the internal 16 kHz clock
N     * |[5]     |ICLKON    |Interrupt Clock On Mode
N     * |        |          |Set this bit "0" will gate the clock to the interrupt generation circuit if the GPIOx[n] interrupt is disabled.
N     * |        |          |0 = disable the clock if the GPIOx[n] interrupt is disabled
N     * |        |          |1 = Interrupt generation clock always active.
N */
N    __IO uint32_t DBCTL;  
X    volatile uint32_t DBCTL;  
N} GPIO_DB_T; 
N
N/**
N    @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO MODE: MODE0 Position              */
N#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO MODE: MODE0 Mask                  */
N
N#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO MODE: MODE1 Position              */
N#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO MODE: MODE1 Mask                  */
N
N#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO MODE: MODE2 Position              */
N#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO MODE: MODE2 Mask                  */
N
N#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO MODE: MODE3 Position              */
N#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO MODE: MODE3 Mask                  */
N
N#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO MODE: MODE4 Position              */
N#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO MODE: MODE4 Mask                  */
N
N#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO MODE: MODE5 Position              */
N#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO MODE: MODE5 Mask                  */
N
N#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO MODE: MODE6 Position              */
N#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO MODE: MODE6 Mask                  */
N
N#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO MODE: MODE7 Position              */
N#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO MODE: MODE7 Mask                  */
N
N#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO MODE: MODE8 Position              */
N#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO MODE: MODE8 Mask                  */
N
N#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO MODE: MODE9 Position              */
N#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO MODE: MODE9 Mask                  */
N
N#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO MODE: MODE10 Position             */
N#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO MODE: MODE10 Mask                 */
N
N#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO MODE: MODE11 Position             */
N#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO MODE: MODE11 Mask                 */
N
N#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO MODE: MODE12 Position             */
N#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO MODE: MODE12 Mask                 */
N
N#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO MODE: MODE13 Position             */
N#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO MODE: MODE13 Mask                 */
N
N#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO MODE: MODE14 Position             */
N#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO MODE: MODE14 Mask                 */
N
N#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO MODE: MODE15 Position             */
N#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO MODE: MODE15 Mask                 */
N
N#define GPIO_DINOFF_DINOFF16_Pos         (16)                                              /*!< GPIO DINOFF: DINOFF16 Position         */
N#define GPIO_DINOFF_DINOFF16_Msk         (0x1ul << GPIO_DINOFF_DINOFF16_Pos)               /*!< GPIO DINOFF: DINOFF16 Mask             */
N
N#define GPIO_DINOFF_DINOFF17_Pos         (17)                                              /*!< GPIO DINOFF: DINOFF17 Position         */
N#define GPIO_DINOFF_DINOFF17_Msk         (0x1ul << GPIO_DINOFF_DINOFF17_Pos)               /*!< GPIO DINOFF: DINOFF17 Mask             */
N
N#define GPIO_DINOFF_DINOFF18_Pos         (18)                                              /*!< GPIO DINOFF: DINOFF18 Position         */
N#define GPIO_DINOFF_DINOFF18_Msk         (0x1ul << GPIO_DINOFF_DINOFF18_Pos)               /*!< GPIO DINOFF: DINOFF18 Mask             */
N
N#define GPIO_DINOFF_DINOFF19_Pos         (19)                                              /*!< GPIO DINOFF: DINOFF19 Position         */
N#define GPIO_DINOFF_DINOFF19_Msk         (0x1ul << GPIO_DINOFF_DINOFF19_Pos)               /*!< GPIO DINOFF: DINOFF19 Mask             */
N
N#define GPIO_DINOFF_DINOFF20_Pos         (20)                                              /*!< GPIO DINOFF: DINOFF20 Position         */
N#define GPIO_DINOFF_DINOFF20_Msk         (0x1ul << GPIO_DINOFF_DINOFF20_Pos)               /*!< GPIO DINOFF: DINOFF20 Mask             */
N
N#define GPIO_DINOFF_DINOFF21_Pos         (21)                                              /*!< GPIO DINOFF: DINOFF21 Position         */
N#define GPIO_DINOFF_DINOFF21_Msk         (0x1ul << GPIO_DINOFF_DINOFF21_Pos)               /*!< GPIO DINOFF: DINOFF21 Mask             */
N
N#define GPIO_DINOFF_DINOFF22_Pos         (22)                                              /*!< GPIO DINOFF: DINOFF22 Position         */
N#define GPIO_DINOFF_DINOFF22_Msk         (0x1ul << GPIO_DINOFF_DINOFF22_Pos)               /*!< GPIO DINOFF: DINOFF22 Mask             */
N
N#define GPIO_DINOFF_DINOFF23_Pos         (23)                                              /*!< GPIO DINOFF: DINOFF23 Position         */
N#define GPIO_DINOFF_DINOFF23_Msk         (0x1ul << GPIO_DINOFF_DINOFF23_Pos)               /*!< GPIO DINOFF: DINOFF23 Mask             */
N
N#define GPIO_DINOFF_DINOFF24_Pos         (24)                                              /*!< GPIO DINOFF: DINOFF24 Position         */
N#define GPIO_DINOFF_DINOFF24_Msk         (0x1ul << GPIO_DINOFF_DINOFF24_Pos)               /*!< GPIO DINOFF: DINOFF24 Mask             */
N
N#define GPIO_DINOFF_DINOFF25_Pos         (25)                                              /*!< GPIO DINOFF: DINOFF25 Position         */
N#define GPIO_DINOFF_DINOFF25_Msk         (0x1ul << GPIO_DINOFF_DINOFF25_Pos)               /*!< GPIO DINOFF: DINOFF25 Mask             */
N
N#define GPIO_DINOFF_DINOFF26_Pos         (26)                                              /*!< GPIO DINOFF: DINOFF26 Position         */
N#define GPIO_DINOFF_DINOFF26_Msk         (0x1ul << GPIO_DINOFF_DINOFF26_Pos)               /*!< GPIO DINOFF: DINOFF26 Mask             */
N
N#define GPIO_DINOFF_DINOFF27_Pos         (27)                                              /*!< GPIO DINOFF: DINOFF27 Position         */
N#define GPIO_DINOFF_DINOFF27_Msk         (0x1ul << GPIO_DINOFF_DINOFF27_Pos)               /*!< GPIO DINOFF: DINOFF27 Mask             */
N
N#define GPIO_DINOFF_DINOFF28_Pos         (28)                                              /*!< GPIO DINOFF: DINOFF28 Position         */
N#define GPIO_DINOFF_DINOFF28_Msk         (0x1ul << GPIO_DINOFF_DINOFF28_Pos)               /*!< GPIO DINOFF: DINOFF28 Mask             */
N
N#define GPIO_DINOFF_DINOFF29_Pos         (29)                                              /*!< GPIO DINOFF: DINOFF29 Position         */
N#define GPIO_DINOFF_DINOFF29_Msk         (0x1ul << GPIO_DINOFF_DINOFF29_Pos)               /*!< GPIO DINOFF: DINOFF29 Mask             */
N
N#define GPIO_DINOFF_DINOFF30_Pos         (30)                                              /*!< GPIO DINOFF: DINOFF30 Position         */
N#define GPIO_DINOFF_DINOFF30_Msk         (0x1ul << GPIO_DINOFF_DINOFF30_Pos)               /*!< GPIO DINOFF: DINOFF30 Mask             */
N
N#define GPIO_DINOFF_DINOFF31_Pos         (31)                                              /*!< GPIO DINOFF: DINOFF31 Position         */
N#define GPIO_DINOFF_DINOFF31_Msk         (0x1ul << GPIO_DINOFF_DINOFF31_Pos)               /*!< GPIO DINOFF: DINOFF31 Mask             */
N
N#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO DOUT: DOUT0 Position              */
N#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO DOUT: DOUT0 Mask                  */
N
N#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO DOUT: DOUT1 Position              */
N#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO DOUT: DOUT1 Mask                  */
N
N#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO DOUT: DOUT2 Position              */
N#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO DOUT: DOUT2 Mask                  */
N
N#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO DOUT: DOUT3 Position              */
N#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO DOUT: DOUT3 Mask                  */
N
N#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO DOUT: DOUT4 Position              */
N#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO DOUT: DOUT4 Mask                  */
N
N#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO DOUT: DOUT5 Position              */
N#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO DOUT: DOUT5 Mask                  */
N
N#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO DOUT: DOUT6 Position              */
N#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO DOUT: DOUT6 Mask                  */
N
N#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO DOUT: DOUT7 Position              */
N#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO DOUT: DOUT7 Mask                  */
N
N#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO DOUT: DOUT8 Position              */
N#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO DOUT: DOUT8 Mask                  */
N
N#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO DOUT: DOUT9 Position              */
N#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO DOUT: DOUT9 Mask                  */
N
N#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO DOUT: DOUT10 Position             */
N#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO DOUT: DOUT10 Mask                 */
N
N#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO DOUT: DOUT11 Position             */
N#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO DOUT: DOUT11 Mask                 */
N
N#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO DOUT: DOUT12 Position             */
N#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO DOUT: DOUT12 Mask                 */
N
N#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO DOUT: DOUT13 Position             */
N#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO DOUT: DOUT13 Mask                 */
N
N#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO DOUT: DOUT14 Position             */
N#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO DOUT: DOUT14 Mask                 */
N
N#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO DOUT: DOUT15 Position             */
N#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO DOUT: DOUT15 Mask                 */
N
N#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO DATMSK: DATMSK0 Position          */
N#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO DATMSK: DATMSK0 Mask              */
N
N#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO DATMSK: DATMSK1 Position          */
N#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO DATMSK: DATMSK1 Mask              */
N
N#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO DATMSK: DATMSK2 Position          */
N#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO DATMSK: DATMSK2 Mask              */
N
N#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO DATMSK: DATMSK3 Position          */
N#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO DATMSK: DATMSK3 Mask              */
N
N#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO DATMSK: DATMSK4 Position          */
N#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO DATMSK: DATMSK4 Mask              */
N
N#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO DATMSK: DATMSK5 Position          */
N#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO DATMSK: DATMSK5 Mask              */
N
N#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO DATMSK: DATMSK6 Position          */
N#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO DATMSK: DATMSK6 Mask              */
N
N#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO DATMSK: DATMSK7 Position          */
N#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO DATMSK: DATMSK7 Mask              */
N
N#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO DATMSK: DATMSK8 Position          */
N#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO DATMSK: DATMSK8 Mask              */
N
N#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO DATMSK: DATMSK9 Position          */
N#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO DATMSK: DATMSK9 Mask              */
N
N#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO DATMSK: DATMSK10 Position         */
N#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO DATMSK: DATMSK10 Mask             */
N
N#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO DATMSK: DATMSK11 Position         */
N#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO DATMSK: DATMSK11 Mask             */
N
N#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO DATMSK: DATMSK12 Position         */
N#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO DATMSK: DATMSK12 Mask             */
N
N#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO DATMSK: DATMSK13 Position         */
N#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO DATMSK: DATMSK13 Mask             */
N
N#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO DATMSK: DATMSK14 Position         */
N#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO DATMSK: DATMSK14 Mask             */
N
N#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO DATMSK: DATMSK15 Position         */
N#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO DATMSK: DATMSK15 Mask             */
N
N#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO PIN: PIN0 Position                */
N#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO PIN: PIN0 Mask                    */
N
N#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO PIN: PIN1 Position                */
N#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO PIN: PIN1 Mask                    */
N
N#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO PIN: PIN2 Position                */
N#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO PIN: PIN2 Mask                    */
N
N#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO PIN: PIN3 Position                */
N#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO PIN: PIN3 Mask                    */
N
N#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO PIN: PIN4 Position                */
N#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO PIN: PIN4 Mask                    */
N
N#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO PIN: PIN5 Position                */
N#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO PIN: PIN5 Mask                    */
N
N#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO PIN: PIN6 Position                */
N#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO PIN: PIN6 Mask                    */
N
N#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO PIN: PIN7 Position                */
N#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO PIN: PIN7 Mask                    */
N
N#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO PIN: PIN8 Position                */
N#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO PIN: PIN8 Mask                    */
N
N#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO PIN: PIN9 Position                */
N#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO PIN: PIN9 Mask                    */
N
N#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO PIN: PIN10 Position               */
N#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO PIN: PIN10 Mask                   */
N
N#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO PIN: PIN11 Position               */
N#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO PIN: PIN11 Mask                   */
N
N#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO PIN: PIN12 Position               */
N#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO PIN: PIN12 Mask                   */
N
N#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO PIN: PIN13 Position               */
N#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO PIN: PIN13 Mask                   */
N
N#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO PIN: PIN14 Position               */
N#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO PIN: PIN14 Mask                   */
N
N#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO PIN: PIN15 Position               */
N#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO PIN: PIN15 Mask                   */
N
N#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO DBEN: DBEN0 Position              */
N#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO DBEN: DBEN0 Mask                  */
N
N#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO DBEN: DBEN1 Position              */
N#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO DBEN: DBEN1 Mask                  */
N
N#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO DBEN: DBEN2 Position              */
N#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO DBEN: DBEN2 Mask                  */
N
N#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO DBEN: DBEN3 Position              */
N#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO DBEN: DBEN3 Mask                  */
N
N#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO DBEN: DBEN4 Position              */
N#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO DBEN: DBEN4 Mask                  */
N
N#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO DBEN: DBEN5 Position              */
N#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO DBEN: DBEN5 Mask                  */
N
N#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO DBEN: DBEN6 Position              */
N#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO DBEN: DBEN6 Mask                  */
N
N#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO DBEN: DBEN7 Position              */
N#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO DBEN: DBEN7 Mask                  */
N
N#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO DBEN: DBEN8 Position              */
N#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO DBEN: DBEN8 Mask                  */
N
N#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO DBEN: DBEN9 Position              */
N#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO DBEN: DBEN9 Mask                  */
N
N#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO DBEN: DBEN10 Position             */
N#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO DBEN: DBEN10 Mask                 */
N
N#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO DBEN: DBEN11 Position             */
N#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO DBEN: DBEN11 Mask                 */
N
N#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO DBEN: DBEN12 Position             */
N#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO DBEN: DBEN12 Mask                 */
N
N#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO DBEN: DBEN13 Position             */
N#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO DBEN: DBEN13 Mask                 */
N
N#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO DBEN: DBEN14 Position             */
N#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO DBEN: DBEN14 Mask                 */
N
N#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO DBEN: DBEN15 Position             */
N#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO DBEN: DBEN15 Mask                 */
N
N#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO INTTYPE: TYPE0 Position           */
N#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO INTTYPE: TYPE0 Mask               */
N
N#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO INTTYPE: TYPE1 Position           */
N#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO INTTYPE: TYPE1 Mask               */
N
N#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO INTTYPE: TYPE2 Position           */
N#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO INTTYPE: TYPE2 Mask               */
N
N#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO INTTYPE: TYPE3 Position           */
N#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO INTTYPE: TYPE3 Mask               */
N
N#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO INTTYPE: TYPE4 Position           */
N#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO INTTYPE: TYPE4 Mask               */
N
N#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO INTTYPE: TYPE5 Position           */
N#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO INTTYPE: TYPE5 Mask               */
N
N#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO INTTYPE: TYPE6 Position           */
N#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO INTTYPE: TYPE6 Mask               */
N
N#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO INTTYPE: TYPE7 Position           */
N#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO INTTYPE: TYPE7 Mask               */
N
N#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO INTTYPE: TYPE8 Position           */
N#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO INTTYPE: TYPE8 Mask               */
N
N#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO INTTYPE: TYPE9 Position           */
N#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO INTTYPE: TYPE9 Mask               */
N
N#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO INTTYPE: TYPE10 Position          */
N#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO INTTYPE: TYPE10 Mask              */
N
N#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO INTTYPE: TYPE11 Position          */
N#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO INTTYPE: TYPE11 Mask              */
N
N#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO INTTYPE: TYPE12 Position          */
N#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO INTTYPE: TYPE12 Mask              */
N
N#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO INTTYPE: TYPE13 Position          */
N#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO INTTYPE: TYPE13 Mask              */
N
N#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO INTTYPE: TYPE14 Position          */
N#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO INTTYPE: TYPE14 Mask              */
N
N#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO INTTYPE: TYPE15 Position          */
N#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO INTTYPE: TYPE15 Mask              */
N
N#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO INTEN: FLIEN0 Position            */
N#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO INTEN: FLIEN0 Mask                */
N
N#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO INTEN: FLIEN1 Position            */
N#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO INTEN: FLIEN1 Mask                */
N
N#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO INTEN: FLIEN2 Position            */
N#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO INTEN: FLIEN2 Mask                */
N
N#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO INTEN: FLIEN3 Position            */
N#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO INTEN: FLIEN3 Mask                */
N
N#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO INTEN: FLIEN4 Position            */
N#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO INTEN: FLIEN4 Mask                */
N
N#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO INTEN: FLIEN5 Position            */
N#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO INTEN: FLIEN5 Mask                */
N
N#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO INTEN: FLIEN6 Position            */
N#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO INTEN: FLIEN6 Mask                */
N
N#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO INTEN: FLIEN7 Position            */
N#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO INTEN: FLIEN7 Mask                */
N
N#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO INTEN: FLIEN8 Position            */
N#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO INTEN: FLIEN8 Mask                */
N
N#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO INTEN: FLIEN9 Position            */
N#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO INTEN: FLIEN9 Mask                */
N
N#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO INTEN: FLIEN10 Position           */
N#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO INTEN: FLIEN10 Mask               */
N
N#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO INTEN: FLIEN11 Position           */
N#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO INTEN: FLIEN11 Mask               */
N
N#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO INTEN: FLIEN12 Position           */
N#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO INTEN: FLIEN12 Mask               */
N
N#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO INTEN: FLIEN13 Position           */
N#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO INTEN: FLIEN13 Mask               */
N
N#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO INTEN: FLIEN14 Position           */
N#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO INTEN: FLIEN14 Mask               */
N
N#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO INTEN: FLIEN15 Position           */
N#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO INTEN: FLIEN15 Mask               */
N
N#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO INTEN: RHIEN0 Position            */
N#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO INTEN: RHIEN0 Mask                */
N
N#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO INTEN: RHIEN1 Position            */
N#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO INTEN: RHIEN1 Mask                */
N
N#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO INTEN: RHIEN2 Position            */
N#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO INTEN: RHIEN2 Mask                */
N
N#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO INTEN: RHIEN3 Position            */
N#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO INTEN: RHIEN3 Mask                */
N
N#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO INTEN: RHIEN4 Position            */
N#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO INTEN: RHIEN4 Mask                */
N
N#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO INTEN: RHIEN5 Position            */
N#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO INTEN: RHIEN5 Mask                */
N
N#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO INTEN: RHIEN6 Position            */
N#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO INTEN: RHIEN6 Mask                */
N
N#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO INTEN: RHIEN7 Position            */
N#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO INTEN: RHIEN7 Mask                */
N
N#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO INTEN: RHIEN8 Position            */
N#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO INTEN: RHIEN8 Mask                */
N
N#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO INTEN: RHIEN9 Position            */
N#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO INTEN: RHIEN9 Mask                */
N
N#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO INTEN: RHIEN10 Position           */
N#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO INTEN: RHIEN10 Mask               */
N
N#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO INTEN: RHIEN11 Position           */
N#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO INTEN: RHIEN11 Mask               */
N
N#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO INTEN: RHIEN12 Position           */
N#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO INTEN: RHIEN12 Mask               */
N
N#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO INTEN: RHIEN13 Position           */
N#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO INTEN: RHIEN13 Mask               */
N
N#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO INTEN: RHIEN14 Position           */
N#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO INTEN: RHIEN14 Mask               */
N
N#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO INTEN: RHIEN15 Position           */
N#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO INTEN: RHIEN15 Mask               */
N
N#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO INTSRC: INTSRC0 Position          */
N#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO INTSRC: INTSRC0 Mask              */
N
N#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO INTSRC: INTSRC1 Position          */
N#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO INTSRC: INTSRC1 Mask              */
N
N#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO INTSRC: INTSRC2 Position          */
N#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO INTSRC: INTSRC2 Mask              */
N
N#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO INTSRC: INTSRC3 Position          */
N#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO INTSRC: INTSRC3 Mask              */
N
N#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO INTSRC: INTSRC4 Position          */
N#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO INTSRC: INTSRC4 Mask              */
N
N#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO INTSRC: INTSRC5 Position          */
N#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO INTSRC: INTSRC5 Mask              */
N
N#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO INTSRC: INTSRC6 Position          */
N#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO INTSRC: INTSRC6 Mask              */
N
N#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO INTSRC: INTSRC7 Position          */
N#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO INTSRC: INTSRC7 Mask              */
N
N#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO INTSRC: INTSRC8 Position          */
N#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO INTSRC: INTSRC8 Mask              */
N
N#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO INTSRC: INTSRC9 Position          */
N#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO INTSRC: INTSRC9 Mask              */
N
N#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO INTSRC: INTSRC10 Position         */
N#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO INTSRC: INTSRC10 Mask             */
N
N#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO INTSRC: INTSRC11 Position         */
N#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO INTSRC: INTSRC11 Mask             */
N
N#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO INTSRC: INTSRC12 Position         */
N#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO INTSRC: INTSRC12 Mask             */
N
N#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO INTSRC: INTSRC13 Position         */
N#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO INTSRC: INTSRC13 Mask             */
N
N#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO INTSRC: INTSRC14 Position         */
N#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO INTSRC: INTSRC14 Mask             */
N
N#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO INTSRC: INTSRC15 Position         */
N#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO INTSRC: INTSRC15 Mask             */
N
N#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO MODE: MODE0 Position              */
N#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO MODE: MODE0 Mask                  */
N
N#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO MODE: MODE1 Position              */
N#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO MODE: MODE1 Mask                  */
N
N#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO MODE: MODE2 Position              */
N#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO MODE: MODE2 Mask                  */
N
N#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO MODE: MODE3 Position              */
N#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO MODE: MODE3 Mask                  */
N
N#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO MODE: MODE4 Position              */
N#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO MODE: MODE4 Mask                  */
N
N#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO MODE: MODE5 Position              */
N#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO MODE: MODE5 Mask                  */
N
N#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO MODE: MODE6 Position              */
N#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO MODE: MODE6 Mask                  */
N
N#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO MODE: MODE7 Position              */
N#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO MODE: MODE7 Mask                  */
N
N#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO MODE: MODE8 Position              */
N#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO MODE: MODE8 Mask                  */
N
N#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO MODE: MODE9 Position              */
N#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO MODE: MODE9 Mask                  */
N
N#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO MODE: MODE10 Position             */
N#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO MODE: MODE10 Mask                 */
N
N#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO MODE: MODE11 Position             */
N#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO MODE: MODE11 Mask                 */
N
N#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO MODE: MODE12 Position             */
N#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO MODE: MODE12 Mask                 */
N
N#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO MODE: MODE13 Position             */
N#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO MODE: MODE13 Mask                 */
N
N#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO MODE: MODE14 Position             */
N#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO MODE: MODE14 Mask                 */
N
N#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO MODE: MODE15 Position             */
N#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO MODE: MODE15 Mask                 */
N
N#define GPIO_DINOFF_DINOFF16_Pos         (16)                                              /*!< GPIO DINOFF: DINOFF16 Position         */
N#define GPIO_DINOFF_DINOFF16_Msk         (0x1ul << GPIO_DINOFF_DINOFF16_Pos)               /*!< GPIO DINOFF: DINOFF16 Mask             */
N
N#define GPIO_DINOFF_DINOFF17_Pos         (17)                                              /*!< GPIO DINOFF: DINOFF17 Position         */
N#define GPIO_DINOFF_DINOFF17_Msk         (0x1ul << GPIO_DINOFF_DINOFF17_Pos)               /*!< GPIO DINOFF: DINOFF17 Mask             */
N
N#define GPIO_DINOFF_DINOFF18_Pos         (18)                                              /*!< GPIO DINOFF: DINOFF18 Position         */
N#define GPIO_DINOFF_DINOFF18_Msk         (0x1ul << GPIO_DINOFF_DINOFF18_Pos)               /*!< GPIO DINOFF: DINOFF18 Mask             */
N
N#define GPIO_DINOFF_DINOFF19_Pos         (19)                                              /*!< GPIO DINOFF: DINOFF19 Position         */
N#define GPIO_DINOFF_DINOFF19_Msk         (0x1ul << GPIO_DINOFF_DINOFF19_Pos)               /*!< GPIO DINOFF: DINOFF19 Mask             */
N
N#define GPIO_DINOFF_DINOFF20_Pos         (20)                                              /*!< GPIO DINOFF: DINOFF20 Position         */
N#define GPIO_DINOFF_DINOFF20_Msk         (0x1ul << GPIO_DINOFF_DINOFF20_Pos)               /*!< GPIO DINOFF: DINOFF20 Mask             */
N
N#define GPIO_DINOFF_DINOFF21_Pos         (21)                                              /*!< GPIO DINOFF: DINOFF21 Position         */
N#define GPIO_DINOFF_DINOFF21_Msk         (0x1ul << GPIO_DINOFF_DINOFF21_Pos)               /*!< GPIO DINOFF: DINOFF21 Mask             */
N
N#define GPIO_DINOFF_DINOFF22_Pos         (22)                                              /*!< GPIO DINOFF: DINOFF22 Position         */
N#define GPIO_DINOFF_DINOFF22_Msk         (0x1ul << GPIO_DINOFF_DINOFF22_Pos)               /*!< GPIO DINOFF: DINOFF22 Mask             */
N
N#define GPIO_DINOFF_DINOFF23_Pos         (23)                                              /*!< GPIO DINOFF: DINOFF23 Position         */
N#define GPIO_DINOFF_DINOFF23_Msk         (0x1ul << GPIO_DINOFF_DINOFF23_Pos)               /*!< GPIO DINOFF: DINOFF23 Mask             */
N
N#define GPIO_DINOFF_DINOFF24_Pos         (24)                                              /*!< GPIO DINOFF: DINOFF24 Position         */
N#define GPIO_DINOFF_DINOFF24_Msk         (0x1ul << GPIO_DINOFF_DINOFF24_Pos)               /*!< GPIO DINOFF: DINOFF24 Mask             */
N
N#define GPIO_DINOFF_DINOFF25_Pos         (25)                                              /*!< GPIO DINOFF: DINOFF25 Position         */
N#define GPIO_DINOFF_DINOFF25_Msk         (0x1ul << GPIO_DINOFF_DINOFF25_Pos)               /*!< GPIO DINOFF: DINOFF25 Mask             */
N
N#define GPIO_DINOFF_DINOFF26_Pos         (26)                                              /*!< GPIO DINOFF: DINOFF26 Position         */
N#define GPIO_DINOFF_DINOFF26_Msk         (0x1ul << GPIO_DINOFF_DINOFF26_Pos)               /*!< GPIO DINOFF: DINOFF26 Mask             */
N
N#define GPIO_DINOFF_DINOFF27_Pos         (27)                                              /*!< GPIO DINOFF: DINOFF27 Position         */
N#define GPIO_DINOFF_DINOFF27_Msk         (0x1ul << GPIO_DINOFF_DINOFF27_Pos)               /*!< GPIO DINOFF: DINOFF27 Mask             */
N
N#define GPIO_DINOFF_DINOFF28_Pos         (28)                                              /*!< GPIO DINOFF: DINOFF28 Position         */
N#define GPIO_DINOFF_DINOFF28_Msk         (0x1ul << GPIO_DINOFF_DINOFF28_Pos)               /*!< GPIO DINOFF: DINOFF28 Mask             */
N
N#define GPIO_DINOFF_DINOFF29_Pos         (29)                                              /*!< GPIO DINOFF: DINOFF29 Position         */
N#define GPIO_DINOFF_DINOFF29_Msk         (0x1ul << GPIO_DINOFF_DINOFF29_Pos)               /*!< GPIO DINOFF: DINOFF29 Mask             */
N
N#define GPIO_DINOFF_DINOFF30_Pos         (30)                                              /*!< GPIO DINOFF: DINOFF30 Position         */
N#define GPIO_DINOFF_DINOFF30_Msk         (0x1ul << GPIO_DINOFF_DINOFF30_Pos)               /*!< GPIO DINOFF: DINOFF30 Mask             */
N
N#define GPIO_DINOFF_DINOFF31_Pos         (31)                                              /*!< GPIO DINOFF: DINOFF31 Position         */
N#define GPIO_DINOFF_DINOFF31_Msk         (0x1ul << GPIO_DINOFF_DINOFF31_Pos)               /*!< GPIO DINOFF: DINOFF31 Mask             */
N
N#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO DOUT: DOUT0 Position              */
N#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO DOUT: DOUT0 Mask                  */
N
N#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO DOUT: DOUT1 Position              */
N#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO DOUT: DOUT1 Mask                  */
N
N#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO DOUT: DOUT2 Position              */
N#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO DOUT: DOUT2 Mask                  */
N
N#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO DOUT: DOUT3 Position              */
N#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO DOUT: DOUT3 Mask                  */
N
N#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO DOUT: DOUT4 Position              */
N#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO DOUT: DOUT4 Mask                  */
N
N#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO DOUT: DOUT5 Position              */
N#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO DOUT: DOUT5 Mask                  */
N
N#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO DOUT: DOUT6 Position              */
N#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO DOUT: DOUT6 Mask                  */
N
N#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO DOUT: DOUT7 Position              */
N#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO DOUT: DOUT7 Mask                  */
N
N#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO DOUT: DOUT8 Position              */
N#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO DOUT: DOUT8 Mask                  */
N
N#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO DOUT: DOUT9 Position              */
N#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO DOUT: DOUT9 Mask                  */
N
N#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO DOUT: DOUT10 Position             */
N#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO DOUT: DOUT10 Mask                 */
N
N#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO DOUT: DOUT11 Position             */
N#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO DOUT: DOUT11 Mask                 */
N
N#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO DOUT: DOUT12 Position             */
N#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO DOUT: DOUT12 Mask                 */
N
N#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO DOUT: DOUT13 Position             */
N#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO DOUT: DOUT13 Mask                 */
N
N#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO DOUT: DOUT14 Position             */
N#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO DOUT: DOUT14 Mask                 */
N
N#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO DOUT: DOUT15 Position             */
N#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO DOUT: DOUT15 Mask                 */
N
N#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO DATMSK: DATMSK0 Position          */
N#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO DATMSK: DATMSK0 Mask              */
N
N#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO DATMSK: DATMSK1 Position          */
N#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO DATMSK: DATMSK1 Mask              */
N
N#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO DATMSK: DATMSK2 Position          */
N#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO DATMSK: DATMSK2 Mask              */
N
N#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO DATMSK: DATMSK3 Position          */
N#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO DATMSK: DATMSK3 Mask              */
N
N#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO DATMSK: DATMSK4 Position          */
N#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO DATMSK: DATMSK4 Mask              */
N
N#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO DATMSK: DATMSK5 Position          */
N#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO DATMSK: DATMSK5 Mask              */
N
N#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO DATMSK: DATMSK6 Position          */
N#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO DATMSK: DATMSK6 Mask              */
N
N#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO DATMSK: DATMSK7 Position          */
N#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO DATMSK: DATMSK7 Mask              */
N
N#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO DATMSK: DATMSK8 Position          */
N#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO DATMSK: DATMSK8 Mask              */
N
N#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO DATMSK: DATMSK9 Position          */
N#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO DATMSK: DATMSK9 Mask              */
N
N#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO DATMSK: DATMSK10 Position         */
N#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO DATMSK: DATMSK10 Mask             */
N
N#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO DATMSK: DATMSK11 Position         */
N#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO DATMSK: DATMSK11 Mask             */
N
N#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO DATMSK: DATMSK12 Position         */
N#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO DATMSK: DATMSK12 Mask             */
N
N#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO DATMSK: DATMSK13 Position         */
N#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO DATMSK: DATMSK13 Mask             */
N
N#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO DATMSK: DATMSK14 Position         */
N#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO DATMSK: DATMSK14 Mask             */
N
N#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO DATMSK: DATMSK15 Position         */
N#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO DATMSK: DATMSK15 Mask             */
N
N#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO PIN: PIN0 Position                */
N#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO PIN: PIN0 Mask                    */
N
N#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO PIN: PIN1 Position                */
N#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO PIN: PIN1 Mask                    */
N
N#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO PIN: PIN2 Position                */
N#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO PIN: PIN2 Mask                    */
N
N#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO PIN: PIN3 Position                */
N#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO PIN: PIN3 Mask                    */
N
N#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO PIN: PIN4 Position                */
N#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO PIN: PIN4 Mask                    */
N
N#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO PIN: PIN5 Position                */
N#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO PIN: PIN5 Mask                    */
N
N#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO PIN: PIN6 Position                */
N#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO PIN: PIN6 Mask                    */
N
N#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO PIN: PIN7 Position                */
N#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO PIN: PIN7 Mask                    */
N
N#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO PIN: PIN8 Position                */
N#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO PIN: PIN8 Mask                    */
N
N#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO PIN: PIN9 Position                */
N#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO PIN: PIN9 Mask                    */
N
N#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO PIN: PIN10 Position               */
N#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO PIN: PIN10 Mask                   */
N
N#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO PIN: PIN11 Position               */
N#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO PIN: PIN11 Mask                   */
N
N#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO PIN: PIN12 Position               */
N#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO PIN: PIN12 Mask                   */
N
N#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO PIN: PIN13 Position               */
N#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO PIN: PIN13 Mask                   */
N
N#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO PIN: PIN14 Position               */
N#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO PIN: PIN14 Mask                   */
N
N#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO PIN: PIN15 Position               */
N#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO PIN: PIN15 Mask                   */
N
N#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO DBEN: DBEN0 Position              */
N#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO DBEN: DBEN0 Mask                  */
N
N#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO DBEN: DBEN1 Position              */
N#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO DBEN: DBEN1 Mask                  */
N
N#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO DBEN: DBEN2 Position              */
N#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO DBEN: DBEN2 Mask                  */
N
N#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO DBEN: DBEN3 Position              */
N#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO DBEN: DBEN3 Mask                  */
N
N#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO DBEN: DBEN4 Position              */
N#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO DBEN: DBEN4 Mask                  */
N
N#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO DBEN: DBEN5 Position              */
N#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO DBEN: DBEN5 Mask                  */
N
N#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO DBEN: DBEN6 Position              */
N#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO DBEN: DBEN6 Mask                  */
N
N#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO DBEN: DBEN7 Position              */
N#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO DBEN: DBEN7 Mask                  */
N
N#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO DBEN: DBEN8 Position              */
N#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO DBEN: DBEN8 Mask                  */
N
N#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO DBEN: DBEN9 Position              */
N#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO DBEN: DBEN9 Mask                  */
N
N#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO DBEN: DBEN10 Position             */
N#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO DBEN: DBEN10 Mask                 */
N
N#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO DBEN: DBEN11 Position             */
N#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO DBEN: DBEN11 Mask                 */
N
N#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO DBEN: DBEN12 Position             */
N#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO DBEN: DBEN12 Mask                 */
N
N#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO DBEN: DBEN13 Position             */
N#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO DBEN: DBEN13 Mask                 */
N
N#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO DBEN: DBEN14 Position             */
N#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO DBEN: DBEN14 Mask                 */
N
N#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO DBEN: DBEN15 Position             */
N#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO DBEN: DBEN15 Mask                 */
N
N#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO INTTYPE: TYPE0 Position           */
N#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO INTTYPE: TYPE0 Mask               */
N
N#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO INTTYPE: TYPE1 Position           */
N#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO INTTYPE: TYPE1 Mask               */
N
N#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO INTTYPE: TYPE2 Position           */
N#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO INTTYPE: TYPE2 Mask               */
N
N#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO INTTYPE: TYPE3 Position           */
N#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO INTTYPE: TYPE3 Mask               */
N
N#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO INTTYPE: TYPE4 Position           */
N#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO INTTYPE: TYPE4 Mask               */
N
N#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO INTTYPE: TYPE5 Position           */
N#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO INTTYPE: TYPE5 Mask               */
N
N#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO INTTYPE: TYPE6 Position           */
N#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO INTTYPE: TYPE6 Mask               */
N
N#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO INTTYPE: TYPE7 Position           */
N#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO INTTYPE: TYPE7 Mask               */
N
N#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO INTTYPE: TYPE8 Position           */
N#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO INTTYPE: TYPE8 Mask               */
N
N#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO INTTYPE: TYPE9 Position           */
N#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO INTTYPE: TYPE9 Mask               */
N
N#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO INTTYPE: TYPE10 Position          */
N#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO INTTYPE: TYPE10 Mask              */
N
N#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO INTTYPE: TYPE11 Position          */
N#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO INTTYPE: TYPE11 Mask              */
N
N#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO INTTYPE: TYPE12 Position          */
N#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO INTTYPE: TYPE12 Mask              */
N
N#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO INTTYPE: TYPE13 Position          */
N#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO INTTYPE: TYPE13 Mask              */
N
N#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO INTTYPE: TYPE14 Position          */
N#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO INTTYPE: TYPE14 Mask              */
N
N#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO INTTYPE: TYPE15 Position          */
N#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO INTTYPE: TYPE15 Mask              */
N
N#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO INTEN: FLIEN0 Position            */
N#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO INTEN: FLIEN0 Mask                */
N
N#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO INTEN: FLIEN1 Position            */
N#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO INTEN: FLIEN1 Mask                */
N
N#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO INTEN: FLIEN2 Position            */
N#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO INTEN: FLIEN2 Mask                */
N
N#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO INTEN: FLIEN3 Position            */
N#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO INTEN: FLIEN3 Mask                */
N
N#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO INTEN: FLIEN4 Position            */
N#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO INTEN: FLIEN4 Mask                */
N
N#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO INTEN: FLIEN5 Position            */
N#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO INTEN: FLIEN5 Mask                */
N
N#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO INTEN: FLIEN6 Position            */
N#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO INTEN: FLIEN6 Mask                */
N
N#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO INTEN: FLIEN7 Position            */
N#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO INTEN: FLIEN7 Mask                */
N
N#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO INTEN: FLIEN8 Position            */
N#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO INTEN: FLIEN8 Mask                */
N
N#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO INTEN: FLIEN9 Position            */
N#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO INTEN: FLIEN9 Mask                */
N
N#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO INTEN: FLIEN10 Position           */
N#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO INTEN: FLIEN10 Mask               */
N
N#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO INTEN: FLIEN11 Position           */
N#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO INTEN: FLIEN11 Mask               */
N
N#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO INTEN: FLIEN12 Position           */
N#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO INTEN: FLIEN12 Mask               */
N
N#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO INTEN: FLIEN13 Position           */
N#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO INTEN: FLIEN13 Mask               */
N
N#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO INTEN: FLIEN14 Position           */
N#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO INTEN: FLIEN14 Mask               */
N
N#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO INTEN: FLIEN15 Position           */
N#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO INTEN: FLIEN15 Mask               */
N
N#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO INTEN: RHIEN0 Position            */
N#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO INTEN: RHIEN0 Mask                */
N
N#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO INTEN: RHIEN1 Position            */
N#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO INTEN: RHIEN1 Mask                */
N
N#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO INTEN: RHIEN2 Position            */
N#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO INTEN: RHIEN2 Mask                */
N
N#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO INTEN: RHIEN3 Position            */
N#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO INTEN: RHIEN3 Mask                */
N
N#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO INTEN: RHIEN4 Position            */
N#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO INTEN: RHIEN4 Mask                */
N
N#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO INTEN: RHIEN5 Position            */
N#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO INTEN: RHIEN5 Mask                */
N
N#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO INTEN: RHIEN6 Position            */
N#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO INTEN: RHIEN6 Mask                */
N
N#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO INTEN: RHIEN7 Position            */
N#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO INTEN: RHIEN7 Mask                */
N
N#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO INTEN: RHIEN8 Position            */
N#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO INTEN: RHIEN8 Mask                */
N
N#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO INTEN: RHIEN9 Position            */
N#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO INTEN: RHIEN9 Mask                */
N
N#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO INTEN: RHIEN10 Position           */
N#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO INTEN: RHIEN10 Mask               */
N
N#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO INTEN: RHIEN11 Position           */
N#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO INTEN: RHIEN11 Mask               */
N
N#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO INTEN: RHIEN12 Position           */
N#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO INTEN: RHIEN12 Mask               */
N
N#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO INTEN: RHIEN13 Position           */
N#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO INTEN: RHIEN13 Mask               */
N
N#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO INTEN: RHIEN14 Position           */
N#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO INTEN: RHIEN14 Mask               */
N
N#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO INTEN: RHIEN15 Position           */
N#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO INTEN: RHIEN15 Mask               */
N
N#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO INTSRC: INTSRC0 Position          */
N#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO INTSRC: INTSRC0 Mask              */
N
N#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO INTSRC: INTSRC1 Position          */
N#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO INTSRC: INTSRC1 Mask              */
N
N#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO INTSRC: INTSRC2 Position          */
N#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO INTSRC: INTSRC2 Mask              */
N
N#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO INTSRC: INTSRC3 Position          */
N#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO INTSRC: INTSRC3 Mask              */
N
N#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO INTSRC: INTSRC4 Position          */
N#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO INTSRC: INTSRC4 Mask              */
N
N#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO INTSRC: INTSRC5 Position          */
N#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO INTSRC: INTSRC5 Mask              */
N
N#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO INTSRC: INTSRC6 Position          */
N#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO INTSRC: INTSRC6 Mask              */
N
N#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO INTSRC: INTSRC7 Position          */
N#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO INTSRC: INTSRC7 Mask              */
N
N#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO INTSRC: INTSRC8 Position          */
N#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO INTSRC: INTSRC8 Mask              */
N
N#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO INTSRC: INTSRC9 Position          */
N#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO INTSRC: INTSRC9 Mask              */
N
N#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO INTSRC: INTSRC10 Position         */
N#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO INTSRC: INTSRC10 Mask             */
N
N#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO INTSRC: INTSRC11 Position         */
N#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO INTSRC: INTSRC11 Mask             */
N
N#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO INTSRC: INTSRC12 Position         */
N#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO INTSRC: INTSRC12 Mask             */
N
N#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO INTSRC: INTSRC13 Position         */
N#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO INTSRC: INTSRC13 Mask             */
N
N#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO INTSRC: INTSRC14 Position         */
N#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO INTSRC: INTSRC14 Mask             */
N
N#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO INTSRC: INTSRC15 Position         */
N#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO INTSRC: INTSRC15 Mask             */
N
N#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO DBCTL: DBCLKSEL Position          */
N#define GPIO_DBCTL_DBCLKSEL_Msk          (0xful << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO DBCTL: DBCLKSEL Mask              */
N
N#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO DBCTL: DBCLKSRC Position          */
N#define GPIO_DBCTL_DBCLKSRC_Msk          (0x1ul << GPIO_DBCTL_DBCLKSRC_Pos)                /*!< GPIO DBCTL: DBCLKSRC Mask              */
N
N#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO DBCTL: ICLKON Position            */
N#define GPIO_DBCTL_ICLKON_Msk            (0x1ul << GPIO_DBCTL_ICLKON_Pos)                  /*!< GPIO DBCTL: ICLKON Mask                */
N
N/**@}*/ /* GPIO_CONST */
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge Control Bit
N     * |        |          |When AA=1 prior to address or data received, an acknowledge (ACK - low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when:
N     * |        |          |1. A slave is acknowledging the address sent from master,
N     * |        |          |2. The receiver devices are acknowledging the data sent by transmitter.
N     * |        |          |When AA = 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line
N     * |[3]     |SI        |I2C Interrupt Flag
N     * |        |          |When a new SIO state is present in the I2C_STATUS register, the SI flag is set by hardware, and if bit EI ( I2C_CTL[7]) is set, the I2C interrupt is requested.
N     * |        |          |SI must be cleared by software.
N     * |        |          |Clear SI is by writing one to this bit.
N     * |[4]     |STO       |I2C STOP Control Bit
N     * |        |          |In master mode, set STO to transmit a STOP condition to bus.
N     * |        |          |I2C hardware will check the bus condition, when a STOP condition is detected this bit will be cleared by hardware automatically.
N     * |        |          |In slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
N     * |        |          |This means it is NO LONGER in the slave receiver mode able receive data from the master transmit device.
N     * |[5]     |STA       |I2C START Control Bit
N     * |        |          |Setting STA to logic 1 will enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
N     * |[6]     |I2CEN     |I2C Controller Enable Bit
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |        |          |Set to enable I2C serial function block. 
N     * |[7]     |INTEN     |Enable Interrupt
N     * |        |          |0 = Disable interrupt.
N     * |        |          |1 = Enable interrupt CPU.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * ADDR0
N     * ===================================================================================================
N     * Offset: 0x04  I2C Slave address Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[1:7]   |ADDR      |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if any of the addresses are matched.
N */
N    __IO uint32_t ADDR0;                 
X    volatile uint32_t ADDR0;                 
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x08  I2C DATA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |DAT       |I2C Data Register
N     * |        |          |During master or slave transmit mode, data to be transmitted is written to this register.
N     * |        |          |During master or slave receive mode, data that has been received may be read from this register.
N */
N    __IO uint32_t DAT;                   
X    volatile uint32_t DAT;                   
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |STATUS    |I2C Status Register
N     * |        |          |The status register of I2C:
N     * |        |          |The three least significant bits are always 0.
N     * |        |          |The five most significant bits contain the status code.
N     * |        |          |There are 26 possible status codes.
N     * |        |          |When STATUS contains F8H, no serial interrupt is requested.
N     * |        |          |All other STATUS values correspond to defined I2C states.
N     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N     * |        |          |A valid status code is present in STATUS one PCLK cycle after SI is set by hardware and is still present one PCLK cycle after SI has been reset by software.
N     * |        |          |In addition, states 00H stands for a Bus Error.
N     * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the frame.
N     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N */
N    __I  uint32_t STATUS;                
X    volatile const  uint32_t STATUS;                
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x10  I2C clock divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |DIVIDER   |I2C Clock Divided Register
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x( CLK+1)).
N */
N    __IO uint32_t CLKDIV;                
X    volatile uint32_t CLKDIV;                
N
N    /**
N     * TOCTL
N     * ===================================================================================================
N     * Offset: 0x14  I2C Time out control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOIF      |Time-Out Flag
N     * |        |          |0 = No time-out.
N     * |        |          |1 = Time-out flag is set by H/W. It can interrupt CPU. Write 1 to clear.
N     * |[1]     |TOCDIV4   |Time-Out Counter Input Clock Divide By 4
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |        |          |When enabled, the time-out clock is PCLK/4.
N     * |[2]     |TOCEN     |Time-out Counter Control Bit
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |        |          |When enabled, the 14 bit time-out counter will start counting when SI is clear.
N     * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
N */
N    __IO uint32_t TOCTL;                 
X    volatile uint32_t TOCTL;                 
N
N    /**
N     * ADDR1
N     * ===================================================================================================
N     * Offset: 0x18  I2C Slave address Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[1:7]   |ADDR      |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if any of the addresses are matched.
N */
N    __IO uint32_t ADDR1;                 
X    volatile uint32_t ADDR1;                 
N
N    /**
N     * ADDR2
N     * ===================================================================================================
N     * Offset: 0x1C  I2C Slave address Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[1:7]   |ADDR      |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if any of the addresses are matched.
N */
N    __IO uint32_t ADDR2;                 
X    volatile uint32_t ADDR2;                 
N
N    /**
N     * ADDR3
N     * ===================================================================================================
N     * Offset: 0x20  I2C Slave address Register3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[1:7]   |ADDR      |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if any of the addresses are matched.
N */
N    __IO uint32_t ADDR3;                 
X    volatile uint32_t ADDR3;                 
N
N    /**
N     * ADDRMSK0
N     * ===================================================================================================
N     * Offset: 0x24  I2C Slave address Mask Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |ADDRMSK1  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[2]     |ADDRMSK2  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[3]     |ADDRMSK3  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[4]     |ADDRMSK4  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[5]     |ADDRMSK5  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[6]     |ADDRMSK6  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[7]     |ADDRMSK7  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N */
N    __IO uint32_t ADDRMSK0;              
X    volatile uint32_t ADDRMSK0;              
N
N    /**
N     * ADDRMSK1
N     * ===================================================================================================
N     * Offset: 0x28  I2C Slave address Mask Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |ADDRMSK1  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[2]     |ADDRMSK2  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[3]     |ADDRMSK3  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[4]     |ADDRMSK4  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[5]     |ADDRMSK5  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[6]     |ADDRMSK6  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[7]     |ADDRMSK7  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N */
N    __IO uint32_t ADDRMSK1;              
X    volatile uint32_t ADDRMSK1;              
N
N    /**
N     * ADDRMSK2
N     * ===================================================================================================
N     * Offset: 0x2C  I2C Slave address Mask Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |ADDRMSK1  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[2]     |ADDRMSK2  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[3]     |ADDRMSK3  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[4]     |ADDRMSK4  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[5]     |ADDRMSK5  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[6]     |ADDRMSK6  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[7]     |ADDRMSK7  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N */
N    __IO uint32_t ADDRMSK2;              
X    volatile uint32_t ADDRMSK2;              
N
N    /**
N     * ADDRMSK3
N     * ===================================================================================================
N     * Offset: 0x30  I2C Slave address Mask Register3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |ADDRMSK1  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[2]     |ADDRMSK2  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[3]     |ADDRMSK3  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[4]     |ADDRMSK4  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[5]     |ADDRMSK5  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[6]     |ADDRMSK6  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N     * |[7]     |ADDRMSK7  |I2C Address Mask register
N     * |        |          |0 = Mask disable.
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
N     * |        |          |Bits in this field mask the I2C_ADDRx registers.
N     * |        |          |masking bits from the address comparison.
N */
N    __IO uint32_t ADDRMSK3;              
X    volatile uint32_t ADDRMSK3;              
N
N} I2C_T;
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C CTL: AA Position                   */
N#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C CTL: AA Mask                       */
N
N#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C CTL: SI Position                   */
N#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C CTL: SI Mask                       */
N
N#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C CTL: STO Position                  */
N#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C CTL: STO Mask                      */
N
N#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C CTL: STA Position                  */
N#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C CTL: STA Mask                      */
N
N#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C CTL: I2CEN Position                */
N#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C CTL: I2CEN Mask                    */
N
N#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C CTL: INTEN Position                */
N#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C CTL: INTEN Mask                    */
N
N#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C ADDR0: GC Position                 */
N#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C ADDR0: GC Mask                     */
N
N#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C ADDR0: ADDR Position               */
N#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C ADDR0: ADDR Mask                   */
N
N#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C DAT: DAT Position                  */
N#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C DAT: DAT Mask                      */
N
N#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C STATUS: STATUS Position            */
N#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C STATUS: STATUS Mask                */
N
N#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C CLKDIV: DIVIDER Position           */
N#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C CLKDIV: DIVIDER Mask               */
N
N#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C TOCTL: TOIF Position               */
N#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C TOCTL: TOIF Mask                   */
N
N#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C TOCTL: TOCDIV4 Position            */
N#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C TOCTL: TOCDIV4 Mask                */
N
N#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C TOCTL: TOCEN Position              */
N#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C TOCTL: TOCEN Mask                  */
N
N#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C ADDR1: GC Position                 */
N#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C ADDR1: GC Mask                     */
N
N#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C ADDR1: ADDR Position               */
N#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C ADDR1: ADDR Mask                   */
N
N#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C ADDR2: GC Position                 */
N#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C ADDR2: GC Mask                     */
N
N#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C ADDR2: ADDR Position               */
N#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C ADDR2: ADDR Mask                   */
N
N#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C ADDR3: GC Position                 */
N#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C ADDR3: GC Mask                     */
N
N#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C ADDR3: ADDR Position               */
N#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C ADDR3: ADDR Mask                   */
N
N#define I2C_ADDRMSK0_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK0: ADDRMSK1 Position        */
N#define I2C_ADDRMSK0_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK1_Pos)              /*!< I2C ADDRMSK0: ADDRMSK1 Mask            */
N
N#define I2C_ADDRMSK0_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK0: ADDRMSK2 Position        */
N#define I2C_ADDRMSK0_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK2_Pos)              /*!< I2C ADDRMSK0: ADDRMSK2 Mask            */
N
N#define I2C_ADDRMSK0_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK0: ADDRMSK3 Position        */
N#define I2C_ADDRMSK0_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK3_Pos)              /*!< I2C ADDRMSK0: ADDRMSK3 Mask            */
N
N#define I2C_ADDRMSK0_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK0: ADDRMSK4 Position        */
N#define I2C_ADDRMSK0_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK4_Pos)              /*!< I2C ADDRMSK0: ADDRMSK4 Mask            */
N
N#define I2C_ADDRMSK0_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK0: ADDRMSK5 Position        */
N#define I2C_ADDRMSK0_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK5_Pos)              /*!< I2C ADDRMSK0: ADDRMSK5 Mask            */
N
N#define I2C_ADDRMSK0_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK0: ADDRMSK6 Position        */
N#define I2C_ADDRMSK0_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK6_Pos)              /*!< I2C ADDRMSK0: ADDRMSK6 Mask            */
N
N#define I2C_ADDRMSK0_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK0: ADDRMSK7 Position        */
N#define I2C_ADDRMSK0_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK7_Pos)              /*!< I2C ADDRMSK0: ADDRMSK7 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK1: ADDRMSK1 Position        */
N#define I2C_ADDRMSK1_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK1_Pos)              /*!< I2C ADDRMSK1: ADDRMSK1 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK1: ADDRMSK2 Position        */
N#define I2C_ADDRMSK1_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK2_Pos)              /*!< I2C ADDRMSK1: ADDRMSK2 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK1: ADDRMSK3 Position        */
N#define I2C_ADDRMSK1_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK3_Pos)              /*!< I2C ADDRMSK1: ADDRMSK3 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK1: ADDRMSK4 Position        */
N#define I2C_ADDRMSK1_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK4_Pos)              /*!< I2C ADDRMSK1: ADDRMSK4 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK1: ADDRMSK5 Position        */
N#define I2C_ADDRMSK1_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK5_Pos)              /*!< I2C ADDRMSK1: ADDRMSK5 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK1: ADDRMSK6 Position        */
N#define I2C_ADDRMSK1_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK6_Pos)              /*!< I2C ADDRMSK1: ADDRMSK6 Mask            */
N
N#define I2C_ADDRMSK1_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK1: ADDRMSK7 Position        */
N#define I2C_ADDRMSK1_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK7_Pos)              /*!< I2C ADDRMSK1: ADDRMSK7 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK2: ADDRMSK1 Position        */
N#define I2C_ADDRMSK2_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK1_Pos)              /*!< I2C ADDRMSK2: ADDRMSK1 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK2: ADDRMSK2 Position        */
N#define I2C_ADDRMSK2_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK2_Pos)              /*!< I2C ADDRMSK2: ADDRMSK2 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK2: ADDRMSK3 Position        */
N#define I2C_ADDRMSK2_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK3_Pos)              /*!< I2C ADDRMSK2: ADDRMSK3 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK2: ADDRMSK4 Position        */
N#define I2C_ADDRMSK2_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK4_Pos)              /*!< I2C ADDRMSK2: ADDRMSK4 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK2: ADDRMSK5 Position        */
N#define I2C_ADDRMSK2_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK5_Pos)              /*!< I2C ADDRMSK2: ADDRMSK5 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK2: ADDRMSK6 Position        */
N#define I2C_ADDRMSK2_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK6_Pos)              /*!< I2C ADDRMSK2: ADDRMSK6 Mask            */
N
N#define I2C_ADDRMSK2_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK2: ADDRMSK7 Position        */
N#define I2C_ADDRMSK2_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK7_Pos)              /*!< I2C ADDRMSK2: ADDRMSK7 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK3: ADDRMSK1 Position        */
N#define I2C_ADDRMSK3_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK1_Pos)              /*!< I2C ADDRMSK3: ADDRMSK1 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK3: ADDRMSK2 Position        */
N#define I2C_ADDRMSK3_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK2_Pos)              /*!< I2C ADDRMSK3: ADDRMSK2 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK3: ADDRMSK3 Position        */
N#define I2C_ADDRMSK3_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK3_Pos)              /*!< I2C ADDRMSK3: ADDRMSK3 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK3: ADDRMSK4 Position        */
N#define I2C_ADDRMSK3_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK4_Pos)              /*!< I2C ADDRMSK3: ADDRMSK4 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK3: ADDRMSK5 Position        */
N#define I2C_ADDRMSK3_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK5_Pos)              /*!< I2C ADDRMSK3: ADDRMSK5 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK3: ADDRMSK6 Position        */
N#define I2C_ADDRMSK3_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK6_Pos)              /*!< I2C ADDRMSK3: ADDRMSK6 Mask            */
N
N#define I2C_ADDRMSK3_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK3: ADDRMSK7 Position        */
N#define I2C_ADDRMSK3_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK7_Pos)              /*!< I2C ADDRMSK3: ADDRMSK7 Mask            */
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  I2S Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2SEN     |Enable I2S Controller
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |[1]     |TXEN      |Transmit Enable
N     * |        |          |0 = Disable data transmit
N     * |        |          |1 = Enable data transmit 
N     * |[2]     |RXEN      |Receive Enable
N     * |        |          |0 = Disable data receive
N     * |        |          |1 = Enable data receive 
N     * |[3]     |MUTE      |Transmit Mute Enable
N     * |        |          |0 = Transmit data is shifted from FIFO
N     * |        |          |1= Transmit channel zero
N     * |[4:5]   |WDWIDTH   |Word Width
N     * |        |          |This parameter sets the word width of audio data.
N     * |        |          |See Figure 5-63 for details of how data is formatted in transmit and receive FIFO.
N     * |        |          |00 = data is 8 bit
N     * |        |          |01 = data is 16 bit
N     * |        |          |10 = data is 24 bit
N     * |        |          |11 = data is 32 bit
N     * |[6]     |MONO      |Monaural data
N     * |        |          |This parameter sets whether mono or stereo data is processed.
N     * |        |          |See Figure 5-63 for details of how data is formatted in transmit and receive FIFO.
N     * |        |          |0 = Data is stereo format
N     * |        |          |1 = Data is monaural format
N     * |[7]     |FORMAT    |Data format
N     * |        |          |0 = I2S data format
N     * |        |          |1 = MSB justified data format
N     * |        |          |See Figure 5-61 and Figure 5-62 for timing differences.
N     * |[8]     |SLAVE     |Slave Mode
N     * |        |          |I2S can operate as a master or slave.
N     * |        |          |For master mode, I2S_BCLK and I2S_FS pins are outputs and send bit clock and frame sync from ISD9100.
N     * |        |          |In slave mode, I2S_BCLK and I2S_FS pins are inputs and bit clock and frame sync are received from external audio device.
N     * |        |          |0 = Master mode
N     * |        |          |1 = Slave mode 
N     * |[9:11]  |TXTH      |Transmit FIFO Threshold Level
N     * |        |          |If remaining data words in transmit FIFO less than or equal to the threshold level then TXTHI flag is set.
N     * |        |          |Threshold = TXTH words remaining in transmit FIFO
N     * |[12:14] |RXTH      |Receive FIFO Threshold Level
N     * |        |          |When received data word(s) in buffer is equal or higher than threshold level then RXTHI flag is set.
N     * |        |          |Threshold = RXTH+1 words of data in receive FIFO.
N     * |[15]    |MCLKEN    |Master Clock Enable
N     * |        |          |The ISD9100 can generate a master clock signal to an external audio CODEC to synchronize the audio devices.
N     * |        |          |If audio devices are not synchronous, then data will be periodically corrupted.
N     * |        |          |Software needs to implement a way to drop/repeat or interpolate samples in a jitter buffer if devices are not synchronized.
N     * |        |          |The master clock frequency is determined by the I2S_CLKDIV.MCLKDIV.
N     * |        |          |register.
N     * |        |          |0 = Disable master clock
N     * |        |          |1 = Enable master clock
N     * |[16]    |RZCEN     |Right Channel Zero Cross Detect Enable
N     * |        |          |If this bit is set to 1, when right channel data sign bit changes, or data bits are all zero, the RZCIF flag in I2S_STATUS register will be set to 1.
N     * |        |          |0 = Disable right channel zero cross detect
N     * |        |          |1 = Enable right channel zero cross detect
N     * |[17]    |LZCEN     |Left Channel Zero Cross Detect Enable
N     * |        |          |If this bit is set to 1, when left channel data sign bit changes, or data bits are all zero, the LZCIF flag in I2S_STATUS register will be set to 1.
N     * |        |          |0 = Disable left channel zero cross detect
N     * |        |          |1 = Enable left channel zero cross detect
N     * |[18]    |TXCLR     |Clear Transmit FIFO
N     * |        |          |Write 1 to clear transmitting FIFO, internal pointer is reset to FIFO start point, and TXTH returns to zero and transmit FIFO becomes empty.
N     * |        |          |Data in transmit FIFO is not changed.
N     * |        |          |This bit is cleared by hardware automatically when clear operation complete.
N     * |[19]    |RXCLR     |Clear Receive FIFO
N     * |        |          |Write 1 to clear receiving FIFO, internal pointer is reset to FIFO start point, and RXTH returns to zero and receive FIFO becomes empty.
N     * |        |          |This bit is cleared by hardware automatically when clear operation complete.
N     * |[20]    |TXPDMAEN  |Enable Transmit DMA
N     * |        |          |When TX DMA is enables, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.
N     * |        |          |0 = Disable TX DMA
N     * |        |          |1 = Enable TX DMA
N     * |[21]    |RXPDMAEN  |Enable Receive DMA
N     * |        |          |When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.
N     * |        |          |0 = Disable RX DMA
N     * |        |          |1 = Enable RX DMA
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x04  I2S Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |MCLKDIV   |Master Clock Divider
N     * |        |          |ISD9160 can generate a master clock to synchronously drive an external audio device.
N     * |        |          |If MCLKDIV is set to 0, MCLK is the same as I2S_CLK clock input, otherwise MCLK frequency is given by:.
N     * |        |          |F(MCLK) = F(I2S_CLK) / (2xMCLKDIV)
N     * |        |          |Or,
N     * |        |          |MCLKDIV = F(I2S_CLK) / (2 x F(MCLK))
N     * |        |          |If the desired MCLK frequency is 254Fs and Fs = 16kHz then MCLKDIV = 6
N     * |[8:15]  |BCLKDIV   |Bit Clock Divider
N     * |        |          |If I2S operates in master mode, bit clock is provided by ISD9100.
N     * |        |          |Software can program these bits to generate bit clock frequency for the desired sample rate.
N     * |        |          |For sample rate Fs, the desired bit clock frequency is:
N     * |        |          |F(BCLK) = Fs x Word_width_in_bytes x 16
N     * |        |          |For example if Fs = 16kHz, and word width is 2-bytes (16bit) then desired bit clock frequency is 512kHz.
N     * |        |          |The bit clock frequency is given by:
N     * |        |          |F(BCLK) = F(I2S_CLK) / 2x(BCLKDIV+1)
N     * |        |          |Or,
N     * |        |          |BCLKDIV = F(I2S_CLK) / (2 x F(BCLK)) -1
N     * |        |          |So if F(I2S_CLK) = HCLK = 49.152MHz, desired F(BCLK) = 512kHzthen BCLKDIV = 47
N */
N    __IO uint32_t CLKDIV;                
X    volatile uint32_t CLKDIV;                
N
N    /**
N     * IEN
N     * ===================================================================================================
N     * Offset: 0x08  I2S Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXUDIEN   |Receive FIFO Underflow Interrupt Enable
N     * |        |          |If software read receive FIFO when it is empty then RXUDIF flag in I2SSTATUS register is set to 1.
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[1]     |RXOVIEN   |Receive FIFO Overflow Interrupt Enable
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[2]     |RXTHIEN   |Receive FIFO Threshold Level Interrupt
N     * |        |          |Interrupt occurs if this bit is set to 1 and data words in receive FIFO is greater than or equal to RXTH[2:0].
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[8]     |TXUDIEN   |Transmit FIFO Underflow Interrupt Enable
N     * |        |          |Interrupt occur if this bit is set to 1 and transmit FIFO underflow flag is set to 1.
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[9]     |TXOVIEN   |Transmit FIFO Overflow Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to 1 and transmit FIFO overflow flag is set to 1
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[10]    |TXTHIEN   |Transmit FIFO Threshold Level Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH[2:0].
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[11]    |RZCIEN    |Right Channel Zero Cross Interrupt Enable
N     * |        |          |Interrupt will occur if this bit is set to 1 and right channel has zero cross event
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N     * |[12]    |LZCIEN    |Left Channel Zero Cross Interrupt Enable
N     * |        |          |Interrupt will occur if this bit is set to 1 and left channel has zero cross event
N     * |        |          |0 = Disable interrupt
N     * |        |          |1 = Enable interrupt
N */
N    __IO uint32_t IEN;                   
X    volatile uint32_t IEN;                   
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2S Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2SIF     |I2S Interrupt (Read Only)
N     * |        |          |This bit is set if any enabled I2S interrupt is active.
N     * |        |          |0 = No I2S interrupt
N     * |        |          |1 = I2S interrupt active
N     * |[1]     |RXIF      |I2S Receive Interrupt (Read Only)
N     * |        |          |This indicates that there is an active receive interrupt source.
N     * |        |          |This could be RXOVIF, RXUDIF or RXTHIF if corresponding interrupt enable bits are active.
N     * |        |          |To clear interrupt the corresponding source(s) must be cleared.
N     * |        |          |0 = No receive interrupt
N     * |        |          |1 = Receive interrupt occurred
N     * |[2]     |TXIF      |I2S Transmit Interrupt (Read Only)
N     * |        |          |This indicates that there is an active transmit interrupt source.
N     * |        |          |This could be TXOVIF, TXUDIF, TXTHIF, LZCIF or RZCIF if corresponding interrupt enable bits are active.
N     * |        |          |To clear interrupt the corresponding source(s) must be cleared.
N     * |        |          |0 = No transmit interrupt
N     * |        |          |1 = Transmit interrupt occurred.
N     * |[3]     |RIGHT     |Right Channel Active (Read Only)
N     * |        |          |This bit indicates current data being transmitted/received belongs to right channel
N     * |        |          |0 = Left channel
N     * |        |          |1 = Right channel
N     * |[8]     |RXUDIF    |Receive FIFO Underflow Flag (Write '1' to clear)
N     * |        |          |This flag is set if attempt is made to read receive FIFO while it is empty.
N     * |        |          |0 = No underflow
N     * |        |          |1 = Underflow
N     * |[9]     |RXOVIF    |Receive FIFO Overflow Flag (Write '1' to clear)
N     * |        |          |This flag is set if I2S controller writes to receive FIFO when it is full. Audio data is lost.
N     * |        |          |0 = No overflow
N     * |        |          |1 = Overflow
N     * |[10]    |RXTHIF    |Receive FIFO Threshold Flag (Read Only)
N     * |        |          |When data word(s) in receive FIFO is greater than or equal to threshold value set in RXTH[2:0] the RXTHIF bit becomes to 1.
N     * |        |          |It remains set until receive FIFO level is less than RXTH[2:0].
N     * |        |          |It is cleared by reading I2S_RX until threshold satisfied.
N     * |        |          |0 = Data word(s) in FIFO is less than threshold level
N     * |        |          |1 = Data word(s) in FIFO is greater than or equal to threshold level
N     * |[11]    |RXFULL    |Receive FIFO full (Read Only)
N     * |        |          |This bit is set when receive FIFO is full.
N     * |        |          |0 = Not full.
N     * |        |          |1 = Full.
N     * |[12]    |RXEMPTY   |Receive FIFO empty (Read Only)
N     * |        |          |This is set when receive FIFO is empty.
N     * |        |          |0 = Not empty
N     * |        |          |1 = Empty
N     * |[16]    |TXUDIF    |Transmit FIFO underflow flag (Write '1' to clear)
N     * |        |          |This flag is set if I2S controller requests data when transmit FIFO is empty.
N     * |        |          |0 = No underflow
N     * |        |          |1 = Underflow
N     * |[17]    |TXOVIF    |Transmit FIFO Overflow Flag (Write '1' to clear)
N     * |        |          |This flag is set if data is written to transmit FIFO when it is full.
N     * |        |          |0 = No overflow
N     * |        |          |1 = Overflow
N     * |[18]    |TXTHIF    |Transmit FIFO Threshold Flag (Read Only)
N     * |        |          |When data word(s) in transmit FIFO is less than or equal to the threshold value set in TXTH[2:0] the TXTHIF bit becomes to 1.
N     * |        |          |It remains set until transmit FIFO level is greater than TXTH[2:0].
N     * |        |          |Cleared by writing to I2S_TX register until threshold exceeded.
N     * |        |          |0 = Data word(s) in FIFO is greater than threshold level
N     * |        |          |1 = Data word(s) in FIFO is less than or equal to threshold level
N     * |[19]    |TXFULL    |Transmit FIFO Full (Read Only)
N     * |        |          |This bit is set when transmit FIFO is full.
N     * |        |          |0 = Not full.
N     * |        |          |1 = Full.
N     * |[20]    |TXEMPTY   |Transmit FIFO Empty (Read Only)
N     * |        |          |This is set when transmit FIFO is empty.
N     * |        |          |0 = Not empty
N     * |        |          |1 = Empty
N     * |[21]    |TXBUSY    |Transmit Busy (Read Only)
N     * |        |          |This bit is cleared when all data in transmit FIFO and Tx shift register is shifted out.
N     * |        |          |It is set when first data is loaded to Tx shift register.
N     * |        |          |0 = Transmit shift register is empty
N     * |        |          |1 = Transmit shift register is busy
N     * |[22]    |RZCIF     |Right channel zero cross flag (write '1' to clear, or clear RZCEN)
N     * |        |          |0 = No zero cross
N     * |        |          |1 = Right channel zero cross is detected
N     * |[23]    |LZCIF     |Left channel zero cross flag (write '1' to clear, or clear LZCEN)
N     * |        |          |0 = No zero cross detected.
N     * |        |          |1 = Left channel zero cross is detected
N     * |[24:27] |RXCNT     |Receive FIFO level (Read Only)
N     * |        |          |RXCNT = number of words in receive FIFO.
N     * |[28:31] |TXCNT     |Transmit FIFO level (Read Only)
N     * |        |          |TXCNT = number of words in transmit FIFO.
N */
N    __I  uint32_t STATUS;                
X    volatile const  uint32_t STATUS;                
N
N    /**
N     * TX
N     * ===================================================================================================
N     * Offset: 0x10  I2S Transmit FIFO Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |TX        |Transmit FIFO Register (Write Only)
N     * |        |          |A write to this register pushes data onto the transmit FIFO.
N     * |        |          |The transmit FIFO is eight words deep.
N     * |        |          |The number of words currently in the FIFO can be determined by reading I2S_STATUS.TXCNT.
N */
N    __O  uint32_t TX;                    
X    volatile  uint32_t TX;                    
N
N    /**
N     * RX
N     * ===================================================================================================
N     * Offset: 0x14  I2S Receive FIFO Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |RX        |Receive FIFO Register (Read Only)
N     * |        |          |A read of this register will pop data from the receive FIFO.
N     * |        |          |The receive FIFO is eight words deep.
N     * |        |          |The number of words currently in the FIFO can be determined by reading I2S_STATUS.RXCNT.
N */
N    __I  uint32_t RX;                    
X    volatile const  uint32_t RX;                    
N
N} I2S_T;
N
N/**
N    @addtogroup I2S_CONST I2S Bit Field Definition
N    Constant Definitions for I2S Controller
N@{ */
N
N#define I2S_CTL_I2SEN_Pos                (0)                                               /*!< I2S CTL: I2SEN Position                */
N#define I2S_CTL_I2SEN_Msk                (0x1ul << I2S_CTL_I2SEN_Pos)                      /*!< I2S CTL: I2SEN Mask                    */
N
N#define I2S_CTL_TXEN_Pos                 (1)                                               /*!< I2S CTL: TXEN Position                 */
N#define I2S_CTL_TXEN_Msk                 (0x1ul << I2S_CTL_TXEN_Pos)                       /*!< I2S CTL: TXEN Mask                     */
N
N#define I2S_CTL_RXEN_Pos                 (2)                                               /*!< I2S CTL: RXEN Position                 */
N#define I2S_CTL_RXEN_Msk                 (0x1ul << I2S_CTL_RXEN_Pos)                       /*!< I2S CTL: RXEN Mask                     */
N
N#define I2S_CTL_MUTE_Pos                 (3)                                               /*!< I2S CTL: MUTE Position                 */
N#define I2S_CTL_MUTE_Msk                 (0x1ul << I2S_CTL_MUTE_Pos)                       /*!< I2S CTL: MUTE Mask                     */
N
N#define I2S_CTL_WDWIDTH_Pos              (4)                                               /*!< I2S CTL: WDWIDTH Position              */
N#define I2S_CTL_WDWIDTH_Msk              (0x3ul << I2S_CTL_WDWIDTH_Pos)                    /*!< I2S CTL: WDWIDTH Mask                  */
N
N#define I2S_CTL_MONO_Pos                 (6)                                               /*!< I2S CTL: MONO Position                 */
N#define I2S_CTL_MONO_Msk                 (0x1ul << I2S_CTL_MONO_Pos)                       /*!< I2S CTL: MONO Mask                     */
N
N#define I2S_CTL_FORMAT_Pos               (7)                                               /*!< I2S CTL: FORMAT Position               */
N#define I2S_CTL_FORMAT_Msk               (0x1ul << I2S_CTL_FORMAT_Pos)                     /*!< I2S CTL: FORMAT Mask                   */
N
N#define I2S_CTL_SLAVE_Pos                (8)                                               /*!< I2S CTL: SLAVE Position                */
N#define I2S_CTL_SLAVE_Msk                (0x1ul << I2S_CTL_SLAVE_Pos)                      /*!< I2S CTL: SLAVE Mask                    */
N
N#define I2S_CTL_TXTH_Pos                 (9)                                               /*!< I2S CTL: TXTH Position                 */
N#define I2S_CTL_TXTH_Msk                 (0x7ul << I2S_CTL_TXTH_Pos)                       /*!< I2S CTL: TXTH Mask                     */
N
N#define I2S_CTL_RXTH_Pos                 (12)                                              /*!< I2S CTL: RXTH Position                 */
N#define I2S_CTL_RXTH_Msk                 (0x7ul << I2S_CTL_RXTH_Pos)                       /*!< I2S CTL: RXTH Mask                     */
N
N#define I2S_CTL_MCLKEN_Pos               (15)                                              /*!< I2S CTL: MCLKEN Position               */
N#define I2S_CTL_MCLKEN_Msk               (0x1ul << I2S_CTL_MCLKEN_Pos)                     /*!< I2S CTL: MCLKEN Mask                   */
N
N#define I2S_CTL_RZCEN_Pos                (16)                                              /*!< I2S CTL: RZCEN Position                */
N#define I2S_CTL_RZCEN_Msk                (0x1ul << I2S_CTL_RZCEN_Pos)                      /*!< I2S CTL: RZCEN Mask                    */
N
N#define I2S_CTL_LZCEN_Pos                (17)                                              /*!< I2S CTL: LZCEN Position                */
N#define I2S_CTL_LZCEN_Msk                (0x1ul << I2S_CTL_LZCEN_Pos)                      /*!< I2S CTL: LZCEN Mask                    */
N
N#define I2S_CTL_TXCLR_Pos                (18)                                              /*!< I2S CTL: TXCLR Position                */
N#define I2S_CTL_TXCLR_Msk                (0x1ul << I2S_CTL_TXCLR_Pos)                      /*!< I2S CTL: TXCLR Mask                    */
N
N#define I2S_CTL_RXCLR_Pos                (19)                                              /*!< I2S CTL: RXCLR Position                */
N#define I2S_CTL_RXCLR_Msk                (0x1ul << I2S_CTL_RXCLR_Pos)                      /*!< I2S CTL: RXCLR Mask                    */
N
N#define I2S_CTL_TXPDMAEN_Pos             (20)                                              /*!< I2S CTL: TXPDMAEN Position             */
N#define I2S_CTL_TXPDMAEN_Msk             (0x1ul << I2S_CTL_TXPDMAEN_Pos)                   /*!< I2S CTL: TXPDMAEN Mask                 */
N
N#define I2S_CTL_RXPDMAEN_Pos             (21)                                              /*!< I2S CTL: RXPDMAEN Position             */
N#define I2S_CTL_RXPDMAEN_Msk             (0x1ul << I2S_CTL_RXPDMAEN_Pos)                   /*!< I2S CTL: RXPDMAEN Mask                 */
N
N#define I2S_CLKDIV_MCLKDIV_Pos           (0)                                               /*!< I2S CLKDIV: MCLKDIV Position           */
N#define I2S_CLKDIV_MCLKDIV_Msk           (0x7ul << I2S_CLKDIV_MCLKDIV_Pos)                 /*!< I2S CLKDIV: MCLKDIV Mask               */
N
N#define I2S_CLKDIV_BCLKDIV_Pos           (8)                                               /*!< I2S CLKDIV: BCLKDIV Position           */
N#define I2S_CLKDIV_BCLKDIV_Msk           (0xfful << I2S_CLKDIV_BCLKDIV_Pos)                /*!< I2S CLKDIV: BCLKDIV Mask               */
N
N#define I2S_IEN_RXUDIEN_Pos              (0)                                               /*!< I2S IEN: RXUDIEN Position              */
N#define I2S_IEN_RXUDIEN_Msk              (0x1ul << I2S_IEN_RXUDIEN_Pos)                    /*!< I2S IEN: RXUDIEN Mask                  */
N
N#define I2S_IEN_RXOVIEN_Pos              (1)                                               /*!< I2S IEN: RXOVIEN Position              */
N#define I2S_IEN_RXOVIEN_Msk              (0x1ul << I2S_IEN_RXOVIEN_Pos)                    /*!< I2S IEN: RXOVIEN Mask                  */
N
N#define I2S_IEN_RXTHIEN_Pos              (2)                                               /*!< I2S IEN: RXTHIEN Position              */
N#define I2S_IEN_RXTHIEN_Msk              (0x1ul << I2S_IEN_RXTHIEN_Pos)                    /*!< I2S IEN: RXTHIEN Mask                  */
N
N#define I2S_IEN_TXUDIEN_Pos              (8)                                               /*!< I2S IEN: TXUDIEN Position              */
N#define I2S_IEN_TXUDIEN_Msk              (0x1ul << I2S_IEN_TXUDIEN_Pos)                    /*!< I2S IEN: TXUDIEN Mask                  */
N
N#define I2S_IEN_TXOVIEN_Pos              (9)                                               /*!< I2S IEN: TXOVIEN Position              */
N#define I2S_IEN_TXOVIEN_Msk              (0x1ul << I2S_IEN_TXOVIEN_Pos)                    /*!< I2S IEN: TXOVIEN Mask                  */
N
N#define I2S_IEN_TXTHIEN_Pos              (10)                                              /*!< I2S IEN: TXTHIEN Position              */
N#define I2S_IEN_TXTHIEN_Msk              (0x1ul << I2S_IEN_TXTHIEN_Pos)                    /*!< I2S IEN: TXTHIEN Mask                  */
N
N#define I2S_IEN_RZCIEN_Pos               (11)                                              /*!< I2S IEN: RZCIEN Position               */
N#define I2S_IEN_RZCIEN_Msk               (0x1ul << I2S_IEN_RZCIEN_Pos)                     /*!< I2S IEN: RZCIEN Mask                   */
N
N#define I2S_IEN_LZCIEN_Pos               (12)                                              /*!< I2S IEN: LZCIEN Position               */
N#define I2S_IEN_LZCIEN_Msk               (0x1ul << I2S_IEN_LZCIEN_Pos)                     /*!< I2S IEN: LZCIEN Mask                   */
N
N#define I2S_STATUS_I2SIF_Pos             (0)                                               /*!< I2S STATUS: I2SIF Position             */
N#define I2S_STATUS_I2SIF_Msk             (0x1ul << I2S_STATUS_I2SIF_Pos)                   /*!< I2S STATUS: I2SIF Mask                 */
N
N#define I2S_STATUS_RXIF_Pos              (1)                                               /*!< I2S STATUS: RXIF Position              */
N#define I2S_STATUS_RXIF_Msk              (0x1ul << I2S_STATUS_RXIF_Pos)                    /*!< I2S STATUS: RXIF Mask                  */
N
N#define I2S_STATUS_TXIF_Pos              (2)                                               /*!< I2S STATUS: TXIF Position              */
N#define I2S_STATUS_TXIF_Msk              (0x1ul << I2S_STATUS_TXIF_Pos)                    /*!< I2S STATUS: TXIF Mask                  */
N
N#define I2S_STATUS_RIGHT_Pos             (3)                                               /*!< I2S STATUS: RIGHT Position             */
N#define I2S_STATUS_RIGHT_Msk             (0x1ul << I2S_STATUS_RIGHT_Pos)                   /*!< I2S STATUS: RIGHT Mask                 */
N
N#define I2S_STATUS_RXUDIF_Pos            (8)                                               /*!< I2S STATUS: RXUDIF Position            */
N#define I2S_STATUS_RXUDIF_Msk            (0x1ul << I2S_STATUS_RXUDIF_Pos)                  /*!< I2S STATUS: RXUDIF Mask                */
N
N#define I2S_STATUS_RXOVIF_Pos            (9)                                               /*!< I2S STATUS: RXOVIF Position            */
N#define I2S_STATUS_RXOVIF_Msk            (0x1ul << I2S_STATUS_RXOVIF_Pos)                  /*!< I2S STATUS: RXOVIF Mask                */
N
N#define I2S_STATUS_RXTHIF_Pos            (10)                                              /*!< I2S STATUS: RXTHIF Position            */
N#define I2S_STATUS_RXTHIF_Msk            (0x1ul << I2S_STATUS_RXTHIF_Pos)                  /*!< I2S STATUS: RXTHIF Mask                */
N
N#define I2S_STATUS_RXFULL_Pos            (11)                                              /*!< I2S STATUS: RXFULL Position            */
N#define I2S_STATUS_RXFULL_Msk            (0x1ul << I2S_STATUS_RXFULL_Pos)                  /*!< I2S STATUS: RXFULL Mask                */
N
N#define I2S_STATUS_RXEMPTY_Pos           (12)                                              /*!< I2S STATUS: RXEMPTY Position           */
N#define I2S_STATUS_RXEMPTY_Msk           (0x1ul << I2S_STATUS_RXEMPTY_Pos)                 /*!< I2S STATUS: RXEMPTY Mask               */
N
N#define I2S_STATUS_TXUDIF_Pos            (16)                                              /*!< I2S STATUS: TXUDIF Position            */
N#define I2S_STATUS_TXUDIF_Msk            (0x1ul << I2S_STATUS_TXUDIF_Pos)                  /*!< I2S STATUS: TXUDIF Mask                */
N
N#define I2S_STATUS_TXOVIF_Pos            (17)                                              /*!< I2S STATUS: TXOVIF Position            */
N#define I2S_STATUS_TXOVIF_Msk            (0x1ul << I2S_STATUS_TXOVIF_Pos)                  /*!< I2S STATUS: TXOVIF Mask                */
N
N#define I2S_STATUS_TXTHIF_Pos            (18)                                              /*!< I2S STATUS: TXTHIF Position            */
N#define I2S_STATUS_TXTHIF_Msk            (0x1ul << I2S_STATUS_TXTHIF_Pos)                  /*!< I2S STATUS: TXTHIF Mask                */
N
N#define I2S_STATUS_TXFULL_Pos            (19)                                              /*!< I2S STATUS: TXFULL Position            */
N#define I2S_STATUS_TXFULL_Msk            (0x1ul << I2S_STATUS_TXFULL_Pos)                  /*!< I2S STATUS: TXFULL Mask                */
N
N#define I2S_STATUS_TXEMPTY_Pos           (20)                                              /*!< I2S STATUS: TXEMPTY Position           */
N#define I2S_STATUS_TXEMPTY_Msk           (0x1ul << I2S_STATUS_TXEMPTY_Pos)                 /*!< I2S STATUS: TXEMPTY Mask               */
N
N#define I2S_STATUS_TXBUSY_Pos            (21)                                              /*!< I2S STATUS: TXBUSY Position            */
N#define I2S_STATUS_TXBUSY_Msk            (0x1ul << I2S_STATUS_TXBUSY_Pos)                  /*!< I2S STATUS: TXBUSY Mask                */
N
N#define I2S_STATUS_RZCIF_Pos             (22)                                              /*!< I2S STATUS: RZCIF Position             */
N#define I2S_STATUS_RZCIF_Msk             (0x1ul << I2S_STATUS_RZCIF_Pos)                   /*!< I2S STATUS: RZCIF Mask                 */
N
N#define I2S_STATUS_LZCIF_Pos             (23)                                              /*!< I2S STATUS: LZCIF Position             */
N#define I2S_STATUS_LZCIF_Msk             (0x1ul << I2S_STATUS_LZCIF_Pos)                   /*!< I2S STATUS: LZCIF Mask                 */
N
N#define I2S_STATUS_RXCNT_Pos             (24)                                              /*!< I2S STATUS: RXCNT Position             */
N#define I2S_STATUS_RXCNT_Msk             (0xful << I2S_STATUS_RXCNT_Pos)                   /*!< I2S STATUS: RXCNT Mask                 */
N
N#define I2S_STATUS_TXCNT_Pos             (28)                                              /*!< I2S STATUS: TXCNT Position             */
N#define I2S_STATUS_TXCNT_Msk             (0xful << I2S_STATUS_TXCNT_Pos)                   /*!< I2S STATUS: TXCNT Mask                 */
N
N#define I2S_TX_TX_Pos                    (0)                                               /*!< I2S TX: TX Position                    */
N#define I2S_TX_TX_Msk                    (0xfffffffful << I2S_TX_TX_Pos)                   /*!< I2S TX: TX Mask                        */
N
N#define I2S_RX_RX_Pos                    (0)                                               /*!< I2S RX: RX Position                    */
N#define I2S_RX_RX_Msk                    (0xfffffffful << I2S_RX_RX_Pos)                   /*!< I2S RX: RX Mask                        */
N
N/**@}*/ /* I2S_CONST */
N/**@}*/ /* end of I2S register group */
N
N
N/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
N    Memory Mapped Structure for PDMA Controller
N@{ */
N 
Ntypedef struct
N{
N    /**
N     * DSCT_CTL
N     * ===================================================================================================
N     * Offset: 0x00  PDMA Control Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN      |PDMA Channel Enable
N     * |        |          |Setting this bit to 1 enables PDMA's operation.
N     * |        |          |If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
N     * |        |          |Note: SWRST will clear this bit.
N     * |[1]     |SWRST     |Software Engine Reset
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the internal state machine and pointers.
N     * |        |          |The contents of the control register will not be cleared.
N     * |        |          |This bit will auto clear after a few clock cycles.
N     * |[2:3]   |MODESEL   |PDMA Mode Select
N     * |        |          |This parameter selects to transfer direction of the PDMA channel. Possible values are:
N     * |        |          |00 = Memory to Memory mode (SRAM-to-SRAM).
N     * |        |          |01 = IP to Memory mode (APB-to-SRAM).
N     * |        |          |10 = Memory to IP mode (SRAM-to-APB).
N     * |[4:5]   |SASEL     |Source Address Select
N     * |        |          |This parameter determines the behavior of the current source address register with each PDMA transfer.
N     * |        |          |It can either be fixed, incremented or wrapped.
N     * |        |          |00 = Transfer Source address is incremented.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Transfer Source address is fixed
N     * |        |          |11 = Transfer Source address is wrapped.
N     * |        |          |When PDMA_CURBCCHn (Current Byte Count) equals zero, the PDMA_CURSACHn (Current Source Address) and PDMA_CURBCCHn registers will be reloaded from the PDMA_DSCTn_ENDSA (Source Address) and PDMA_TXBCCHn (Byte Count) registers automatically and PDMA will start another transfer.
N     * |        |          |Cycle continues until software sets PDMACKEN = 0.
N     * |        |          |When PDMACKEN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address.
N     * |[6:7]   |DASEL     |Destination Address Select
N     * |        |          |This parameter determines the behavior of the current destination address register with each PDMA transfer.
N     * |        |          |It can either be fixed, incremented or wrapped.
N     * |        |          |00 = Transfer Destination Address is incremented.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input).
N     * |        |          |11 = Transfer Destination Address is wrapped.
N     * |        |          |When PDMA_CURBCCHn (Current Byte Count) equals zero, the PDMA_CURDACHn (Current Destination Address) and PDMA_CURBCCHn registers will be reloaded from the PDMA_DSCTn_ENDDA (Destination Address) and PDMA_TXBCCHn (Byte Count) registers automatically and PDMA will start another transfer.
N     * |        |          |Cycle continues until software sets PDMACKEN=0.
N     * |        |          |When PDMACKEN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address.
N     * |[12:15] |WAINTSEL  |Wrap Interrupt Select
N     * |        |          |x1xx: If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when half each PDMA transfer is complete.
N     * |        |          |For example if BYTECNT = 32 then an interrupt could be generated when 16 bytes were sent.
N     * |        |          |xxx1: If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when each PDMA transfer is wrapped.
N     * |        |          |For example if BYTECNT = 32 then an interrupt could be generated when 32 bytes were sent and PDMA wraps around.
N     * |        |          |x1x1: Both half and w interrupts generated.
N     * |[19:20] |TWIDTH    |Peripheral Transfer Width Select
N     * |        |          |This parameter determines the data width to be transferred each PDMA transfer operation.
N     * |        |          |00 = One word (32 bits) is transferred for every PDMA operation.
N     * |        |          |01 = One byte (8 bits) is transferred for every PDMA operation.
N     * |        |          |10 = One half-word (16 bits) is transferred for every PDMA operation.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: This field is meaningful only when MODESEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).
N     * |[23]    |TXEN      |Trigger Enable - Start a PDMA operation
N     * |        |          |0 = Write: no effect. Read: Idle/Finished.
N     * |        |          |1 = Enable PDMA data read or write transfer.
N     * |        |          |Note: When PDMA transfer completed, this bit will be cleared automatically.
N     * |        |          |If a bus error occurs, all PDMA transfer will be stopped.
N     * |        |          |Software must reset PDMA channel, and then trigger again.
N */
N    __IO uint32_t DSCT_CTL;             
X    volatile uint32_t DSCT_CTL;             
N
N    /**
N     * DSCT_ENDSA
N     * ===================================================================================================
N     * Offset: 0x04  PDMA Transfer Source Address Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |ENDSA     |PDMA Transfer Source Address Register
N     * |        |          |This register holds the initial Source Address of PDMA transfer.
N     * |        |          |Note: The source address must be word aligned.
N */
N    __IO uint32_t DSCT_ENDSA;           
X    volatile uint32_t DSCT_ENDSA;           
N
N    /**
N     * DSCT_ENDDA
N     * ===================================================================================================
N     * Offset: 0x08  PDMA Transfer Destination Address Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |ENDDA     |PDMA Transfer Destination Address Register
N     * |        |          |This register holds the initial Destination Address of PDMA transfer.
N     * |        |          |Note: The destination address must be word aligned.
N */
N    __IO uint32_t DSCT_ENDDA;           
X    volatile uint32_t DSCT_ENDDA;           
N
N    /**
N     * TXBCCH
N     * ===================================================================================================
N     * Offset: 0x0C  PDMA Transfer Byte Count Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |BYTECNT   |PDMA Transfer Byte Count Register
N     * |        |          |This register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.
N     * |        |          |Note: When in memory-to-memory (PDMA_DSCTn_CTL.MODESEL = 00b) mode, the transfer byte count must be word aligned, that is multiples of 4bytes.
N */
N    __IO uint32_t TXBCCH;               
X    volatile uint32_t TXBCCH;               
N
N    /**
N     * INLBPCH
N     * ===================================================================================================
N     * Offset: 0x10  PDMA Internal Buffer Pointer Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |BUFPTR    |PDMA Internal Buffer Pointer Register (Read Only)
N     * |        |          |A PDMA transaction consists of two stages, a read from the source address and a write to the destination address.
N     * |        |          |Internally this data is buffered in a 32bit register.
N     * |        |          |If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.
N */
N    __I  uint32_t INLBPCH0;              
X    volatile const  uint32_t INLBPCH0;              
N
N    /**
N     * CURSACH
N     * ===================================================================================================
N     * Offset: 0x14  PDMA Current Source Address Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |CURSA     |PDMA Current Source Address Register (Read Only)
N     * |        |          |This register returns the source address from which the PDMA transfer is occurring.
N     * |        |          |This register is loaded from PDMA_DSCTn_ENDSA when PDMA is triggered or when a wraparound occurs.
N */
N    __I  uint32_t CURSACH;              
X    volatile const  uint32_t CURSACH;              
N
N    /**
N     * CURDACH
N     * ===================================================================================================
N     * Offset: 0x18  PDMA Current Destination Address Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |CURDA     |PDMA Current Destination Address Register (Read Only)
N     * |        |          |This register returns the destination address to which the PDMA transfer is occurring.
N     * |        |          |This register is loaded from PDMA_DSCTn_ENDDA when PDMA is triggered or when a wraparound occurs.
N */
N    __I  uint32_t CURDACH;              
X    volatile const  uint32_t CURDACH;              
N
N    /**
N     * CURBCCH
N     * ===================================================================================================
N     * Offset: 0x1C  PDMA Current Byte Count Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |CURBC     |PDMA Current Byte Count Register (Read Only)
N     * |        |          |This field indicates the current remaining byte count of PDMA transfer.
N     * |        |          |This register is initialized with PDMA_TXBCCHn register when PDMA is triggered or when a wraparound occurs.
N */
N    __I  uint32_t CURBCCH;              
X    volatile const  uint32_t CURBCCH;              
N
N    /**
N     * INTENCH0
N     * ===================================================================================================
N     * Offset: 0x20  PDMA Interrupt Enable Control Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXABTIEN  |PDMA Read/Write Target Abort Interrupt Enable
N     * |        |          |If enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error.
N     * |        |          |If a transfer is aborted, PDMA channel must be reset to resume DMA operation.
N     * |        |          |0 = Disable PDMA transfer target abort interrupt generation.
N     * |        |          |1 = Enable PDMA transfer target abort interrupt generation.
N     * |[1]     |TXOKIEN   |PDMA Transfer Done Interrupt Enable
N     * |        |          |If enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.
N     * |        |          |0 = Disable PDMA transfer done interrupt generation.
N     * |        |          |1 = Enable PDMA transfer done interrupt generation.
N     * |[2]     |WAINTEN   |Wraparound Interrupt Enable
N     * |        |          |If enabled, and channel source or destination address is in wraparound mode, the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of PDMA_DSCTn_CTL.WAINTSEL.
N     * |        |          |This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress.
N     * |        |          |This allows the efficient implementation of circular buffers for DMA.
N     * |        |          |0 = Disable Wraparound PDMA interrupt generation.
N     * |        |          |1 = Enable Wraparound interrupt generation.
N */
N    __IO uint32_t INTENCH;              
X    volatile uint32_t INTENCH;              
N
N    /**
N     * CHIF
N     * ===================================================================================================
N     * Offset: 0x24  PDMA Interrupt Status Register of Channel 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXABTIF   |PDMA Read/Write Target Abort Interrupt Flag
N     * |        |          |This flag indicates a Target Abort interrupt condition has occurred.
N     * |        |          |This condition can happen if attempt is made to read/write from invalid or non-existent memory space.
N     * |        |          |It occurs when PDMA controller receives a bus error from AHB master.
N     * |        |          |Upon occurrence PDMA will stop transfer and go to idle state.
N     * |        |          |To resume, software must reset PDMA channel and initiate transfer again.
N     * |        |          |0 = No bus ERROR response received.
N     * |        |          |1 = Bus ERROR response received.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[1]     |TXOKIF    |Block Transfer Done Interrupt Flag
N     * |        |          |This bit indicates that PDMA block transfer complete interrupt has been generated.
N     * |        |          |It is cleared by writing 1 to the bit.
N     * |        |          |0 = Transfer ongoing or Idle.
N     * |        |          |1 = Transfer Complete.
N     * |[8:11]  |WAIF      |Wrap Around Transfer Byte Count Interrupt Flag
N     * |        |          |These flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met.
N     * |        |          |They are cleared by writing one to the bits.
N     * |        |          |0001 = Current transfer finished flag (CURBC aaaaaa 0).
N     * |        |          |0100 = Current transfer half complete flag (CURBC aaaaaa BYTECNT/2).
N     * |[31]    |INTSTS    |Interrupt Pin Status (Read Only)
N     * |        |          |This bit is the Interrupt pin status of PDMA channel.
N */
N    __IO uint32_t CHIF;                 
X    volatile uint32_t CHIF;                 
N } PDMA_T;
N
Ntypedef struct
N{
N    /**
N     * GLOCTL
N     * ===================================================================================================
N     * Offset: 0x000  PDMA Global Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SWRST     |PDMA Software Reset
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the internal state machine and pointers.
N     * |        |          |The contents of control register will not be cleared.
N     * |        |          |This bit will auto clear after several clock cycles.
N     * |        |          |Note: This bit can reset all channels (global reset).
N     * |[8:11]  |CHCKEN    |PDMA Controller Channel Clock Enable Control
N     * |        |          |To enable clock for channel n CHCKEN[n] must be set.
N     * |        |          |CHCKEN[n] = 1: Enable Channel n clock
N     * |        |          |CHCKEN[n] = 0: Disable Channel n clock
N */
N    __IO uint32_t GLOCTL;                
X    volatile uint32_t GLOCTL;                
N
N    /**
N     * SVCSEL
N     * ===================================================================================================
N     * Offset: 0x004  PDMA Service Selection Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |SPIRXSEL  |PDMA SPI0 Receive Selection
N     * |        |          |This field defines which PDMA channel is connected to SPI0 peripheral receive (PDMA source) request.
N     * |[4:7]   |SPITXSEL  |PDMA SPI0 Transmit Selection
N     * |        |          |This field defines which PDMA channel is connected to SPI0 peripheral transmit (PDMA destination) request.
N     * |[8:11]  |ADCRXSEL  |PDMA ADC Receive Selection
N     * |        |          |This field defines which PDMA channel is connected to ADC peripheral receive (PDMA source) request.
N     * |[12:15] |DPWMTXSEL |PDMA DPWM Transmit Selection
N     * |        |          |This field defines which PDMA channel is connected to DPWM peripheral transmit (PDMA destination) request.
N     * |[16:19] |UARTRXSEL |PDMA UART0 Receive Selection
N     * |        |          |This field defines which PDMA channel is connected to UART0 peripheral receive (PDMA source) request.
N     * |[20:23] |UARTXSEL  |PDMA UART0 Transmit Selection
N     * |        |          |This field defines which PDMA channel is connected to UART0 peripheral transmit (PDMA destination) request
N     * |[24:27] |I2SRXSEL  |PDMA I2S Receive Selection
N     * |        |          |This field defines which PDMA channel is connected to I2S peripheral receive (PDMA source) request.
N     * |[28:31] |I2STXSEL  |PDMA I2S Transmit Selection
N     * |        |          |This field defines which PDMA channel is connected to I2S peripheral transmit (PDMA destination) request
N */
N    __IO uint32_t SVCSEL;                
X    volatile uint32_t SVCSEL;                
N         uint32_t RESERVE4[1];
N
N
N    /**
N     * GLOBALIF
N     * ===================================================================================================
N     * Offset: 0x00C  PDMA Global Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |GLOBALIF  |Interrupt Pin Status (Read Only)
N     * |        |          |GLOBALIF[n] is the interrupt status of PDMA channel n.
N */
N    __I  uint32_t GLOBALIF;              
X    volatile const  uint32_t GLOBALIF;              
N
N} PDMA_GCR_T;
N
N/**
N    @addtogroup PDMA_CONST PDMA Bit Field Definition
N    Constant Definitions for PDMA Controller
N@{ */
N
N#define PDMA_DSCT_CTL_CHEN_Pos          (0)                                               /*!< PDMA DSCT0_CTL: CHEN Position          */
N#define PDMA_DSCT_CTL_CHEN_Msk          (0x1ul << PDMA_DSCT_CTL_CHEN_Pos)                /*!< PDMA DSCT0_CTL: CHEN Mask              */
N
N#define PDMA_DSCT_CTL_SWRST_Pos         (1)                                               /*!< PDMA DSCT0_CTL: SWRST Position         */
N#define PDMA_DSCT_CTL_SWRST_Msk         (0x1ul << PDMA_DSCT_CTL_SWRST_Pos)               /*!< PDMA DSCT0_CTL: SWRST Mask             */
N
N#define PDMA_DSCT_CTL_MODESEL_Pos       (2)                                               /*!< PDMA DSCT0_CTL: MODESEL Position       */
N#define PDMA_DSCT_CTL_MODESEL_Msk       (0x3ul << PDMA_DSCT_CTL_MODESEL_Pos)             /*!< PDMA DSCT0_CTL: MODESEL Mask           */
N
N#define PDMA_DSCT_CTL_SASEL_Pos         (4)                                               /*!< PDMA DSCT0_CTL: SASEL Position         */
N#define PDMA_DSCT_CTL_SASEL_Msk         (0x3ul << PDMA_DSCT_CTL_SASEL_Pos)               /*!< PDMA DSCT0_CTL: SASEL Mask             */
N
N#define PDMA_DSCT_CTL_DASEL_Pos         (6)                                               /*!< PDMA DSCT0_CTL: DASEL Position         */
N#define PDMA_DSCT_CTL_DASEL_Msk         (0x3ul << PDMA_DSCT_CTL_DASEL_Pos)               /*!< PDMA DSCT0_CTL: DASEL Mask             */
N
N#define PDMA_DSCT_CTL_WAINTSEL_Pos      (12)                                              /*!< PDMA DSCT0_CTL: WAINTSEL Position      */
N#define PDMA_DSCT_CTL_WAINTSEL_Msk      (0xful << PDMA_DSCT_CTL_WAINTSEL_Pos)            /*!< PDMA DSCT0_CTL: WAINTSEL Mask          */
N
N#define PDMA_DSCT_CTL_TXWIDTH_Pos        (19)                                              /*!< PDMA DSCT0_CTL: TWIDTH Position        */
N#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< PDMA DSCT0_CTL: TWIDTH Mask            */
N
N#define PDMA_DSCT_CTL_TXEN_Pos          (23)                                              /*!< PDMA DSCT0_CTL: TXEN Position          */
N#define PDMA_DSCT_CTL_TXEN_Msk          (0x1ul << PDMA_DSCT_CTL_TXEN_Pos)                /*!< PDMA DSCT0_CTL: TXEN Mask              */
N
N#define PDMA_DSCT_ENDSA_ENDSA_Pos       (0)                                               /*!< PDMA DSCT0_ENDSA: ENDSA Position       */
N#define PDMA_DSCT_ENDSA_ENDSA_Msk       (0xfffffffful << PDMA_DSCT_ENDSA_ENDSA_Pos)      /*!< PDMA DSCT0_ENDSA: ENDSA Mask           */
N
N#define PDMA_DSCT_ENDDA_ENDDA_Pos       (0)                                               /*!< PDMA DSCT0_ENDDA: ENDDA Position       */
N#define PDMA_DSCT_ENDDA_ENDDA_Msk       (0xfffffffful << PDMA_DSCT_ENDDA_ENDDA_Pos)      /*!< PDMA DSCT0_ENDDA: ENDDA Mask           */
N
N#define PDMA_TXBCCH_BYTECNT_Pos         (0)                                               /*!< PDMA TXBCCH0: BYTECNT Position         */
N#define PDMA_TXBCCH_BYTECNT_Msk         (0xfffful << PDMA_TXBCCH_BYTECNT_Pos)            /*!< PDMA TXBCCH0: BYTECNT Mask             */
N
N#define PDMA_INLBPCH_BUFPTR_Pos         (0)                                               /*!< PDMA INLBPCH0: BUFPTR Position         */
N#define PDMA_INLBPCH_BUFPTR_Msk         (0xful << PDMA_INLBPCH_BUFPTR_Pos)               /*!< PDMA INLBPCH0: BUFPTR Mask             */
N
N#define PDMA_CURSACH_CURSA_Pos          (0)                                               /*!< PDMA CURSACH0: CURSA Position          */
N#define PDMA_CURSACH_CURSA_Msk          (0xfffffffful << PDMA_CURSACH_CURSA_Pos)         /*!< PDMA CURSACH0: CURSA Mask              */
N
N#define PDMA_CURDACH_CURDA_Pos          (0)                                               /*!< PDMA CURDACH0: CURDA Position          */
N#define PDMA_CURDACH_CURDA_Msk          (0xfffffffful << PDMA_CURDACH_CURDA_Pos)         /*!< PDMA CURDACH0: CURDA Mask              */
N
N#define PDMA_CURBCCH_CURBC_Pos          (0)                                               /*!< PDMA CURBCCH0: CURBC Position          */
N#define PDMA_CURBCCH_CURBC_Msk          (0xfffful << PDMA_CURBCCH_CURBC_Pos)             /*!< PDMA CURBCCH0: CURBC Mask              */
N
N#define PDMA_INTENCH_TXABTIEN_Pos       (0)                                               /*!< PDMA INTENCH0: TXABTIEN Position       */
N#define PDMA_INTENCH_TXABTIEN_Msk       (0x1ul << PDMA_INTENCH_TXABTIEN_Pos)             /*!< PDMA INTENCH0: TXABTIEN Mask           */
N
N#define PDMA_INTENCH_TXOKIEN_Pos        (1)                                               /*!< PDMA INTENCH0: TXOKIEN Position        */
N#define PDMA_INTENCH_TXOKIEN_Msk        (0x1ul << PDMA_INTENCH_TXOKIEN_Pos)              /*!< PDMA INTENCH0: TXOKIEN Mask            */
N
N#define PDMA_INTENCH_WAINTEN_Pos        (2)                                               /*!< PDMA INTENCH0: WAINTEN Position        */
N#define PDMA_INTENCH_WAINTEN_Msk        (0x1ul << PDMA_INTENCH_WAINTEN_Pos)              /*!< PDMA INTENCH0: WAINTEN Mask            */
N
N#define PDMA_CHIF_TXABTIF_Pos           (0)                                               /*!< PDMA CH0IF: TXABTIF Position           */
N#define PDMA_CHIF_TXABTIF_Msk           (0x1ul << PDMA_CHIF_TXABTIF_Pos)                 /*!< PDMA CH0IF: TXABTIF Mask               */
N
N#define PDMA_CHIF_TXOKIF_Pos            (1)                                               /*!< PDMA CH0IF: TXOKIF Position            */
N#define PDMA_CHIF_TXOKIF_Msk            (0x1ul << PDMA_CHIF_TXOKIF_Pos)                  /*!< PDMA CH0IF: TXOKIF Mask                */
N
N#define PDMA_CHIF_WAIF_Pos              (8)                                               /*!< PDMA CH0IF: WAIF Position              */
N#define PDMA_CHIF_WAIF_Msk              (0xful << PDMA_CHIF_WAIF_Pos)                    /*!< PDMA CH0IF: WAIF Mask                  */
N
N#define PDMA_CHIF_INTSTS_Pos            (31)                                              /*!< PDMA CH0IF: INTSTS Position            */
N#define PDMA_CHIF_INTSTS_Msk            (0x1ul << PDMA_CHIF_INTSTS_Pos)                  /*!< PDMA CH0IF: INTSTS Mask                */
N
N#define PDMA_GLOCTL_SWRST_Pos            (0)                                               /*!< PDMA GLOCTL: SWRST Position            */
N#define PDMA_GLOCTL_SWRST_Msk            (0x1ul << PDMA_GLOCTL_SWRST_Pos)                  /*!< PDMA GLOCTL: SWRST Mask                */
N
N#define PDMA_GLOCTL_CHCKEN_Pos           (8)                                               /*!< PDMA GLOCTL: CHCKEN Position           */
N#define PDMA_GLOCTL_CHCKEN_Msk           (0xful << PDMA_GLOCTL_CHCKEN_Pos)                 /*!< PDMA GLOCTL: CHCKEN Mask               */
N
N#define PDMA_SVCSEL_SPIRXSEL_Pos         (0)                                               /*!< PDMA SVCSEL: SPIRXSEL Position         */
N#define PDMA_SVCSEL_SPIRXSEL_Msk         (0xful << PDMA_SVCSEL_SPIRXSEL_Pos)               /*!< PDMA SVCSEL: SPIRXSEL Mask             */
N
N#define PDMA_SVCSEL_SPITXSEL_Pos         (4)                                               /*!< PDMA SVCSEL: SPITXSEL Position         */
N#define PDMA_SVCSEL_SPITXSEL_Msk         (0xful << PDMA_SVCSEL_SPITXSEL_Pos)               /*!< PDMA SVCSEL: SPITXSEL Mask             */
N
N#define PDMA_SVCSEL_ADCRXSEL_Pos         (8)                                               /*!< PDMA SVCSEL: ADCRXSEL Position         */
N#define PDMA_SVCSEL_ADCRXSEL_Msk         (0xful << PDMA_SVCSEL_ADCRXSEL_Pos)               /*!< PDMA SVCSEL: ADCRXSEL Mask             */
N
N#define PDMA_SVCSEL_DPWMTXSEL_Pos        (12)                                              /*!< PDMA SVCSEL: DPWMTXSEL Position        */
N#define PDMA_SVCSEL_DPWMTXSEL_Msk        (0xful << PDMA_SVCSEL_DPWMTXSEL_Pos)              /*!< PDMA SVCSEL: DPWMTXSEL Mask            */
N
N#define PDMA_SVCSEL_UARTRXSEL_Pos        (16)                                              /*!< PDMA SVCSEL: UARTRXSEL Position        */
N#define PDMA_SVCSEL_UARTRXSEL_Msk        (0xful << PDMA_SVCSEL_UARTRXSEL_Pos)              /*!< PDMA SVCSEL: UARTRXSEL Mask            */
N
N#define PDMA_SVCSEL_UARTXSEL_Pos         (20)                                              /*!< PDMA SVCSEL: UARTXSEL Position         */
N#define PDMA_SVCSEL_UARTXSEL_Msk         (0xful << PDMA_SVCSEL_UARTXSEL_Pos)               /*!< PDMA SVCSEL: UARTXSEL Mask             */
N
N#define PDMA_SVCSEL_I2SRXSEL_Pos         (24)                                              /*!< PDMA SVCSEL: I2SRXSEL Position         */
N#define PDMA_SVCSEL_I2SRXSEL_Msk         (0xful << PDMA_SVCSEL_I2SRXSEL_Pos)               /*!< PDMA SVCSEL: I2SRXSEL Mask             */
N
N#define PDMA_SVCSEL_I2STXSEL_Pos         (28)                                              /*!< PDMA SVCSEL: I2STXSEL Position         */
N#define PDMA_SVCSEL_I2STXSEL_Msk         (0xful << PDMA_SVCSEL_I2STXSEL_Pos)               /*!< PDMA SVCSEL: I2STXSEL Mask             */
N
N#define PDMA_GLOBALIF_GLOBALIF_Pos       (0)                                               /*!< PDMA GLOBALIF: GLOBALIF Position       */
N#define PDMA_GLOBALIF_GLOBALIF_Msk       (0xful << PDMA_GLOBALIF_GLOBALIF_Pos)             /*!< PDMA GLOBALIF: GLOBALIF Mask           */
N
N/**@}*/ /* PDMA_CONST */
N/**@}*/ /* end of PDMA register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CLKPSC
N     * ===================================================================================================
N     * Offset: 0x00  PWM Prescaler Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |CLKPSC01  |Clock Pre-scaler For Pair Of PWM CH0 and CH1
N     * |        |          |Clock input is divided by (CLKPSC01 + 1).
N     * |        |          |If CLKPSC01 = 0, then the pre-scaler output clock will be stopped.
N     * |        |          |This implies PWM counter 0 and 1 will also be stopped.
N     * |[16:23] |DTCNT01   |Dead Zone Interval Register For Pair Of PWM CH0 and CH1
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length is that from clock selector 0.
N */
N    __IO uint32_t CLKPSC;                
X    volatile uint32_t CLKPSC;                
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x04  PWM Clock Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |CLKDIV0   |Timer 0 Clock Source Selection
N     * |        |          |(Table is as CLKDIV1)
N     * |[4:6]   |CLKDIV1   |Timer 1 Clock Source Selection
N     * |        |          |Value : Input clock divided by
N     * |        |          |0 : 2
N     * |        |          |1 : 4
N     * |        |          |2 : 8
N     * |        |          |3 : 16
N     * |        |          |4 : 1
N */
N    __IO uint32_t CLKDIV;                
X    volatile uint32_t CLKDIV;                
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x08  PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTEN0    |PWM-Timer 0 Enable/Disable Start Run
N     * |        |          |0 = Stop PWM-Timer 0 Running
N     * |        |          |1 = Enable PWM-Timer 0 Start/Run
N     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF
N     * |        |          |1 = Inverter ON
N     * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |Note: A rising transition of this bit will cause PWM_PERIOD0 and PWM_CMPDAT0 to be cleared.
N     * |[4]     |DTEN01    |Dead-Zone 0 Generator Enable/Disable
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM CH0 and CH1 become a complementary pair.
N     * |[8]     |CNTEN1    |PWM-Timer 1 Enable/Disable Start Run
N     * |        |          |0 = Stop PWM-Timer 1
N     * |        |          |1 = Enable PWM-Timer 1 Start/Run
N     * |[10]    |PINV1     |PWM-Timer 1 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF
N     * |        |          |1 = Inverter ON
N     * |[11]    |CNTMODE1  |PWM-Timer 1 Auto-reload/One-Shot Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |1 = Auto-load Mode
N     * |        |          |Note: A rising transition of this bit will cause PWM_PERIOD1 and PWM_CMPDAT1 to be cleared.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * PERIOD0
N     * ===================================================================================================
N     * Offset: 0x0C  PWM Counter Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |PERIOD    |PWM Counter/Timer Reload Value
N     * |        |          |PERIOD determines the PWM period.
N     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
N     * |        |          |Duty ratio = (CMP+1)/(PERIOD+1).
N     * |        |          |CMP > = PERIOD: PWM output is always high.
N     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
N     * |        |          |(Unit = one PWM clock cycle)
N     * |        |          |Note:
N     * |        |          |Any write to PERIOD will take effect in next PWM cycle.
N */
N    __IO uint32_t PERIOD0;               
X    volatile uint32_t PERIOD0;               
N
N    /**
N     * CMPDAT0
N     * ===================================================================================================
N     * Offset: 0x10  PWM Comparator Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |CMP       |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty cycle.
N     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
N     * |        |          |Duty Cycle = (CMP+1)/(PERIOD+1).
N     * |        |          |CMP > = PERIOD: PWM output is always high.
N     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
N     * |        |          |(Unit = one PWM clock cycle)
N     * |        |          |Note: Any write to CMP will take effect in next PWM cycle.
N */
N    __IO uint32_t CMPDAT0;               
X    volatile uint32_t CMPDAT0;               
N
N    /**
N     * CNT0
N     * ===================================================================================================
N     * Offset: 0x14  PWM Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |CNT       |PWM Data Register
N     * |        |          |Reports the current value of the 16-bit down counter.
N */
N    __I  uint32_t CNT0;                  
X    volatile const  uint32_t CNT0;                  
N
N    /**
N     * PERIOD1
N     * ===================================================================================================
N     * Offset: 0x18  PWM Counter Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |PERIOD    |PWM Counter/Timer Reload Value
N     * |        |          |PERIOD determines the PWM period.
N     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
N     * |        |          |Duty ratio = (CMP+1)/(PERIOD+1).
N     * |        |          |CMP > = PERIOD: PWM output is always high.
N     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
N     * |        |          |(Unit = one PWM clock cycle)
N     * |        |          |Note:
N     * |        |          |Any write to PERIOD will take effect in next PWM cycle.
N */
N    __IO uint32_t PERIOD1;               
X    volatile uint32_t PERIOD1;               
N
N    /**
N     * CMPDAT1
N     * ===================================================================================================
N     * Offset: 0x1C  PWM Comparator Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |CMP       |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty cycle.
N     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
N     * |        |          |Duty Cycle = (CMP+1)/(PERIOD+1).
N     * |        |          |CMP > = PERIOD: PWM output is always high.
N     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
N     * |        |          |(Unit = one PWM clock cycle)
N     * |        |          |Note: Any write to CMP will take effect in next PWM cycle.
N */
N    __IO uint32_t CMPDAT1;               
X    volatile uint32_t CMPDAT1;               
N
N    /**
N     * CNT1
N     * ===================================================================================================
N     * Offset: 0x20  PWM Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |CNT       |PWM Data Register
N     * |        |          |Reports the current value of the 16-bit down counter.
N */
N    __I  uint32_t CNT1;                  
X    volatile const  uint32_t CNT1;                  
N         uint32_t RESERVE0[7];
N
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x40  PWM Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PIEN0     |PWM Timer 0 Interrupt Enable
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable 
N     * |[1]     |PIEN1     |PWM Timer 1 Interrupt Enable
N     * |        |          |0 = Disable
N     * |        |          |1 = Enable
N */
N    __IO uint32_t INTEN;                 
X    volatile uint32_t INTEN;                 
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x44  PWM Interrupt Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PIF0      |PWM Timer 0 Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM CH0 down counter reaches zero, software can clear this bit by writing '1' to it.
N     * |[1]     |PIF1      |PWM Timer 1 Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM CH1 down counter reaches zero, software can clear this bit by writing '1' to it.
N */
N    __IO uint32_t INTSTS;                
X    volatile uint32_t INTSTS;                
N         uint32_t RESERVE1[2];
N
N
N    /**
N     * CAPCTL01
N     * ===================================================================================================
N     * Offset: 0x50  Capture Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPINV0   |Channel 0 Inverter ON/OFF
N     * |        |          |0 = Inverter OFF
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before Capture timer
N     * |[1]     |CRLIEN0   |Channel 0 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |1 = Enable rising latch interrupt.
N     * |        |          |When enabled, capture block generates an interrupt on rising edge of input.
N     * |[2]     |CFLIEN0   |Channel 0 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |1 = Enable falling latch interrupt.
N     * |        |          |When enabled, capture block generates an interrupt on falling edge of input.
N     * |[3]     |CAPEN0    |Capture Channel 0 transition Enable/Disable
N     * |        |          |0 = Disable capture function on channel 0
N     * |        |          |1 = Enable capture function on channel 0.
N     * |        |          |When enabled, Capture function latches the PMW-counter to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers on input edge transition.
N     * |        |          |When disabled, Capture function is inactive as is interrupt.
N     * |[4]     |CAPIF0    |Capture0 Interrupt Indication Flag
N     * |        |          |If channel 0 rising latch interrupt is enabled (CRLIEN0 = 1), a rising transition at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt is enabled (CFLIEN0 = 1).
N     * |        |          |This flag is cleared by software writing a '1' to it.
N     * |[6]     |CRLIF0    |PWM_RCAPDAT0 Latched Indicator Bit
N     * |        |          |When input channel 0 has a rising transition, PWM_RCAPDAT0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.
N     * |[7]     |CFLIF0    |PWM_FCAPDAT0 Latched Indicator Bit
N     * |        |          |When input channel 0 has a falling transition, PWM_FCAPDAT0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it
N     * |[16]    |CAPINV1   |Channel 1 Inverter ON/OFF
N     * |        |          |0 = Inverter OFF
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before Capture timer
N     * |[17]    |CRLIEN1   |Channel 1 Rising Latch Interrupt Enable
N     * |        |          |0 = Disable rising edge latch interrupt
N     * |        |          |1 = Enable rising edge latch interrupt.
N     * |        |          |When enabled, capture block generates an interrupt on rising edge of input.
N     * |[18]    |CFLIEN1   |Channel 1 Falling Latch Interrupt Enable
N     * |        |          |0 = Disable falling edge latch interrupt
N     * |        |          |1 = Enable falling edge latch interrupt.
N     * |        |          |When enabled, capture block generates an interrupt on falling edge of input.
N     * |[19]    |CAPEN1    |Capture Channel 1 Transition Enable/Disable
N     * |        |          |0 = Disable capture function on channel 1
N     * |        |          |1 = Enable capture function on channel 1.
N     * |        |          |When enabled, Capture function latches the PMW-counter to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers on input edge transition.
N     * |        |          |When disabled, Capture function is inactive as is interrupt.
N     * |[20]    |CAPIF1    |Capture1 Interrupt Indication Flag
N     * |        |          |If channel 1 rising latch interrupt is enabled (CRLIEN1 = 1), a rising transition at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt is enabled (CFLIEN1 = 1).
N     * |        |          |This flag is cleared by software writing a '1' to it.
N     * |[22]    |CRLIF1    |PWM_RCAPDAT1 Latched Indicator Bit
N     * |        |          |When input channel 1 has a rising transition, PWM_RCAPDAT1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.
N     * |[23]    |CFLIF1    |PWM_FCAPDAT1 Latched Indicator Bit
N     * |        |          |When input channel 1 has a falling transition, PWM_FCAPDAT1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it
N */
N    __IO uint32_t CAPCTL01;              
X    volatile uint32_t CAPCTL01;              
N         uint32_t RESERVE2[1];
N
N
N    /**
N     * RCAPDAT0
N     * ===================================================================================================
N     * Offset: 0x58  Capture Rising Latch Register (Channel 0)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
N     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a rising edge of the input signal.
N */
N    __I  uint32_t RCAPDAT0;              
X    volatile const  uint32_t RCAPDAT0;              
N
N    /**
N     * FCAPDAT0
N     * ===================================================================================================
N     * Offset: 0x5C  Capture Falling Latch Register (Channel 0)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
N     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a falling edge of the input signal.
N */
N    __I  uint32_t FCAPDAT0;              
X    volatile const  uint32_t FCAPDAT0;              
N
N    /**
N     * RCAPDAT1
N     * ===================================================================================================
N     * Offset: 0x60  Capture Rising Latch Register (Channel 1)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
N     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a rising edge of the input signal.
N */
N    __I  uint32_t RCAPDAT1;              
X    volatile const  uint32_t RCAPDAT1;              
N
N    /**
N     * FCAPDAT1
N     * ===================================================================================================
N     * Offset: 0x64  Capture Falling Latch Register (Channel 1)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
N     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a falling edge of the input signal.
N */
N    __I  uint32_t FCAPDAT1;              
X    volatile const  uint32_t FCAPDAT1;              
N         uint32_t RESERVE3[4];
N
N
N    /**
N     * CAPINEN
N     * ===================================================================================================
N     * Offset: 0x78  Capture Input Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |CAPINEN   |Capture Input Enable Register
N     * |        |          |0 : OFF (PA[13:12] pin input disconnected from Capture block)
N     * |        |          |1 : ON (PA[13:12] pin, if in PWM alternative function, will be configured as an input and fed to capture function)
N     * |        |          |CAPINEN[1:0]
N     * |        |          |Bit 10
N     * |        |          |Bit x1 : Capture channel 0 is from PA [12]
N     * |        |          |Bit 1x : Capture channel 1 is from PA [13] 
N */
N    __IO uint32_t CAPINEN;               
X    volatile uint32_t CAPINEN;               
N
N    /**
N     * POEN
N     * ===================================================================================================
N     * Offset: 0x7C  PWM Output Enable Register for PWM CH0~1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |POEN0     |PWM CH0 Output Enable Register
N     * |        |          |0 = Disable PWM CH0 output to pin.
N     * |        |          |1 = Enable PWM CH0 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function (refer to SYS_GPA_MFP Table 5-7)
N     * |[1]     |POEN1     |PWM CH1 Output Enable Register
N     * |        |          |0 = Disable PWM CH1 output to pin.
N     * |        |          |1 = Enable PWM CH1 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function (refer to SYS_GPA_MFP Table 5-7)
N */
N    __IO uint32_t POEN;                  
X    volatile uint32_t POEN;                  
N
N} PWM_T;
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N#define PWM_CLKPSC_CLKPSC01_Pos          (0)                                               /*!< PWM CLKPSC: CLKPSC01 Position          */
N#define PWM_CLKPSC_CLKPSC01_Msk          (0xfful << PWM_CLKPSC_CLKPSC01_Pos)               /*!< PWM CLKPSC: CLKPSC01 Mask              */
N
N#define PWM_CLKPSC_DTCNT01_Pos           (16)                                              /*!< PWM CLKPSC: DTCNT01 Position           */
N#define PWM_CLKPSC_DTCNT01_Msk           (0xfful << PWM_CLKPSC_DTCNT01_Pos)                /*!< PWM CLKPSC: DTCNT01 Mask               */
N
N#define PWM_CLKDIV_CLKDIV0_Pos           (0)                                               /*!< PWM CLKDIV: CLKDIV0 Position           */
N#define PWM_CLKDIV_CLKDIV0_Msk           (0x7ul << PWM_CLKDIV_CLKDIV0_Pos)                 /*!< PWM CLKDIV: CLKDIV0 Mask               */
N
N#define PWM_CLKDIV_CLKDIV1_Pos           (4)                                               /*!< PWM CLKDIV: CLKDIV1 Position           */
N#define PWM_CLKDIV_CLKDIV1_Msk           (0x7ul << PWM_CLKDIV_CLKDIV1_Pos)                 /*!< PWM CLKDIV: CLKDIV1 Mask               */
N
N#define PWM_CTL_CNTEN0_Pos               (0)                                               /*!< PWM CTL: CNTEN0 Position               */
N#define PWM_CTL_CNTEN0_Msk               (0x1ul << PWM_CTL_CNTEN0_Pos)                     /*!< PWM CTL: CNTEN0 Mask                   */
N
N#define PWM_CTL_PINV0_Pos          	     (2)                                               /*!< PWM CTL: PINV0 Position               */
N#define PWM_CTL_PINV0_Msk           	   (0x1ul << PWM_CTL_PINV0_Pos)       	             /*!< PWM CTL: PINV0 Mask                   */
N
N#define PWM_CTL_CNTMODE0_Pos             (3)                                               /*!< PWM CTL: CNTMODE0 Position               */
N#define PWM_CTL_CNTMODE0_Msk             (0x1ul << PWM_CTL_CNTMODE0_Pos)                   /*!< PWM CTL: CNTMODE0 Mask                   */
N
N#define PWM_CTL_DTEN01_Pos               (4)                                               /*!< PWM CTL: DTEN01 Position               */
N#define PWM_CTL_DTEN01_Msk               (0x1ul << PWM_CTL_DTEN01_Pos)                     /*!< PWM CTL: DTEN01 Mask                   */
N
N#define PWM_CTL_CNTEN1_Pos               (8)                                               /*!< PWM CTL: CNTEN1 Position               */
N#define PWM_CTL_CNTEN1_Msk               (0x1ul << PWM_CTL_CNTEN1_Pos)                     /*!< PWM CTL: CNTEN1 Mask                   */
N
N#define PWM_CTL_PINV1_Pos                (10)                                              /*!< PWM CTL: PINV1 Position                */
N#define PWM_CTL_PINV1_Msk                (0x1ul << PWM_CTL_PINV1_Pos)                      /*!< PWM CTL: PINV1 Mask                    */
N
N#define PWM_CTL_CNTMODE1_Pos             (11)                                              /*!< PWM CTL: CNTMODE1 Position             */
N#define PWM_CTL_CNTMODE1_Msk             (0x1ul << PWM_CTL_CNTMODE1_Pos)                   /*!< PWM CTL: CNTMODE1 Mask                 */
N
N#define PWM_PERIOD0_PERIOD_Pos           (0)                                               /*!< PWM PERIOD0: PERIOD Position           */
N#define PWM_PERIOD0_PERIOD_Msk           (0xfffful << PWM_PERIOD0_PERIOD_Pos)              /*!< PWM PERIOD0: PERIOD Mask               */
N
N#define PWM_CMPDAT0_CMP_Pos              (0)                                               /*!< PWM CMPDAT0: CMP Position              */
N#define PWM_CMPDAT0_CMP_Msk              (0xfffful << PWM_CMPDAT0_CMP_Pos)                 /*!< PWM CMPDAT0: CMP Mask                  */
N
N#define PWM_CNT0_CNT_Pos                 (0)                                               /*!< PWM CNT0: CNT Position                 */
N#define PWM_CNT0_CNT_Msk                 (0xfffful << PWM_CNT0_CNT_Pos)                    /*!< PWM CNT0: CNT Mask                     */
N
N#define PWM_PERIOD1_PERIOD_Pos           (0)                                               /*!< PWM PERIOD1: PERIOD Position           */
N#define PWM_PERIOD1_PERIOD_Msk           (0xfffful << PWM_PERIOD1_PERIOD_Pos)              /*!< PWM PERIOD1: PERIOD Mask               */
N
N#define PWM_CMPDAT1_CMP_Pos              (0)                                               /*!< PWM CMPDAT1: CMP Position              */
N#define PWM_CMPDAT1_CMP_Msk              (0xfffful << PWM_CMPDAT1_CMP_Pos)                 /*!< PWM CMPDAT1: CMP Mask                  */
N
N#define PWM_CNT1_CNT_Pos                 (0)                                               /*!< PWM CNT1: CNT Position                 */
N#define PWM_CNT1_CNT_Msk                 (0xfffful << PWM_CNT1_CNT_Pos)                    /*!< PWM CNT1: CNT Mask                     */
N
N#define PWM_INTEN_PIEN0_Pos              (0)                                               /*!< PWM INTEN: PIEN0 Position              */
N#define PWM_INTEN_PIEN0_Msk              (0x1ul << PWM_INTEN_PIEN0_Pos)                    /*!< PWM INTEN: PIEN0 Mask                  */
N
N#define PWM_INTEN_PIEN1_Pos              (1)                                               /*!< PWM INTEN: PIEN1 Position              */
N#define PWM_INTEN_PIEN1_Msk              (0x1ul << PWM_INTEN_PIEN1_Pos)                    /*!< PWM INTEN: PIEN1 Mask                  */
N
N#define PWM_INTSTS_PIF0_Pos              (0)                                               /*!< PWM INTSTS: PIF0 Position              */
N#define PWM_INTSTS_PIF0_Msk              (0x1ul << PWM_INTSTS_PIF0_Pos)                    /*!< PWM INTSTS: PIF0 Mask                  */
N
N#define PWM_INTSTS_PIF1_Pos              (1)                                               /*!< PWM INTSTS: PIF1 Position              */
N#define PWM_INTSTS_PIF1_Msk              (0x1ul << PWM_INTSTS_PIF1_Pos)                    /*!< PWM INTSTS: PIF1 Mask                  */
N
N#define PWM_CAPCTL01_CAPINV0_Pos         (0)                                               /*!< PWM CAPCTL01: CAPINV0 Position         */
N#define PWM_CAPCTL01_CAPINV0_Msk         (0x1ul << PWM_CAPCTL01_CAPINV0_Pos)               /*!< PWM CAPCTL01: CAPINV0 Mask             */
N
N#define PWM_CAPCTL01_CRLIEN0_Pos         (1)                                               /*!< PWM CAPCTL01: CRLIEN0 Position         */
N#define PWM_CAPCTL01_CRLIEN0_Msk         (0x1ul << PWM_CAPCTL01_CRLIEN0_Pos)               /*!< PWM CAPCTL01: CRLIEN0 Mask             */
N
N#define PWM_CAPCTL01_CFLIEN0_Pos         (2)                                               /*!< PWM CAPCTL01: CFLIEN0 Position         */
N#define PWM_CAPCTL01_CFLIEN0_Msk         (0x1ul << PWM_CAPCTL01_CFLIEN0_Pos)               /*!< PWM CAPCTL01: CFLIEN0 Mask             */
N
N#define PWM_CAPCTL01_CAPEN0_Pos          (3)                                               /*!< PWM CAPCTL01: CAPEN0 Position          */
N#define PWM_CAPCTL01_CAPEN0_Msk          (0x1ul << PWM_CAPCTL01_CAPEN0_Pos)                /*!< PWM CAPCTL01: CAPEN0 Mask              */
N
N#define PWM_CAPCTL01_CAPIF0_Pos          (4)                                               /*!< PWM CAPCTL01: CAPIF0 Position          */
N#define PWM_CAPCTL01_CAPIF0_Msk          (0x1ul << PWM_CAPCTL01_CAPIF0_Pos)                /*!< PWM CAPCTL01: CAPIF0 Mask              */
N
N#define PWM_CAPCTL01_CRLIF0_Pos          (6)                                               /*!< PWM CAPCTL01: CRLIF0 Position          */
N#define PWM_CAPCTL01_CRLIF0_Msk          (0x1ul << PWM_CAPCTL01_CRLIF0_Pos)                /*!< PWM CAPCTL01: CRLIF0 Mask              */
N
N#define PWM_CAPCTL01_CFLIF0_Pos          (7)                                               /*!< PWM CAPCTL01: CFLIF0 Position          */
N#define PWM_CAPCTL01_CFLIF0_Msk          (0x1ul << PWM_CAPCTL01_CFLIF0_Pos)                /*!< PWM CAPCTL01: CFLIF0 Mask              */
N
N#define PWM_CAPCTL01_CAPINV1_Pos         (16)                                              /*!< PWM CAPCTL01: CAPINV1 Position         */
N#define PWM_CAPCTL01_CAPINV1_Msk         (0x1ul << PWM_CAPCTL01_CAPINV1_Pos)               /*!< PWM CAPCTL01: CAPINV1 Mask             */
N
N#define PWM_CAPCTL01_CRLIEN1_Pos         (17)                                              /*!< PWM CAPCTL01: CRLIEN1 Position         */
N#define PWM_CAPCTL01_CRLIEN1_Msk         (0x1ul << PWM_CAPCTL01_CRLIEN1_Pos)               /*!< PWM CAPCTL01: CRLIEN1 Mask             */
N
N#define PWM_CAPCTL01_CFLIEN1_Pos         (18)                                              /*!< PWM CAPCTL01: CFLIEN1 Position         */
N#define PWM_CAPCTL01_CFLIEN1_Msk         (0x1ul << PWM_CAPCTL01_CFLIEN1_Pos)               /*!< PWM CAPCTL01: CFLIEN1 Mask             */
N
N#define PWM_CAPCTL01_CAPEN1_Pos          (19)                                              /*!< PWM CAPCTL01: CAPEN1 Position          */
N#define PWM_CAPCTL01_CAPEN1_Msk          (0x1ul << PWM_CAPCTL01_CAPEN1_Pos)                /*!< PWM CAPCTL01: CAPEN1 Mask              */
N
N#define PWM_CAPCTL01_CAPIF1_Pos          (20)                                              /*!< PWM CAPCTL01: CAPIF1 Position          */
N#define PWM_CAPCTL01_CAPIF1_Msk          (0x1ul << PWM_CAPCTL01_CAPIF1_Pos)                /*!< PWM CAPCTL01: CAPIF1 Mask              */
N
N#define PWM_CAPCTL01_CRLIF1_Pos          (22)                                              /*!< PWM CAPCTL01: CRLIF1 Position          */
N#define PWM_CAPCTL01_CRLIF1_Msk          (0x1ul << PWM_CAPCTL01_CRLIF1_Pos)                /*!< PWM CAPCTL01: CRLIF1 Mask              */
N
N#define PWM_CAPCTL01_CFLIF1_Pos          (23)                                              /*!< PWM CAPCTL01: CFLIF1 Position          */
N#define PWM_CAPCTL01_CFLIF1_Msk          (0x1ul << PWM_CAPCTL01_CFLIF1_Pos)                /*!< PWM CAPCTL01: CFLIF1 Mask              */
N
N#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM RCAPDAT0: RCAPDAT Position         */
N#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM RCAPDAT0: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM FCAPDAT0: FCAPDAT Position         */
N#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM FCAPDAT0: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM RCAPDAT1: RCAPDAT Position         */
N#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM RCAPDAT1: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM FCAPDAT1: FCAPDAT Position         */
N#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM FCAPDAT1: FCAPDAT Mask             */
N
N#define PWM_CAPINEN_CAPINEN_Pos          (0)                                               /*!< PWM CAPINEN: CAPINEN Position          */
N#define PWM_CAPINEN_CAPINEN_Msk          (0x3ul << PWM_CAPINEN_CAPINEN_Pos)                /*!< PWM CAPINEN: CAPINEN Mask              */
N
N#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM POEN: POEN0 Position               */
N#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM POEN: POEN0 Mask                   */
N
N#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM POEN: POEN1 Position               */
N#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM POEN: POEN1 Mask                   */
N
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * INIT
N     * ===================================================================================================
N     * Offset: 0x00  RTC Initialization Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ATVSTS    |RTC Active Status (Read only)
N     * |        |          |0: RTC is in reset state
N     * |        |          |1: RTC is in normal active state.
N     * |[1:31]  |INIT      |RTC Initialization
N     * |        |          |After a power-on reset (POR) RTC block should be initialized by writing 0xA5EB1357 to INIT.
N     * |        |          |This will force a hardware reset then release all logic and counters.
N */
N    __IO  uint32_t INIT;                  
X    volatile  uint32_t INIT;                  
N
N    /**
N     * RWEN
N     * ===================================================================================================
N     * Offset: 0x04  RTC Access Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |RWEN      |RTC Register Access Enable Password (Write only)
N     * |        |          |0xA965 = Enable RTC access
N     * |        |          |Others = Disable RTC access 
N     * |[16]    |RWENF     |RTC Register Access Enable Flag (Read only)
N     * |        |          |1 = RTC register read/write enable.
N     * |        |          |0 = RTC register read/write disable
N     * |        |          |This bit will be set after RWEN[15:0] register is set to 0xA965, it will clear automatically in 512 RTC clock cycles or RWEN[15:0] ! = 0xA965.
N     * |        |          |The effect of RTC_RWEN.RWENF on access to each register is given Table 5-72.
N     * |        |          |Table 5-72 RTC_RWEN.RWENF Register Access Effect.
N     * |        |          |Register : RWENF = 1 : RWENF = 0
N     * |        |          |RTC_INIT : R/W : R/W
N     * |        |          |RTC_FREQADJ : R/W : -
N     * |        |          |RTC_TIME : R/W : R
N     * |        |          |RTC_CAL : R/W : R
N     * |        |          |RTC_CLKFMT : R/W : R/W
N     * |        |          |RTC_WEEKDAY : R/W : R
N     * |        |          |RTC_TALM : R/W : -
N     * |        |          |RTC_CALM : R/W : -
N     * |        |          |RTC_LEAPYEAR : R : R
N     * |        |          |RTC_INTEN : R/W : R/W
N     * |        |          |RTC_INTSTS : R/W : R/W
N     * |        |          |RTC_TICK : R/W : -
N */
N    __O  uint32_t RWEN;                  
X    volatile  uint32_t RWEN;                  
N
N    /**
N     * FREQADJ
N     * ===================================================================================================
N     * Offset: 0x08  RTC Frequency Compensation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:5]   |FRACTION  |Fractional Part
N     * |        |          |Formula = (fraction part of detected value) x 60
N     * |        |          |Refer to 5.8.4.4 for the examples.
N     * |[8:11]  |INTEGER   |Integer Part
N     * |        |          |Register should contain the value (INT(Factual) - 32761)
N     * |        |          |Ex: Integer part of detected value = 32772,
N     * |        |          | RTC_FREQADJ.INTEGER = 32772-32761 = 11 (1011b)
N     * |        |          |The range between 32761 and 32776
N */
N    __IO uint32_t FREQADJ;               
X    volatile uint32_t FREQADJ;               
N
N    /**
N     * TIME
N     * ===================================================================================================
N     * Offset: 0x0C  Time Load Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |SEC       |1 Sec Time Digit (0~9)
N     * |[4:6]   |TENSEC    |10 Sec Time Digit (0~5)
N     * |[8:11]  |MIN       |1 Min Time Digit (0~9)
N     * |[12:14] |TENMIN    |10 Min Time Digit (0~5)
N     * |[16:19] |HR        |1 Hour Time Digit (0~9)
N     * |[20:21] |TENHR     |10 Hour Time Digit (0~3)
N */
N    __IO uint32_t TIME;                  
X    volatile uint32_t TIME;                  
N
N    /**
N     * CAL
N     * ===================================================================================================
N     * Offset: 0x10  Calendar Load Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |DAY       |1-Day Calendar Digit (0~9)
N     * |[4:5]   |TENDAY    |10-Day Calendar Digit (0~3)
N     * |[8:11]  |MON       |1-Month Calendar Digit (0~9)
N     * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
N     * |[16:19] |YEAR      |1-Year Calendar Digit (0~9)
N     * |[20:23] |TENYEAR   |10-Year Calendar Digit (0~9)
N */
N    __IO uint32_t CAL;                   
X    volatile uint32_t CAL;                   
N
N    /**
N     * CLKFMT
N     * ===================================================================================================
N     * Offset: 0x14  Time Scale Selection Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |24HEN     |24-Hour / 12-Hour Mode Selection
N     * |        |          |Determines whether RTC_TIME and RTC_TALM are in 24-hour mode or 12-hour mode
N     * |        |          |1 = select 24-hour time scale
N     * |        |          |0 = select 12-hour time scale with AM and PM indication
N     * |        |          |The range of 24-hour time scale is between 0 and 23.
N     * |        |          |12-hour time scale:
N     * |        |          |01(AM01), 02(AM02), 03(AM03), 04(AM04), 05(AM05), 06(AM06)
N     * |        |          |07(AM07), 08(AM08), 09(AM09), 10(AM10), 11(AM11), 12(AM12)
N     * |        |          |21(PM01), 22(PM02), 23(PM03), 24(PM04), 25(PM05), 26(PM06)
N     * |        |          |27(PM07), 28(PM08), 29(PM09), 30(PM10), 31(PM11), 32(PM12)
N */
N    __IO uint32_t CLKFMT;                
X    volatile uint32_t CLKFMT;                
N
N    /**
N     * WEEKDAY
N     * ===================================================================================================
N     * Offset: 0x18  Day of the Week Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |WEEKDAY   |Day of the Week Register
N     * |        |          |0 (Sunday), 1 (Monday), 2 (Tuesday), 3 (Wednesday)
N     * |        |          |4 (Thursday), 5 (Friday), 6 (Saturday)
N */
N    __IO uint32_t WEEKDAY;               
X    volatile uint32_t WEEKDAY;               
N
N    /**
N     * TALM
N     * ===================================================================================================
N     * Offset: 0x1C  Time Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |SEC       |1 Sec Time Digit of Alarm Setting (0~9)
N     * |[4:6]   |TENSEC    |10 Sec Time Digit of Alarm Setting (0~5)
N     * |[8:11]  |MIN       |1 Min Time Digit of Alarm Setting (0~9)
N     * |[12:14] |TENMIN    |10 Min Time Digit of Alarm Setting (0~5)
N     * |[16:19] |HR        |1 Hour Time Digit of Alarm Setting (0~9)
N     * |[20:21] |TENHR     |10 Hour Time Digit of Alarm Setting (0~3)
N */
N    __IO uint32_t TALM;                  
X    volatile uint32_t TALM;                  
N
N    /**
N     * CALM
N     * ===================================================================================================
N     * Offset: 0x20  Calendar Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
N     * |[4:5]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
N     * |[8:11]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
N     * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
N     * |[16:19] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
N     * |[20:23] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
N */
N    __IO uint32_t CALM;                  
X    volatile uint32_t CALM;                  
N
N    /**
N     * LEAPYEAR
N     * ===================================================================================================
N     * Offset: 0x24  Leap year Indicator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LEAPYEAR  |Leap Year Indication Register (read only)
N     * |        |          |0 = Current year is not a leap year
N     * |        |          |1 = Current year is leap year
N */
N    __I  uint32_t LEAPYEAR;              
X    volatile const  uint32_t LEAPYEAR;              
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x28  RTC Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ALMIEN    |Alarm Interrupt Enable
N     * |        |          |0 = RTC Alarm Interrupt is disabled
N     * |        |          |1 = RTC Alarm Interrupt is enabled
N     * |[1]     |TICKIEN   |Time-Tick Interrupt and Wakeup-by-Tick Enable
N     * |        |          |0 = RTC Time-Tick Interrupt is disabled.
N     * |        |          |1 = RTC Time-Tick Interrupt is enabled.
N */
N    __IO uint32_t INTEN;                 
X    volatile uint32_t INTEN;                 
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x2C  RTC Interrupt Indicator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
N     * |        |          |When RTC Alarm Interrupt is enabled (RTC_INTEN.ALMIEN=1), RTC unit will set AIF to high once the RTC real time counters RTC_TIME and RTC_CAL reach the alarm setting time registers RTC_TALM and RTC_CALM.
N     * |        |          |This bit cleared/acknowledged by writing 1 to it.
N     * |        |          |0= Indicates no Alarm Interrupt condition.
N     * |        |          |1= Indicates RTC Alarm Interrupt generated.
N     * |[1]     |TICKIF    |RTC Time-Tick Interrupt Flag
N     * |        |          |When RTC Time-Tick Interrupt is enabled (RTC_INTEN.TICKIEN=1), RTC unit will set TIF high at the rate selected by RTC_TICK[2:0].
N     * |        |          |This bit cleared/acknowledged by writing 1 to it.
N     * |        |          |0= Indicates no Time-Tick Interrupt condition.
N     * |        |          |1= Indicates RTC Time-Tick Interrupt generated.
N */
N    __IO uint32_t INTSTS;                
X    volatile uint32_t INTSTS;                
N
N    /**
N     * TICK
N     * ===================================================================================================
N     * Offset: 0x30  RTC Time Tick Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:2]   |TICKSEL   |Time Tick Register
N     * |        |          |The RTC time tick period for Periodic Time-Tick Interrupt request.
N     * |        |          |Time Tick (second) : 1 / (2^TICKSEL)
N     * |        |          |Note: This register can be read back after the RTC is active.
N     * |[3]     |TWKEN     |RTC Timer Wakeup CPU Function Enable Bit
N     * |        |          |If TWKEN is set before CPU is in power-down mode, when a RTC Time-Tick or Alarm Match occurs, CPU will wake up.
N     * |        |          |0= Disable Wakeup CPU function.
N     * |        |          |1= Enable the Wakeup function.
N */
N    __IO uint32_t TICK;                  
X    volatile uint32_t TICK;                  
N
N} RTC_T;
N
N/**
N    @addtogroup RTC_CONST RTC Bit Field Definition
N    Constant Definitions for RTC Controller
N@{ */
N
N#define RTC_INIT_ATVSTS_Pos              (0)                                               /*!< RTC INIT: ATVSTS Position              */
N#define RTC_INIT_ATVSTS_Msk              (0x1ul << RTC_INIT_ATVSTS_Pos)                    /*!< RTC INIT: ATVSTS Mask                  */
N
N#define RTC_INIT_INIT_Pos                (1)                                               /*!< RTC INIT: INIT Position                */
N#define RTC_INIT_INIT_Msk                (0x7ffffffful << RTC_INIT_INIT_Pos)               /*!< RTC INIT: INIT Mask                    */
N
N#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC RWEN: RWEN Position                */
N#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC RWEN: RWEN Mask                    */
N
N#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC RWEN: RWENF Position               */
N#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC RWEN: RWENF Mask                   */
N
N#define RTC_FREQADJ_FRACTION_Pos         (0)                                               /*!< RTC FREQADJ: FRACTION Position         */
N#define RTC_FREQADJ_FRACTION_Msk         (0x3ful << RTC_FREQADJ_FRACTION_Pos)              /*!< RTC FREQADJ: FRACTION Mask             */
N
N#define RTC_FREQADJ_INTEGER_Pos          (8)                                               /*!< RTC FREQADJ: INTEGER Position          */
N#define RTC_FREQADJ_INTEGER_Msk          (0xful << RTC_FREQADJ_INTEGER_Pos)                /*!< RTC FREQADJ: INTEGER Mask              */
N
N#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC TIME: SEC Position                 */
N#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC TIME: SEC Mask                     */
N
N#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC TIME: TENSEC Position              */
N#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC TIME: TENSEC Mask                  */
N
N#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC TIME: MIN Position                 */
N#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC TIME: MIN Mask                     */
N
N#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC TIME: TENMIN Position              */
N#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC TIME: TENMIN Mask                  */
N
N#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC TIME: HR Position                  */
N#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC TIME: HR Mask                      */
N
N#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC TIME: TENHR Position               */
N#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC TIME: TENHR Mask                   */
N
N#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC CAL: DAY Position                  */
N#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC CAL: DAY Mask                      */
N
N#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC CAL: TENDAY Position               */
N#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC CAL: TENDAY Mask                   */
N
N#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC CAL: MON Position                  */
N#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC CAL: MON Mask                      */
N
N#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC CAL: TENMON Position               */
N#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC CAL: TENMON Mask                   */
N
N#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC CAL: YEAR Position                 */
N#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC CAL: YEAR Mask                     */
N
N#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC CAL: TENYEAR Position              */
N#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC CAL: TENYEAR Mask                  */
N
N#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC CLKFMT: 24HEN Position             */
N#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC CLKFMT: 24HEN Mask                 */
N
N#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC WEEKDAY: WEEKDAY Position          */
N#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC WEEKDAY: WEEKDAY Mask              */
N
N#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC TALM: SEC Position                 */
N#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC TALM: SEC Mask                     */
N
N#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC TALM: TENSEC Position              */
N#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC TALM: TENSEC Mask                  */
N
N#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC TALM: MIN Position                 */
N#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC TALM: MIN Mask                     */
N
N#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC TALM: TENMIN Position              */
N#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC TALM: TENMIN Mask                  */
N
N#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC TALM: HR Position                  */
N#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC TALM: HR Mask                      */
N
N#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC TALM: TENHR Position               */
N#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC TALM: TENHR Mask                   */
N
N#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC CALM: DAY Position                 */
N#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC CALM: DAY Mask                     */
N
N#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC CALM: TENDAY Position              */
N#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC CALM: TENDAY Mask                  */
N
N#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC CALM: MON Position                 */
N#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC CALM: MON Mask                     */
N
N#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC CALM: TENMON Position              */
N#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC CALM: TENMON Mask                  */
N
N#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC CALM: YEAR Position                */
N#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC CALM: YEAR Mask                    */
N
N#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC CALM: TENYEAR Position             */
N#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC CALM: TENYEAR Mask                 */
N
N#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC LEAPYEAR: LEAPYEAR Position        */
N#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC LEAPYEAR: LEAPYEAR Mask            */
N
N#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC INTEN: ALMIEN Position             */
N#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC INTEN: ALMIEN Mask                 */
N
N#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC INTEN: TICKIEN Position            */
N#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC INTEN: TICKIEN Mask                */
N
N#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC INTSTS: ALMIF Position             */
N#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC INTSTS: ALMIF Mask                 */
N
N#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC INTSTS: TICKIF Position            */
N#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC INTSTS: TICKIF Mask                */
N
N#define RTC_TICK_TICKSEL_Pos             (0)                                               /*!< RTC TICK: TICKSEL Position             */
N#define RTC_TICK_TICKSEL_Msk             (0x7ul << RTC_TICK_TICKSEL_Pos)                   /*!< RTC TICK: TICKSEL Mask                 */
N
N#define RTC_TICK_TWKEN_Pos               (3)                                               /*!< RTC TICK: TWKEN Position               */
N#define RTC_TICK_TWKEN_Msk               (0x1ul << RTC_TICK_TWKEN_Pos)                     /*!< RTC TICK: TWKEN Mask                   */
N
N/**@}*/ /* RTC_CONST */
N/**@}*/ /* end of RTC register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BUSY      |Go and Busy Status
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit starts the transfer.
N     * |        |          |This bit remains set during the transfer and is automatically cleared after transfer finished.
N     * |        |          |NOTE: All registers should be set before writing 1 to this BUSY bit.
N     * |        |          |When a transfer is in progress, writing to any register of the SPI master/slave core has no effect.
N     * |[1]     |RXNET     |Receive At Negative Edge
N     * |        |          |0 = The received data input signal is latched at the rising edge of SCLK.
N     * |        |          |1 = The received data input signal is latched at the falling edge of SCLK.
N     * |[2]     |TXNEG     |Transmit At Negative Edge
N     * |        |          |0 = The transmitted data output signal is changed at the rising edge of SCLK.
N     * |        |          |1 = The transmitted data output signal is changed at the falling edge of SCLK.
N     * |[3:7]   |DWIDTH    |Transmit Bit Length
N     * |        |          |This field specifies how many bits are transmitted in one transmit/receive.
N     * |        |          |Up to 32 bits can be transmitted.
N     * |        |          |DWIDTH = 0x01 --- 1 bit
N     * |        |          |DWIDTH = 0x02 --- 2 bits
N     * |        |          |----
N     * |        |          |DWIDTH = 0x1f --- 31 bits
N     * |        |          |DWIDTH = 0x00 --- 32 bits
N     * |[8:9]   |TXCNT     |Transmit/Receive Word Numbers
N     * |        |          |This field specifies how many transmit/receive word numbers should be executed in one transfer.
N     * |        |          |00 = Only one transmit/receive word will be executed in one transfer.
N     * |        |          |01 = Two successive transmit/receive word will be executed in one transfer.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Reserved.
N     * |[10]    |LSB       |LSB First
N     * |        |          |0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the DWIDTH field).
N     * |        |          |1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the Rx register (bit 0 of SPI_RX0/1).
N     * |[11]    |CLKPOL    |Clock Polarity
N     * |        |          |0 = SCLK idle low.
N     * |        |          |1 = SCLK idle high.
N     * |[12:15] |SUSPITV   |Suspend Interval (Master Only)
N     * |        |          |These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer.
N     * |        |          |The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKPOL = 0.
N     * |        |          |If CLKPOL = 1, the interval is from the rising clock edge to the falling clock edge.
N     * |        |          |The default value is 0x0.
N     * |        |          |When TXCNT = 00b, setting this field has no effect on transfer except as determined by REORDER[0] setting.
N     * |        |          |The suspend interval is determined according to the following equation:.
N     * |        |          |(SUSPITV[3:0] + 2) * period of SCLK
N     * |[16]    |UNITIF    |Interrupt Flag
N     * |        |          |0 = Indicates the transfer is not finished yet.
N     * |        |          |1 = Indicates that the transfer is complete. Interrupt is generated to CPU if enabled.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[17]    |UNITIEN   |Interrupt Enable
N     * |        |          |0 = Disable SPI Interrupt.
N     * |        |          |1 = Enable SPI Interrupt to CPU.
N     * |[18]    |SLAVE     |Master Slave Mode Control
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[19]    |BYTEITV   |Insert Sleep Interval Between Bytes
N     * |        |          |This function is only valid for 32bit transfers (DWIDTH = 0).
N     * |        |          |If set then a pause of (SUSPITV+2) SCLK cycles is inserted between each byte transmitted.
N     * |[20]    |REORDER   |Byte Endian Reorder Function
N     * |        |          |This function changes the order of bytes sent/received to be least significant physical byte first. 
N     * |[21]    |FIFOEN    |FIFO Mode
N     * |        |          |0 = No FIFO present on transmit and receive buffer.
N     * |        |          |1 = Enable FIFO on transmit and receive buffer.
N     * |[22]    |TWOBIT    |Two Bits Transfer Mode
N     * |        |          |0 = Disable two-bit transfer mode.
N     * |        |          |1 = Enable two-bit transfer mode.
N     * |        |          |Note that when enabled in master mode, MOSI0 data comes from SPI_TX0 and MOSI1 data from SPI_TX1.
N     * |        |          |Likewise SPI_RX0 receives bit stream from MISO0 and SPI_RX1 from MISO1.
N     * |        |          |Note that when enabled, the setting of TXCNT must be programmed as 0x00.
N     * |[23]    |VARCLKEN  |Variable Clock Enable (Master Only)
N     * |        |          |0 = The serial clock output frequency is fixed and determined only by the value of DIVIDER0.
N     * |        |          |1 = SCLK output frequency is variable.
N     * |        |          |The output frequency is determined by the value of SPI_VARCLK, DIVIDER0, and DIVIDER1.
N     * |        |          |Note that when enabled, the setting of DWIDTH must be programmed as 0x10 (16 bits mode)
N     * |[24]    |RXEMPTY   |Receive FIFO Empty Status
N     * |        |          |0 = The receive data FIFO is not empty.
N     * |        |          |1 = The receive data FIFO is empty.
N     * |[25]    |RXFULL    |Receive FIFO Full Status
N     * |        |          |0 = The receive data FIFO is not full.
N     * |        |          |1 = The receive data FIFO is full.
N     * |[26]    |TXEMPTY   |Transmit FIFO Empty Status
N     * |        |          |0 = The transmit data FIFO is not empty.
N     * |        |          |1 = The transmit data FIFO is empty.
N     * |[27]    |TXFULL    |Transmit FIFO Full Status
N     * |        |          |0 = The transmit data FIFO is not full.
N     * |        |          |1 = The transmit data FIFO is full.
N     * |[28]    |PDMASSEN  |Enable DMA Automatic SS function
N     * |        |          |When enabled, interface will automatically generate a SS signal for an entire PDMA access transaction.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x04  Clock Divider Register (Master Only)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |DIVIDER0  |Clock Divider Register (master only)
N     * |        |          |The value in this field is the frequency division of the system clock, PCLK, to generate the serial clock on the output SCLK.
N     * |        |          |The desired frequency is obtained according to the following equation:.
N     * |        |          |Fsclk = Fpclk / ((DIVIDER0+1) * 2)
N     * |        |          |In slave mode, the period of SPI clock driven by a master shall satisfy
N     * |        |          |Fsclk < = (Fpclk / 5)
N     * |        |          |In other words, the maximum frequency of SCLK clock is one fifth of the SPI peripheral clock.
N     * |[16:31] |DIVIDER1  |Clock Divider 2 Register (master only)
N     * |        |          |The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SCLK.
N     * |        |          |The desired frequency is obtained according to the following equation:.
N     * |        |          |Fsclk = Fpclk / ((DIVIDER1+1) * 2)
N */
N    __IO uint32_t CLKDIV;                
X    volatile uint32_t CLKDIV;                
N
N    /**
N     * SSCTL
N     * ===================================================================================================
N     * Offset: 0x08  Slave Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |SS        |Slave Select Register (Master only)
N     * |        |          |If AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.
N     * |        |          |If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time.
N     * |        |          |(The active level of SPISSx0/1 is specified in SSACTPOL).
N     * |        |          |Note: SPISSx0 is always defined as device/slave select input signal in slave mode. 
N     * |[2]     |SSACTPOL  |Slave Select Active Level
N     * |        |          |It defines the active level of device/slave select signal (SPISSx0/1).
N     * |        |          |0 = The slave select signal SPISSx0/1 is active at low-level/falling-edge.
N     * |        |          |1 = The slave select signal SPISSx0/1 is active at high-level/rising-edge.
N     * |[3]     |AUTOSS    |Automatic Slave Select (Master only)
N     * |        |          |0 = If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SPI_SSCTL[1:0] register.
N     * |        |          |1 = If this bit is set, SPISSx0/1 signals are generated automatically.
N     * |        |          |It means that device/slave select signal, which is set in SPI_SSCTL[1:0] register is asserted by the SPI controller when transmit/receive is started by setting BUSY, and is de-asserted after each transmit/receive is finished.
N     * |[4]     |LVTRGEN   |Slave Select Level Trigger (Slave only)
N     * |        |          |0= The input slave select signal is edge-trigger. This is the default value.
N     * |        |          |1= The slave select signal will be level-trigger.
N     * |        |          |It depends on SSACTPOL to decide the signal is active low or active high.
N     * |[5]     |LVTRGSTS  |Level Trigger Flag
N     * |        |          |When the LVTRGEN bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
N     * |        |          |0=One of the received number and the received bit length doesn't meet the requirement in one transfer.
N     * |        |          |1=The received number and received bits met the requirement which defines in TXCNT and DWIDTH among one transfer.
N     * |        |          |Note: This bit is READ only
N */
N    __IO uint32_t SSCTL;                 
X    volatile uint32_t SSCTL;                 
N         uint32_t RESERVE0[1];
N
N
N    /**
N     * RX0
N     * ===================================================================================================
N     * Offset: 0x10  Data Receive Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |RX        |Data Receive Register
N     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer.
N     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
N     * |        |          |For example, if DWIDTH is set to 0x08 and TXCNT is set to 0x0, bit Rx0[7:0] holds the received data.
N     * |        |          |NOTE: The Data Receive Registers are read only registers. 
N */
N    __I  uint32_t RX0;                   
X    volatile const  uint32_t RX0;                   
N
N    /**
N     * RX1
N     * ===================================================================================================
N     * Offset: 0x14  Data Receive Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |RX        |Data Receive Register
N     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer.
N     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
N     * |        |          |For example, if DWIDTH is set to 0x08 and TXCNT is set to 0x0, bit Rx0[7:0] holds the received data.
N     * |        |          |NOTE: The Data Receive Registers are read only registers. 
N */
N    __I  uint32_t RX1;                   
X    volatile const  uint32_t RX1;                   
N         uint32_t RESERVE1[2];
N
N
N    /**
N     * TX0
N     * ===================================================================================================
N     * Offset: 0x20  Data Transmit Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |TX        |Data Transmit Register
N     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
N     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
N     * |        |          |For example, if DWIDTH is set to 0x08 and the TXCNT is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer.
N     * |        |          |If DWIDTH is set to 0x00 and TXCNT is set to 0x1, the core will perform two 32-bit transmit/receive successive using the same setting (the order is TX0[31:0], TX1[31:0]).
N */
N    __O  uint32_t TX0;                   
X    volatile  uint32_t TX0;                   
N
N    /**
N     * TX1
N     * ===================================================================================================
N     * Offset: 0x24  Data Transmit Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |TX        |Data Transmit Register
N     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
N     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
N     * |        |          |For example, if DWIDTH is set to 0x08 and the TXCNT is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer.
N     * |        |          |If DWIDTH is set to 0x00 and TXCNT is set to 0x1, the core will perform two 32-bit transmit/receive successive using the same setting (the order is TX0[31:0], TX1[31:0]).
N */
N    __O  uint32_t TX1;                   
X    volatile  uint32_t TX1;                   
N         uint32_t RESERVE2[3];
N
N
N    /**
N     * VARCLK
N     * ===================================================================================================
N     * Offset: 0x34  Variable Clock Pattern Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |VARCLK    |Variable Clock Pattern
N     * |        |          |The value in this field is the frequency pattern of the SPI clock.
N     * |        |          |If the bit field of VARCLK is '0', the output frequency of SCLK is given by the value of DIVIDER0.
N     * |        |          |If the bit field of VARCLK is '1', the output frequency of SCLK is given by the value of DIVIDER1.
N     * |        |          |Refer to register DIVIDER0.
N     * |        |          |Refer to Variable Serial Clock Frequency paragraph for detailed description.
N     * |        |          |Note: Used for CLKPOL = 0 only, 16 bit transmission.
N */
N    __IO uint32_t VARCLK;                
X    volatile uint32_t VARCLK;                
N
N    /**
N     * PDMACTL
N     * ===================================================================================================
N     * Offset: 0x38  SPI DMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TXPDMAEN  |Transmit DMA Start
N     * |        |          |Set this bit to 1 will start the transmit DMA process.
N     * |        |          |SPI module will issue request to DMA module automatically.
N     * |        |          |If using DMA mode to transfer data, remember not to set BUSY bit of SPI_CTL register.
N     * |        |          |The DMA controller inside SPI module will set it automatically whenever necessary.
N     * |[1]     |RXPDMAEN  |Receive DMA Start
N     * |        |          |Set this bit to 1 will start the receive DMA process.
N     * |        |          |SPI module will issue request to DMA module automatically.
N */
N    __IO uint32_t PDMACTL;               
X    volatile uint32_t PDMACTL;               
N
N} SPI_T;
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N#define SPI_CTL_BUSY_Pos                 (0)                                               /*!< SPI CTL: BUSY Position                 */
N#define SPI_CTL_BUSY_Msk                 (0x1ul << SPI_CTL_BUSY_Pos)                       /*!< SPI CTL: BUSY Mask                     */
N
N#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI CTL: RXNEG Position                */
N#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI CTL: RXNEG Mask                    */
N
N#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI CTL: TXNEG Position                */
N#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI CTL: TXNEG Mask                    */
N
N#define SPI_CTL_DWIDTH_Pos               (3)                                               /*!< SPI CTL: DWIDTH Position               */
N#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI CTL: DWIDTH Mask                   */
N
N#define SPI_CTL_TX_NUM_Pos               (8)                                               /*!< SPI CTL: TX_NUM Position                */
N#define SPI_CTL_TX_NUM_Msk               (0x3ul << SPI_CTL_TX_NUM_Pos)                      /*!< SPI CTL: TX_NUM Mask                    */
N
N#define SPI_CTL_LSB_Pos                  (10)                                              /*!< SPI CTL: LSB Position                  */
N#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI CTL: LSB Mask                      */
N
N#define SPI_CTL_CLKP_Pos                 (11)                                              /*!< SPI CTL: CLKP Position               */
N#define SPI_CTL_CLKP_Msk                 (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI CTL: CLKP Mask                   */
N
N#define SPI_CTL_SUSPITV_Pos              (12)                                              /*!< SPI CTL: SUSPITV Position              */
N#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI CTL: SUSPITV Mask                  */
N
N#define SPI_CTL_UNIT_INTSTS_Pos          (16)                                              /*!< SPI CTL: UNIT_INTSTS Position               */
N#define SPI_CTL_UNIT_INTSTS_Msk          (0x1ul << SPI_CTL_UNIT_INTSTS_Pos)                /*!< SPI CTL: UNITIF Mask                   */
N
N#define SPI_CTL_UNIT_INTEN_Pos           (17)                                              /*!< SPI CTL: UNITIEN Position              */
N#define SPI_CTL_UNIT_INTEN_Msk           (0x1ul << SPI_CTL_UNIT_INTEN_Pos)                 /*!< SPI CTL: UNITIEN Mask                  */
N
N#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI CTL: SLAVE Position                */
N#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI CTL: SLAVE Mask                    */
N
N#define SPI_CTL_BYTEITV_Pos              (19)                                              /*!< SPI CTL: BYTEITV Position              */
N#define SPI_CTL_BYTEITV_Msk              (0x1ul << SPI_CTL_BYTEITV_Pos)                    /*!< SPI CTL: BYTEITV Mask                  */
N
N#define SPI_CTL_REORDER_Pos              (20)                                              /*!< SPI CTL: REORDER Position              */
N#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI CTL: REORDER Mask                  */
N
N#define SPI_CTL_FIFOEN_Pos               (21)                                              /*!< SPI CTL: FIFOEN Position               */
N#define SPI_CTL_FIFOEN_Msk               (0x1ul << SPI_CTL_FIFOEN_Pos)                     /*!< SPI CTL: FIFOEN Mask                   */
N
N#define SPI_CTL_TWOBIT_Pos               (22)                                              /*!< SPI CTL: TWOBIT Position               */
N#define SPI_CTL_TWOBIT_Msk               (0x1ul << SPI_CTL_TWOBIT_Pos)                     /*!< SPI CTL: TWOBIT Mask                   */
N
N#define SPI_CTL_VARCLKEN_Pos             (23)                                              /*!< SPI CTL: VARCLKEN Position             */
N#define SPI_CTL_VARCLKEN_Msk             (0x1ul << SPI_CTL_VARCLKEN_Pos)                   /*!< SPI CTL: VARCLKEN Mask                 */
N
N#define SPI_CTL_RXEMPTY_Pos              (24)                                              /*!< SPI CTL: RXEMPTY Position              */
N#define SPI_CTL_RXEMPTY_Msk              (0x1ul << SPI_CTL_RXEMPTY_Pos)                    /*!< SPI CTL: RXEMPTY Mask                  */
N
N#define SPI_CTL_RXFULL_Pos               (25)                                              /*!< SPI CTL: RXFULL Position               */
N#define SPI_CTL_RXFULL_Msk               (0x1ul << SPI_CTL_RXFULL_Pos)                     /*!< SPI CTL: RXFULL Mask                   */
N
N#define SPI_CTL_TXEMPTY_Pos              (26)                                              /*!< SPI CTL: TXEMPTY Position              */
N#define SPI_CTL_TXEMPTY_Msk              (0x1ul << SPI_CTL_TXEMPTY_Pos)                    /*!< SPI CTL: TXEMPTY Mask                  */
N
N#define SPI_CTL_TXFULL_Pos               (27)                                              /*!< SPI CTL: TXFULL Position               */
N#define SPI_CTL_TXFULL_Msk               (0x1ul << SPI_CTL_TXFULL_Pos)                     /*!< SPI CTL: TXFULL Mask                   */
N
N#define SPI_CTL_PDMASSEN_Pos             (28)                                              /*!< SPI CTL: PDMASSEN Position             */
N#define SPI_CTL_PDMASSEN_Msk             (0x1ul << SPI_CTL_PDMASSEN_Pos)                   /*!< SPI CTL: PDMASSEN Mask                 */
N
N#define SPI_CLKDIV_DIVIDER0_Pos          (0)                                               /*!< SPI CLKDIV: DIVIDER0 Position          */
N#define SPI_CLKDIV_DIVIDER0_Msk          (0xfffful << SPI_CLKDIV_DIVIDER0_Pos)             /*!< SPI CLKDIV: DIVIDER0 Mask              */
N
N#define SPI_CLKDIV_DIVIDER1_Pos          (16)                                              /*!< SPI CLKDIV: DIVIDER1 Position          */
N#define SPI_CLKDIV_DIVIDER1_Msk          (0xfffful << SPI_CLKDIV_DIVIDER1_Pos)             /*!< SPI CLKDIV: DIVIDER1 Mask              */
N
N#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI SSCTL: SS Position                 */
N#define SPI_SSCTL_SS_Msk                 (0x3ul << SPI_SSCTL_SS_Pos)                       /*!< SPI SSCTL: SS Mask                     */
N
N#define SPI_SSCTL_SS_LVL_Pos             (2)                                               /*!< SPI SSCTL: SS_LVL Position           */
N#define SPI_SSCTL_SS_LVL_Msk             (0x1ul << SPI_SSCTL_SS_LVL_Pos)                   /*!< SPI SSCTL: SS_LVL Mask               */
N
N#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI SSCTL: AUTOSS Position             */
N#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI SSCTL: AUTOSS Mask                 */
N
N#define SPI_SSCTL_LVTRGEN_Pos            (4)                                               /*!< SPI SSCTL: LVTRGEN Position            */
N#define SPI_SSCTL_LVTRGEN_Msk            (0x1ul << SPI_SSCTL_LVTRGEN_Pos)                  /*!< SPI SSCTL: LVTRGEN Mask                */
N
N#define SPI_SSCTL_LVTRGSTS_Pos           (5)                                               /*!< SPI SSCTL: LVTRGSTS Position           */
N#define SPI_SSCTL_LVTRGSTS_Msk           (0x1ul << SPI_SSCTL_LVTRGSTS_Pos)                 /*!< SPI SSCTL: LVTRGSTS Mask               */
N
N#define SPI_RX0_RX_Pos                   (0)                                               /*!< SPI RX0: RX Position                   */
N#define SPI_RX0_RX_Msk                   (0xfffffffful << SPI_RX0_RX_Pos)                  /*!< SPI RX0: RX Mask                       */
N
N#define SPI_RX1_RX_Pos                   (0)                                               /*!< SPI RX1: RX Position                   */
N#define SPI_RX1_RX_Msk                   (0xfffffffful << SPI_RX1_RX_Pos)                  /*!< SPI RX1: RX Mask                       */
N
N#define SPI_TX0_TX_Pos                   (0)                                               /*!< SPI TX0: TX Position                   */
N#define SPI_TX0_TX_Msk                   (0xfffffffful << SPI_TX0_TX_Pos)                  /*!< SPI TX0: TX Mask                       */
N
N#define SPI_TX1_TX_Pos                   (0)                                               /*!< SPI TX1: TX Position                   */
N#define SPI_TX1_TX_Msk                   (0xfffffffful << SPI_TX1_TX_Pos)                  /*!< SPI TX1: TX Mask                       */
N
N#define SPI_VARCLK_VARCLK_Pos            (0)                                               /*!< SPI VARCLK: VARCLK Position            */
N#define SPI_VARCLK_VARCLK_Msk            (0xfffffffful << SPI_VARCLK_VARCLK_Pos)           /*!< SPI VARCLK: VARCLK Mask                */
N
N#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI PDMACTL: TXPDMAEN Position         */
N#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI PDMACTL: TXPDMAEN Mask             */
N
N#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI PDMACTL: RXPDMAEN Position         */
N#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI PDMACTL: RXPDMAEN Mask             */
N
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N 
Ntypedef struct
N{
N
N    /**
N     * PDID
N     * ===================================================================================================
N     * Offset: 0x00  Product Identifier Register 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:31]  |CORERSTF  |Chip Part Number Identifier
N */
N         uint32_t PDID;
N
N
N    /**
N     * RSTSTS
N     * ===================================================================================================
N     * Offset: 0x04  System Reset Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CORERSTF  |Reset Source From CORE
N     * |        |          |The CORERSTF flag is set if the core has been reset.
N     * |        |          |Possible sources of reset are a Power-On Reset (POR), RESETn Pin Reset or PMU reset.
N     * |        |          |0= No reset from CORE
N     * |        |          |1= Core was reset by hardware block.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[2]     |WDTRF     |Reset Source From WDT
N     * |        |          |The WDTRF flag is set if pervious reset source originates from the Watch-Dog module.
N     * |        |          |0= No reset from Watch-Dog
N     * |        |          |1= The Watch-Dog module issued the reset signal to reset the system.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[5]     |SYSRF     |Reset Source From MCU
N     * |        |          |The SYSRF flag is set if the previous reset source originates from the Cortex_M0 kernel.
N     * |        |          |0= No reset from MCU
N     * |        |          |1= The Cortex_M0 MCU issued a reset signal to reset the system by software writing 1 to bit SYSCTL_AIRCTL.SYSRESTREQ, Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[6]     |PMURSTF   |Reset Source From PMU
N     * |        |          |The PMURSTF flag is set if the PMU.
N     * |        |          |0= No reset from PMU
N     * |        |          |1= PMU reset the system from a power down/standby event.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[7]     |CPURF     |Reset Source From CPU
N     * |        |          |The CPURF flag is set by hardware if software writes SYS_IPRST0.CPURST with a "1" to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).
N     * |        |          |0= No reset from CPU
N     * |        |          |1= The Cortex-M0 CPU kernel and FMC has been reset by software setting CPURST to 1.
N     * |        |          |This bit is cleared by writing 1 to itself.
N */
N    __IO uint32_t RSTSTS;                
X    volatile uint32_t RSTSTS;                
N
N    /**
N     * IPRST0
N     * ===================================================================================================
N     * Offset: 0x08  IP Reset Control Resister1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIPRST   |CHIP One Shot Reset
N     * |        |          |Set this bit will reset the whole chip, this bit will automatically return to "0" after the 2 clock cycles.
N     * |        |          |CHIPRST has same behavior as POR reset, all the chip modules are reset and the chip configuration settings from flash are reloaded.
N     * |        |          |This bit is a protected bit, to program first issue the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
N     * |        |          |0= Normal
N     * |        |          |1= Reset CHIP
N     * |[1]     |CPURST    |CPU Kernel One Shot Reset
N     * |        |          |Setting this bit will reset the CPU kernel and Flash Memory Controller(FMC), this bit will automatically return to "0" after the 2 clock cycles
N     * |        |          |This bit is a protected bit, to program first issue the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
N     * |        |          |0= Normal
N     * |        |          |1= Reset CPU
N     * |[2]     |PDMARST   |PDMA Controller Reset
N     * |        |          |Set "1" will generate a reset signal to the PDMA Block.
N     * |        |          |User needs to set this bit to "0" to release from the reset state.
N     * |        |          |0= Normal operation
N     * |        |          |1= PDMA IP reset
N */
N    __IO uint32_t IPRST0;                
X    volatile uint32_t IPRST0;                
N
N    /**
N     * IPRST1
N     * ===================================================================================================
N     * Offset: 0x0C  IP Reset Control Resister2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6]     |TMR0RST   |Timer0 Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[7]     |TMR1RST   |Timer1 Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[8]     |I2C0RST   |I2C0 Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[12]    |SPI0RST   |SPI0 Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[13]    |DPWMRST   |DPWM Speaker Driver Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[16]    |UART0RST  |UART0 Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[18]    |BIQRST    |Biquad Filter Block Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[19]    |CRCRST    |CRC Generation Block Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[20]    |PWM0RST   |PWM0 controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[22]    |ACMPRST   |Analog Comparator Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[28]    |EADCRST   |ADC Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[29]    |I2S0RST   |I2S Controller Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N     * |[30]    |ANARST    |Analog Block Control Reset
N     * |        |          |0 = Normal Operation
N     * |        |          |1 = Reset
N */
N    __IO uint32_t IPRST1;                
X    volatile uint32_t IPRST1;                
N         uint32_t RESERVE1[8];
N
N
N    /**
N     * PASMTEN
N     * ===================================================================================================
N     * Offset: 0x30  GPIOA input type control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[16]    |SMTEN16   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[17]    |SMTEN17   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[18]    |SMTEN18   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[19]    |SMTEN19   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[20]    |SMTEN20   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[21]    |SMTEN21   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[22]    |SMTEN22   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[23]    |SMTEN23   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[24]    |SMTEN24   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[25]    |SMTEN25   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[26]    |SMTEN26   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[27]    |SMTEN27   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[28]    |SMTEN28   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[29]    |SMTEN29   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[30]    |SMTEN30   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N     * |[31]    |SMTEN31   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
N */
N    __IO uint32_t PASMTEN;               
X    volatile uint32_t PASMTEN;               
N
N    /**
N     * PBSMTEN
N     * ===================================================================================================
N     * Offset: 0x34  GPIOB input type control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[16]    |SMTEN16   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[17]    |SMTEN17   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[18]    |SMTEN18   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[19]    |SMTEN19   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[20]    |SMTEN20   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[21]    |SMTEN21   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[22]    |SMTEN22   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N     * |[23]    |SMTEN23   |Schmitt Trigger
N     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
N     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
N     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
N */
N    __IO uint32_t PBSMTEN;               
X    volatile uint32_t PBSMTEN;               
N
N    /**
N     * GPA_MFP
N     * ===================================================================================================
N     * Offset: 0x38  GPIOA multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |PA0MFP    |Alternate Function Setting For PA0MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = SPI_MOSI0
N     * |        |          |10 = MCLK
N     * |[2:3]   |PA1MFP    |Alternate Function Setting For PA1MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = SPI_SCLK
N     * |        |          |10 = I2C_SCL
N     * |[4:5]   |PA2MFP    |Alternate Function Setting For PA2MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = SPI_SSB0
N     * |[6:7]   |PA3MFP    |Alternate Function Setting For PA3MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = SPI_MISO0
N     * |        |          |10 = I2C_SDA
N     * |[8:9]   |PA4MFP    |Alternate Function Setting For PA4MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2S_FS
N     * |[10:11] |PA5MFP    |Alternate Function Setting For PA5MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2S_BCLK
N     * |[12:13] |PA6MFP    |Alternate Function Setting For PA6MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2S_SDI
N     * |[14:15] |PA7MFP    |Alternate Function Setting For PA7MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2S_SDO
N     * |[16:17] |PA8MFP    |Alternate Function Setting For PA8MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = UART_TX
N     * |        |          |10 = I2S_FS
N     * |[18:19] |PA9MFP    |Alternate Function Setting For PA0MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = UART_RX
N     * |        |          |10 = I2S_BCLK
N     * |[20:21] |PA10MFP   |Alternate Function Setting For PA10MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2C_SDA
N     * |        |          |10 = I2S_SDI
N     * |        |          |11 = UART_RTSn
N     * |[22:23] |PA11MFP   |Alternate Function Setting For PA11MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2C_SCL
N     * |        |          |10 = I2S_SDO
N     * |        |          |11 = UART_CTSn
N     * |[24:25] |PA12MFP   |Alternate Function Setting For PA12MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = PWM0CH0
N     * |        |          |10 = SPKP
N     * |        |          |11 = I2S_FS
N     * |[26:27] |PA13MFP   |Alternate Function Setting For PA13MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = PWM0CH1
N     * |        |          |10 = SPKM
N     * |        |          |11 = I2S_BCLK
N     * |[28:29] |PA14MFP   |Alternate Function Setting For PA14MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = TM0
N     * |        |          |10 = SDCLK
N     * |        |          |11 = SDCLKn
N     * |[30:31] |PA15MFP   |Alternate Function Setting For PA15MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = TM1
N     * |        |          |10 = SDIN
N */
N    __IO uint32_t GPA_MFP;               
X    volatile uint32_t GPA_MFP;               
N
N    /**
N     * GPB_MFP
N     * ===================================================================================================
N     * Offset: 0x3C  GPIOB multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |PB0MFP    |Alternate Function Setting For PB0MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = SPI_SSB1
N     * |        |          |10 = CMP0
N     * |        |          |11 = SPI_SSB0
N     * |[2:3]   |PB1MFP    |Alternate Function Setting For PB1MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = MCLK
N     * |        |          |10 = CMP1
N     * |        |          |11 = SPI_SSB1
N     * |[4:5]   |PB2MFP    |Alternate Function Setting For PB2MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2C_SCL
N     * |        |          |10 = CMP2
N     * |        |          |11 = SPI_SCLK
N     * |[6:7]   |PB3MFP    |Alternate Function Setting For PB3MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2C_SDA
N     * |        |          |10 = CMP3
N     * |        |          |11 = SPI_MISO0
N     * |[8:9]   |PB4MFP    |Alternate Function Setting For PB4MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = PWM0CH0_INV(PWM0 channel 0 invert output pin)
N     * |        |          |10 = CMP4
N     * |        |          |11 = SPI_MOSI0
N     * |[10:11] |PB5MFP    |Alternate Function Setting For PB5MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = PWM0CH1_INV(PWM0 channel 1 invert output pin)
N     * |        |          |10 = CMP5
N     * |        |          |11 = SPI_MISO1
N     * |[12:13] |PB6MFP    |Alternate Function Setting For PB6MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2S_SDI
N     * |        |          |10 = CMP6
N     * |        |          |11 = SPI_MOSI1
N     * |[14:15] |PB7MFP    |Alternate Function Setting For PB7MFP
N     * |        |          |00 = GPIO
N     * |        |          |01 = I2S_SDO
N     * |        |          |10 = CMP7
N */
N    __IO uint32_t GPB_MFP;               
X    volatile uint32_t GPB_MFP;               
N         uint32_t RESERVE2[5];
N
N
N    /**
N     * WKCTL
N     * ===================================================================================================
N     * Offset: 0x54  WAKEUP pin control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKDIN     |State Of Wakeup Pin
N     * |        |          |Read only.
N     * |[1]     |WKPUEN    |Wakeup Pin Pull-up Control
N     * |        |          |This signal is latched in deep power down and preserved.
N     * |        |          |0 = pull-up enable
N     * |        |          |1 = tristate (default)
N     * |[2]     |WKOENB    |Wakeup Pin Output Enable Bar
N     * |        |          |0 = drive WKDOUT to pin
N     * |        |          |1 = tristate (default)
N     * |[3]     |WKDOUT    |Wakeup Output State
N     * |        |          |0 = drive Low if the corresponding output mode bit is set (default)
N     * |        |          |1 = drive High if the corresponding output mode bit is set
N */
N    __IO uint32_t WKCTL;                 
X    volatile uint32_t WKCTL;                 
N         uint32_t RESERVE3[42];
N
N
N    /**
N     * REGLCTL
N     * ===================================================================================================
N     * Offset: 0x100  Register Lock Key Address register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |REGLCTL   |Protected Register Unlock Register
N     * |        |          |0 = Protected registers are locked. Any write to the target register is ignored.
N     * |        |          |1 = Protected registers are unlocked
N */
N    __IO uint32_t REGLCTL;               
X    volatile uint32_t REGLCTL;               
N         uint32_t RESERVE4[3];
N
N
N    /**
N     * IRCTCTL
N     * ===================================================================================================
N     * Offset: 0x110  Oscillator Frequency Adjustment control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |FREQ0SEL  |8 Bit Trim For Oscillator
N     * |        |          |FREQ0SEL [7:5] are 8 coarse trim ranges which overlap in frequency.
N     * |        |          |FREQ0SEL [4:0] are 32 fine trim steps of approximately 0.5% resolution.
N     * |[8]     |RGE0SEL   |Range Bit For Oscillator
N     * |        |          |0 = high range
N     * |        |          |1 = low range
N     * |[16:23] |FREQ1SEL  |8 Bit Trim For Oscillator
N     * |        |          |FREQ1SEL [7:5] are 8 coarse trim ranges which overlap in frequency.
N     * |        |          |FREQ1SEL [4:0] are 32 fine trim steps of approximately 0.5% resolution.
N     * |[24]    |RGE1SEL   |Range Bit For Oscillator
N     * |        |          |0 = high range
N     * |        |          |1 = low range
N */
N    __IO uint32_t IRCTCTL;               
X    volatile uint32_t IRCTCTL;               
N
N} SYS_T;
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N#define SYS_RSTSTS_CORERSTF_Pos          (0)                                               /*!< SYS RSTSTS: CORERSTF Position          */
N#define SYS_RSTSTS_CORERSTF_Msk          (0x1ul << SYS_RSTSTS_CORERSTF_Pos)                /*!< SYS RSTSTS: CORERSTF Mask              */
N
N#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS RSTSTS: WDTRF Position             */
N#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS RSTSTS: WDTRF Mask                 */
N
N#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS RSTSTS: SYSRF Position             */
N#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS RSTSTS: SYSRF Mask                 */
N
N#define SYS_RSTSTS_PMURSTF_Pos           (6)                                               /*!< SYS RSTSTS: PMURSTF Position           */
N#define SYS_RSTSTS_PMURSTF_Msk           (0x1ul << SYS_RSTSTS_PMURSTF_Pos)                 /*!< SYS RSTSTS: PMURSTF Mask               */
N
N#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS RSTSTS: CPURF Position             */
N#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS RSTSTS: CPURF Mask                 */
N
N#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS IPRST0: CHIPRST Position           */
N#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS IPRST0: CHIPRST Mask               */
N
N#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS IPRST0: CPURST Position            */
N#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS IPRST0: CPURST Mask                */
N
N#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS IPRST0: PDMARST Position           */
N#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS IPRST0: PDMARST Mask               */
N
N#define SYS_IPRST1_TMR0RST_Pos           (6)                                               /*!< SYS IPRST1: TMR0RST Position           */
N#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS IPRST1: TMR0RST Mask               */
N
N#define SYS_IPRST1_TMR1RST_Pos           (7)                                               /*!< SYS IPRST1: TMR1RST Position           */
N#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS IPRST1: TMR1RST Mask               */
N
N#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS IPRST1: I2C0RST Position           */
N#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS IPRST1: I2C0RST Mask               */
N
N#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS IPRST1: SPI0RST Position           */
N#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS IPRST1: SPI0RST Mask               */
N
N#define SYS_IPRST1_DPWMRST_Pos           (13)                                              /*!< SYS IPRST1: DPWMRST Position           */
N#define SYS_IPRST1_DPWMRST_Msk           (0x1ul << SYS_IPRST1_DPWMRST_Pos)                 /*!< SYS IPRST1: DPWMRST Mask               */
N
N#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS IPRST1: UART0RST Position          */
N#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS IPRST1: UART0RST Mask              */
N
N#define SYS_IPRST1_BIQRST_Pos            (18)                                              /*!< SYS IPRST1: BIQRST Position            */
N#define SYS_IPRST1_BIQRST_Msk            (0x1ul << SYS_IPRST1_BIQRST_Pos)                  /*!< SYS IPRST1: BIQRST Mask                */
N
N#define SYS_IPRST1_CRCRST_Pos            (19)                                              /*!< SYS IPRST1: CRCRST Position            */
N#define SYS_IPRST1_CRCRST_Msk            (0x1ul << SYS_IPRST1_CRCRST_Pos)                  /*!< SYS IPRST1: CRCRST Mask                */
N
N#define SYS_IPRST1_PWM0RST_Pos           (20)                                              /*!< SYS IPRST1: PWM0RST Position           */
N#define SYS_IPRST1_PWM0RST_Msk           (0x1ul << SYS_IPRST1_PWM0RST_Pos)                 /*!< SYS IPRST1: PWM0RST Mask               */
N
N#define SYS_IPRST1_ACMPRST_Pos           (22)                                              /*!< SYS IPRST1: ACMPRST Position           */
N#define SYS_IPRST1_ACMPRST_Msk           (0x1ul << SYS_IPRST1_ACMPRST_Pos)                 /*!< SYS IPRST1: ACMPRST Mask               */
N
N#define SYS_IPRST1_EADCRST_Pos           (28)                                              /*!< SYS IPRST1: EADCRST Position           */
N#define SYS_IPRST1_EADCRST_Msk           (0x1ul << SYS_IPRST1_EADCRST_Pos)                 /*!< SYS IPRST1: EADCRST Mask               */
N
N#define SYS_IPRST1_I2S0RST_Pos           (29)                                              /*!< SYS IPRST1: I2S0RST Position           */
N#define SYS_IPRST1_I2S0RST_Msk           (0x1ul << SYS_IPRST1_I2S0RST_Pos)                 /*!< SYS IPRST1: I2S0RST Mask               */
N
N#define SYS_IPRST1_ANARST_Pos            (30)                                              /*!< SYS IPRST1: ANARST Position            */
N#define SYS_IPRST1_ANARST_Msk            (0x1ul << SYS_IPRST1_ANARST_Pos)                  /*!< SYS IPRST1: ANARST Mask                */
N
N#define SYS_PASMTEN_SMTEN16_Pos          (16)                                              /*!< SYS PASMTEN: SMTEN16 Position          */
N#define SYS_PASMTEN_SMTEN16_Msk          (0x1ul << SYS_PASMTEN_SMTEN16_Pos)                /*!< SYS PASMTEN: SMTEN16 Mask              */
N
N#define SYS_PASMTEN_SMTEN17_Pos          (17)                                              /*!< SYS PASMTEN: SMTEN17 Position          */
N#define SYS_PASMTEN_SMTEN17_Msk          (0x1ul << SYS_PASMTEN_SMTEN17_Pos)                /*!< SYS PASMTEN: SMTEN17 Mask              */
N
N#define SYS_PASMTEN_SMTEN18_Pos          (18)                                              /*!< SYS PASMTEN: SMTEN18 Position          */
N#define SYS_PASMTEN_SMTEN18_Msk          (0x1ul << SYS_PASMTEN_SMTEN18_Pos)                /*!< SYS PASMTEN: SMTEN18 Mask              */
N
N#define SYS_PASMTEN_SMTEN19_Pos          (19)                                              /*!< SYS PASMTEN: SMTEN19 Position          */
N#define SYS_PASMTEN_SMTEN19_Msk          (0x1ul << SYS_PASMTEN_SMTEN19_Pos)                /*!< SYS PASMTEN: SMTEN19 Mask              */
N
N#define SYS_PASMTEN_SMTEN20_Pos          (20)                                              /*!< SYS PASMTEN: SMTEN20 Position          */
N#define SYS_PASMTEN_SMTEN20_Msk          (0x1ul << SYS_PASMTEN_SMTEN20_Pos)                /*!< SYS PASMTEN: SMTEN20 Mask              */
N
N#define SYS_PASMTEN_SMTEN21_Pos          (21)                                              /*!< SYS PASMTEN: SMTEN21 Position          */
N#define SYS_PASMTEN_SMTEN21_Msk          (0x1ul << SYS_PASMTEN_SMTEN21_Pos)                /*!< SYS PASMTEN: SMTEN21 Mask              */
N
N#define SYS_PASMTEN_SMTEN22_Pos          (22)                                              /*!< SYS PASMTEN: SMTEN22 Position          */
N#define SYS_PASMTEN_SMTEN22_Msk          (0x1ul << SYS_PASMTEN_SMTEN22_Pos)                /*!< SYS PASMTEN: SMTEN22 Mask              */
N
N#define SYS_PASMTEN_SMTEN23_Pos          (23)                                              /*!< SYS PASMTEN: SMTEN23 Position          */
N#define SYS_PASMTEN_SMTEN23_Msk          (0x1ul << SYS_PASMTEN_SMTEN23_Pos)                /*!< SYS PASMTEN: SMTEN23 Mask              */
N
N#define SYS_PASMTEN_SMTEN24_Pos          (24)                                              /*!< SYS PASMTEN: SMTEN24 Position          */
N#define SYS_PASMTEN_SMTEN24_Msk          (0x1ul << SYS_PASMTEN_SMTEN24_Pos)                /*!< SYS PASMTEN: SMTEN24 Mask              */
N
N#define SYS_PASMTEN_SMTEN25_Pos          (25)                                              /*!< SYS PASMTEN: SMTEN25 Position          */
N#define SYS_PASMTEN_SMTEN25_Msk          (0x1ul << SYS_PASMTEN_SMTEN25_Pos)                /*!< SYS PASMTEN: SMTEN25 Mask              */
N
N#define SYS_PASMTEN_SMTEN26_Pos          (26)                                              /*!< SYS PASMTEN: SMTEN26 Position          */
N#define SYS_PASMTEN_SMTEN26_Msk          (0x1ul << SYS_PASMTEN_SMTEN26_Pos)                /*!< SYS PASMTEN: SMTEN26 Mask              */
N
N#define SYS_PASMTEN_SMTEN27_Pos          (27)                                              /*!< SYS PASMTEN: SMTEN27 Position          */
N#define SYS_PASMTEN_SMTEN27_Msk          (0x1ul << SYS_PASMTEN_SMTEN27_Pos)                /*!< SYS PASMTEN: SMTEN27 Mask              */
N
N#define SYS_PASMTEN_SMTEN28_Pos          (28)                                              /*!< SYS PASMTEN: SMTEN28 Position          */
N#define SYS_PASMTEN_SMTEN28_Msk          (0x1ul << SYS_PASMTEN_SMTEN28_Pos)                /*!< SYS PASMTEN: SMTEN28 Mask              */
N
N#define SYS_PASMTEN_SMTEN29_Pos          (29)                                              /*!< SYS PASMTEN: SMTEN29 Position          */
N#define SYS_PASMTEN_SMTEN29_Msk          (0x1ul << SYS_PASMTEN_SMTEN29_Pos)                /*!< SYS PASMTEN: SMTEN29 Mask              */
N
N#define SYS_PASMTEN_SMTEN30_Pos          (30)                                              /*!< SYS PASMTEN: SMTEN30 Position          */
N#define SYS_PASMTEN_SMTEN30_Msk          (0x1ul << SYS_PASMTEN_SMTEN30_Pos)                /*!< SYS PASMTEN: SMTEN30 Mask              */
N
N#define SYS_PASMTEN_SMTEN31_Pos          (31)                                              /*!< SYS PASMTEN: SMTEN31 Position          */
N#define SYS_PASMTEN_SMTEN31_Msk          (0x1ul << SYS_PASMTEN_SMTEN31_Pos)                /*!< SYS PASMTEN: SMTEN31 Mask              */
N
N#define SYS_PBSMTEN_SMTEN16_Pos          (16)                                              /*!< SYS PBSMTEN: SMTEN16 Position          */
N#define SYS_PBSMTEN_SMTEN16_Msk          (0x1ul << SYS_PBSMTEN_SMTEN16_Pos)                /*!< SYS PBSMTEN: SMTEN16 Mask              */
N
N#define SYS_PBSMTEN_SMTEN17_Pos          (17)                                              /*!< SYS PBSMTEN: SMTEN17 Position          */
N#define SYS_PBSMTEN_SMTEN17_Msk          (0x1ul << SYS_PBSMTEN_SMTEN17_Pos)                /*!< SYS PBSMTEN: SMTEN17 Mask              */
N
N#define SYS_PBSMTEN_SMTEN18_Pos          (18)                                              /*!< SYS PBSMTEN: SMTEN18 Position          */
N#define SYS_PBSMTEN_SMTEN18_Msk          (0x1ul << SYS_PBSMTEN_SMTEN18_Pos)                /*!< SYS PBSMTEN: SMTEN18 Mask              */
N
N#define SYS_PBSMTEN_SMTEN19_Pos          (19)                                              /*!< SYS PBSMTEN: SMTEN19 Position          */
N#define SYS_PBSMTEN_SMTEN19_Msk          (0x1ul << SYS_PBSMTEN_SMTEN19_Pos)                /*!< SYS PBSMTEN: SMTEN19 Mask              */
N
N#define SYS_PBSMTEN_SMTEN20_Pos          (20)                                              /*!< SYS PBSMTEN: SMTEN20 Position          */
N#define SYS_PBSMTEN_SMTEN20_Msk          (0x1ul << SYS_PBSMTEN_SMTEN20_Pos)                /*!< SYS PBSMTEN: SMTEN20 Mask              */
N
N#define SYS_PBSMTEN_SMTEN21_Pos          (21)                                              /*!< SYS PBSMTEN: SMTEN21 Position          */
N#define SYS_PBSMTEN_SMTEN21_Msk          (0x1ul << SYS_PBSMTEN_SMTEN21_Pos)                /*!< SYS PBSMTEN: SMTEN21 Mask              */
N
N#define SYS_PBSMTEN_SMTEN22_Pos          (22)                                              /*!< SYS PBSMTEN: SMTEN22 Position          */
N#define SYS_PBSMTEN_SMTEN22_Msk          (0x1ul << SYS_PBSMTEN_SMTEN22_Pos)                /*!< SYS PBSMTEN: SMTEN22 Mask              */
N
N#define SYS_PBSMTEN_SMTEN23_Pos          (23)                                              /*!< SYS PBSMTEN: SMTEN23 Position          */
N#define SYS_PBSMTEN_SMTEN23_Msk          (0x1ul << SYS_PBSMTEN_SMTEN23_Pos)                /*!< SYS PBSMTEN: SMTEN23 Mask              */
N
N#define SYS_GPA_MFP_PA0MFP_Pos           (0)                                               /*!< SYS GPA_MFP: PA0MFP Position           */
N#define SYS_GPA_MFP_PA0MFP_Msk           (0x3ul << SYS_GPA_MFP_PA0MFP_Pos)                 /*!< SYS GPA_MFP: PA0MFP Mask               */
N
N#define SYS_GPA_MFP_PA1MFP_Pos           (2)                                               /*!< SYS GPA_MFP: PA1MFP Position           */
N#define SYS_GPA_MFP_PA1MFP_Msk           (0x3ul << SYS_GPA_MFP_PA1MFP_Pos)                 /*!< SYS GPA_MFP: PA1MFP Mask               */
N
N#define SYS_GPA_MFP_PA2MFP_Pos           (4)                                               /*!< SYS GPA_MFP: PA2MFP Position           */
N#define SYS_GPA_MFP_PA2MFP_Msk           (0x3ul << SYS_GPA_MFP_PA2MFP_Pos)                 /*!< SYS GPA_MFP: PA2MFP Mask               */
N
N#define SYS_GPA_MFP_PA3MFP_Pos           (6)                                               /*!< SYS GPA_MFP: PA3MFP Position           */
N#define SYS_GPA_MFP_PA3MFP_Msk           (0x3ul << SYS_GPA_MFP_PA3MFP_Pos)                 /*!< SYS GPA_MFP: PA3MFP Mask               */
N
N#define SYS_GPA_MFP_PA4MFP_Pos           (8)                                               /*!< SYS GPA_MFP: PA4MFP Position           */
N#define SYS_GPA_MFP_PA4MFP_Msk           (0x3ul << SYS_GPA_MFP_PA4MFP_Pos)                 /*!< SYS GPA_MFP: PA4MFP Mask               */
N
N#define SYS_GPA_MFP_PA5MFP_Pos           (10)                                              /*!< SYS GPA_MFP: PA5MFP Position           */
N#define SYS_GPA_MFP_PA5MFP_Msk           (0x3ul << SYS_GPA_MFP_PA5MFP_Pos)                 /*!< SYS GPA_MFP: PA5MFP Mask               */
N
N#define SYS_GPA_MFP_PA6MFP_Pos           (12)                                              /*!< SYS GPA_MFP: PA6MFP Position           */
N#define SYS_GPA_MFP_PA6MFP_Msk           (0x3ul << SYS_GPA_MFP_PA6MFP_Pos)                 /*!< SYS GPA_MFP: PA6MFP Mask               */
N
N#define SYS_GPA_MFP_PA7MFP_Pos           (14)                                              /*!< SYS GPA_MFP: PA7MFP Position           */
N#define SYS_GPA_MFP_PA7MFP_Msk           (0x3ul << SYS_GPA_MFP_PA7MFP_Pos)                 /*!< SYS GPA_MFP: PA7MFP Mask               */
N
N#define SYS_GPA_MFP_PA8MFP_Pos           (16)                                              /*!< SYS GPA_MFP: PA8MFP Position           */
N#define SYS_GPA_MFP_PA8MFP_Msk           (0x3ul << SYS_GPA_MFP_PA8MFP_Pos)                 /*!< SYS GPA_MFP: PA8MFP Mask               */
N
N#define SYS_GPA_MFP_PA9MFP_Pos           (18)                                              /*!< SYS GPA_MFP: PA9MFP Position           */
N#define SYS_GPA_MFP_PA9MFP_Msk           (0x3ul << SYS_GPA_MFP_PA9MFP_Pos)                 /*!< SYS GPA_MFP: PA9MFP Mask               */
N
N#define SYS_GPA_MFP_PA10MFP_Pos          (20)                                              /*!< SYS GPA_MFP: PA10MFP Position          */
N#define SYS_GPA_MFP_PA10MFP_Msk          (0x3ul << SYS_GPA_MFP_PA10MFP_Pos)                /*!< SYS GPA_MFP: PA10MFP Mask              */
N
N#define SYS_GPA_MFP_PA11MFP_Pos          (22)                                              /*!< SYS GPA_MFP: PA11MFP Position          */
N#define SYS_GPA_MFP_PA11MFP_Msk          (0x3ul << SYS_GPA_MFP_PA11MFP_Pos)                /*!< SYS GPA_MFP: PA11MFP Mask              */
N
N#define SYS_GPA_MFP_PA12MFP_Pos          (24)                                              /*!< SYS GPA_MFP: PA12MFP Position          */
N#define SYS_GPA_MFP_PA12MFP_Msk          (0x3ul << SYS_GPA_MFP_PA12MFP_Pos)                /*!< SYS GPA_MFP: PA12MFP Mask              */
N
N#define SYS_GPA_MFP_PA13MFP_Pos          (26)                                              /*!< SYS GPA_MFP: PA13MFP Position          */
N#define SYS_GPA_MFP_PA13MFP_Msk          (0x3ul << SYS_GPA_MFP_PA13MFP_Pos)                /*!< SYS GPA_MFP: PA13MFP Mask              */
N
N#define SYS_GPA_MFP_PA14MFP_Pos          (28)                                              /*!< SYS GPA_MFP: PA14MFP Position          */
N#define SYS_GPA_MFP_PA14MFP_Msk          (0x3ul << SYS_GPA_MFP_PA14MFP_Pos)                /*!< SYS GPA_MFP: PA14MFP Mask              */
N
N#define SYS_GPA_MFP_PA15MFP_Pos          (30)                                              /*!< SYS GPA_MFP: PA15MFP Position          */
N#define SYS_GPA_MFP_PA15MFP_Msk          (0x3ul << SYS_GPA_MFP_PA15MFP_Pos)                /*!< SYS GPA_MFP: PA15MFP Mask              */
N
N#define SYS_GPB_MFP_PB0MFP_Pos           (0)                                               /*!< SYS GPB_MFP: PB0MFP Position           */
N#define SYS_GPB_MFP_PB0MFP_Msk           (0x3ul << SYS_GPB_MFP_PB0MFP_Pos)                 /*!< SYS GPB_MFP: PB0MFP Mask               */
N
N#define SYS_GPB_MFP_PB1MFP_Pos           (2)                                               /*!< SYS GPB_MFP: PB1MFP Position           */
N#define SYS_GPB_MFP_PB1MFP_Msk           (0x3ul << SYS_GPB_MFP_PB1MFP_Pos)                 /*!< SYS GPB_MFP: PB1MFP Mask               */
N
N#define SYS_GPB_MFP_PB2MFP_Pos           (4)                                               /*!< SYS GPB_MFP: PB2MFP Position           */
N#define SYS_GPB_MFP_PB2MFP_Msk           (0x3ul << SYS_GPB_MFP_PB2MFP_Pos)                 /*!< SYS GPB_MFP: PB2MFP Mask               */
N
N#define SYS_GPB_MFP_PB3MFP_Pos           (6)                                               /*!< SYS GPB_MFP: PB3MFP Position           */
N#define SYS_GPB_MFP_PB3MFP_Msk           (0x3ul << SYS_GPB_MFP_PB3MFP_Pos)                 /*!< SYS GPB_MFP: PB3MFP Mask               */
N
N#define SYS_GPB_MFP_PB4MFP_Pos           (8)                                               /*!< SYS GPB_MFP: PB4MFP Position           */
N#define SYS_GPB_MFP_PB4MFP_Msk           (0x3ul << SYS_GPB_MFP_PB4MFP_Pos)                 /*!< SYS GPB_MFP: PB4MFP Mask               */
N
N#define SYS_GPB_MFP_PB5MFP_Pos           (10)                                              /*!< SYS GPB_MFP: PB5MFP Position           */
N#define SYS_GPB_MFP_PB5MFP_Msk           (0x3ul << SYS_GPB_MFP_PB5MFP_Pos)                 /*!< SYS GPB_MFP: PB5MFP Mask               */
N
N#define SYS_GPB_MFP_PB6MFP_Pos           (12)                                              /*!< SYS GPB_MFP: PB6MFP Position           */
N#define SYS_GPB_MFP_PB6MFP_Msk           (0x3ul << SYS_GPB_MFP_PB6MFP_Pos)                 /*!< SYS GPB_MFP: PB6MFP Mask               */
N
N#define SYS_GPB_MFP_PB7MFP_Pos           (14)                                              /*!< SYS GPB_MFP: PB7MFP Position           */
N#define SYS_GPB_MFP_PB7MFP_Msk           (0x3ul << SYS_GPB_MFP_PB7MFP_Pos)                 /*!< SYS GPB_MFP: PB7MFP Mask               */
N
N#define SYS_WKCTL_WKDIN_Pos              (0)                                               /*!< SYS WKCTL: WKDIN Position              */
N#define SYS_WKCTL_WKDIN_Msk              (0x1ul << SYS_WKCTL_WKDIN_Pos)                    /*!< SYS WKCTL: WKDIN Mask                  */
N
N#define SYS_WKCTL_WKPUEN_Pos             (1)                                               /*!< SYS WKCTL: WKPUEN Position             */
N#define SYS_WKCTL_WKPUEN_Msk             (0x1ul << SYS_WKCTL_WKPUEN_Pos)                   /*!< SYS WKCTL: WKPUEN Mask                 */
N
N#define SYS_WKCTL_WKOENB_Pos             (2)                                               /*!< SYS WKCTL: WKOENB Position             */
N#define SYS_WKCTL_WKOENB_Msk             (0x1ul << SYS_WKCTL_WKOENB_Pos)                   /*!< SYS WKCTL: WKOENB Mask                 */
N
N#define SYS_WKCTL_WKDOUT_Pos             (3)                                               /*!< SYS WKCTL: WKDOUT Position             */
N#define SYS_WKCTL_WKDOUT_Msk             (0x1ul << SYS_WKCTL_WKDOUT_Pos)                   /*!< SYS WKCTL: WKDOUT Mask                 */
N
N#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS REGLCTL: REGLCTL Position          */
N#define SYS_REGLCTL_REGLCTL_Msk          (0x1ul << SYS_REGLCTL_REGLCTL_Pos)                /*!< SYS REGLCTL: REGLCTL Mask              */
N
N#define SYS_IRCTCTL_FREQ0SEL_Pos         (0)                                               /*!< SYS IRCTCTL: FREQ0SEL Position         */
N#define SYS_IRCTCTL_FREQ0SEL_Msk         (0xfful << SYS_IRCTCTL_FREQ0SEL_Pos)              /*!< SYS IRCTCTL: FREQ0SEL Mask             */
N
N#define SYS_IRCTCTL_RGE0SEL_Pos          (8)                                               /*!< SYS IRCTCTL: RGE0SEL Position          */
N#define SYS_IRCTCTL_RGE0SEL_Msk          (0x1ul << SYS_IRCTCTL_RGE0SEL_Pos)                /*!< SYS IRCTCTL: RGE0SEL Mask              */
N
N#define SYS_IRCTCTL_FREQ1SEL_Pos         (16)                                              /*!< SYS IRCTCTL: FREQ1SEL Position         */
N#define SYS_IRCTCTL_FREQ1SEL_Msk         (0xfful << SYS_IRCTCTL_FREQ1SEL_Pos)              /*!< SYS IRCTCTL: FREQ1SEL Mask             */
N
N#define SYS_IRCTCTL_RGE1SEL_Pos          (24)                                              /*!< SYS IRCTCTL: RGE1SEL Position          */
N#define SYS_IRCTCTL_RGE1SEL_Msk          (0x1ul << SYS_IRCTCTL_RGE1SEL_Pos)                /*!< SYS IRCTCTL: RGE1SEL Mask              */
N
N/**@}*/ /* SYS_CONST */
N/**@}*/ /* end of SYS register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TMR Timer Controller(TMR)
N    Memory Mapped Structure for TMR Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  Timer Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |PSC       |Pre-scale Counter
N     * |        |          |Clock input is divided by PSC+1 before it is fed to the counter. If PSC = 0, then there is no scaling.
N     * |[16]    |CNTDATEN  |Data Latch Enable
N     * |        |          |When CNTDATEN is set, TIMERx_CNT (Timer Data Register) will be updated continuously with the 24-bit up-counter value as the timer is counting.
N     * |        |          |1 = Timer Data Register update enable.
N     * |        |          |0 = Timer Data Register update disable. 
N     * |[25]    |ACTSTS    |Timer Active Status Bit (Read only)
N     * |        |          |This bit indicates the counter status of timer.
N     * |        |          |0 = Timer is not active.
N     * |        |          |1 = Timer is active.
N     * |[26]    |RSTCNT    |Counter Reset Bit
N     * |        |          |Set this bit will reset the timer counter, prescale and also force CNTEN to 0.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset Timer's prescale counter, internal 24-bit up-counter and CNTEN bit.
N     * |[27:28] |OPMODE    |Timer Operating Mode
N     * |        |          |0 = The timer is operating in the one-shot mode.
N     * |        |          |The associated interrupt signal is generated once (if INTEN is enabled) and CNTEN is automatically cleared by hardware.
N     * |        |          |1 = The timer is operating in the periodic mode.
N     * |        |          |The associated interrupt signal is generated periodically (if INTEN is enabled).
N     * |        |          |2 = Reserved.
N     * |        |          |3 = The timer is operating in continuous counting mode.
N     * |        |          |The associated interrupt signal is generated when CNT = CMPDAT (if INTEN is enabled); however, the 24-bit up-counter counts continuously without reset.
N     * |[29]    |INTEN     |Interrupt Enable Bit
N     * |        |          |0 = Disable TIMER Interrupt.
N     * |        |          |1 = Enable TIMER Interrupt.
N     * |        |          |If timer interrupt is enabled, the timer asserts its interrupt signal when the count is equal to TIMERx_CMP.
N     * |[30]    |CNTEN     |Counter Enable Bit
N     * |        |          |0 = Stops/Suspends counting
N     * |        |          |1 = Starts counting
N     * |        |          |Note1: Setting CNTEN = 1 enables 24-bit counter. It continues count from last value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (OPMODE = 00b) when the timer interrupt is generated (INTEN = 1b).
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N    /**
N     * CMP
N     * ===================================================================================================
N     * Offset: 0x04  Timer Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:24]  |CMPDAT    |Timer Comparison Value
N     * |        |          |CMPDAT is a 24-bit comparison register.
N     * |        |          |When the 24-bit up-counter is enabled and its value is equal to CMPDAT value, a Timer Interrupt is requested if the timer interrupt is enabled with TIMERx_CTL.INTEN = 1.
N     * |        |          |The CMPDAT value defines the timer cycle time.
N     * |        |          |Time out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT)
N     * |        |          |NOTE1: Never set CMPDAT to 0x000 or 0x001. Timer will not function correctly.
N     * |        |          |NOTE2: Regardless of CNTEN state, whenever a new value is written to this register, TIMER will restart counting using this new value and abort previous count.
N */
N    __IO uint32_t CMP;                   
X    volatile uint32_t CMP;                   
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x08  Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Timer Interrupt Flag
N     * |        |          |This bit indicates the interrupt status of Timer.
N     * |        |          |TIF bit is set by hardware when the 24-bit counter matches the timer comparison value (CMPDAT).
N     * |        |          |It is cleared by writing 1.
N */
N    __IO uint32_t INTSTS;                
X    volatile uint32_t INTSTS;                
N
N    /**
N     * CNT
N     * ===================================================================================================
N     * Offset: 0x0C  Timer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:23]  |CNT       |Timer Data Register
N     * |        |          |When TIMERx_CTL.CNTDATEN is set to 1, the internal 24-bit timer up-counter value will be latched into CNT.
N     * |        |          |User can read this register for the up-counter value.
N */
N    __IO uint32_t CNT;                   
X    volatile uint32_t CNT;                   
N
N} TMR_T;
N
N/**
N    @addtogroup TMR_CONST TMR Bit Field Definition
N    Constant Definitions for TMR Controller
N@{ */
N
N#define TMR_CTL_PSC_Pos                  (0)                                               /*!< TMR CTL: PSC Position                  */
N#define TMR_CTL_PSC_Msk                  (0xfful << TMR_CTL_PSC_Pos)                       /*!< TMR CTL: PSC Mask                      */
N
N#define TMR_CTL_CNTDATEN_Pos             (16)                                              /*!< TMR CTL: CNTDATEN Position             */
N#define TMR_CTL_CNTDATEN_Msk             (0x1ul << TMR_CTL_CNTDATEN_Pos)                   /*!< TMR CTL: CNTDATEN Mask                 */
N
N#define TMR_CTL_ACTSTS_Pos               (25)                                              /*!< TMR CTL: ACTSTS Position               */
N#define TMR_CTL_ACTSTS_Msk               (0x1ul << TMR_CTL_ACTSTS_Pos)                     /*!< TMR CTL: ACTSTS Mask                   */
N
N#define TMR_CTL_RSTCNT_Pos               (26)                                              /*!< TMR CTL: RSTCNT Position               */
N#define TMR_CTL_RSTCNT_Msk               (0x1ul << TMR_CTL_RSTCNT_Pos)                     /*!< TMR CTL: RSTCNT Mask                   */
N
N#define TMR_CTL_OPMODE_Pos               (27)                                              /*!< TMR CTL: OPMODE Position               */
N#define TMR_CTL_OPMODE_Msk               (0x3ul << TMR_CTL_OPMODE_Pos)                     /*!< TMR CTL: OPMODE Mask                   */
N
N#define TMR_CTL_INTEN_Pos                (29)                                              /*!< TMR CTL: INTEN Position                */
N#define TMR_CTL_INTEN_Msk                (0x1ul << TMR_CTL_INTEN_Pos)                      /*!< TMR CTL: INTEN Mask                    */
N
N#define TMR_CTL_CNTEN_Pos                (30)                                              /*!< TMR CTL: CNTEN Position                */
N#define TMR_CTL_CNTEN_Msk                (0x1ul << TMR_CTL_CNTEN_Pos)                      /*!< TMR CTL: CNTEN Mask                    */
N
N#define TMR_CMP_CMPDAT_Pos               (0)                                               /*!< TMR CMP: CMPDAT Position               */
N#define TMR_CMP_CMPDAT_Msk               (0x1fffffful << TMR_CMP_CMPDAT_Pos)               /*!< TMR CMP: CMPDAT Mask                   */
N
N#define TMR_INTSTS_TIF_Pos               (0)                                               /*!< TMR INTSTS: TIF Position               */
N#define TMR_INTSTS_TIF_Msk               (0x1ul << TMR_INTSTS_TIF_Pos)                     /*!< TMR INTSTS: TIF Mask                   */
N
N#define TMR_CNT_CNT_Pos                  (0)                                               /*!< TMR CNT: CNT Position                  */
N#define TMR_CNT_CNT_Msk                  (0xfffffful << TMR_CNT_CNT_Pos)                   /*!< TMR CNT: CNT Mask                      */
N
N/**@}*/ /* TMR_CONST */
N/**@}*/ /* end of TMR register group */
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x00  UART0 Receive/Transfer FIFO Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:7]   |DAT       |Receive FIFO Register
N     * |        |          |Reading this register will return data from the receive data FIFO.
N     * |        |          |By reading this register, the UART will return the 8-bit data received from Rx pin (LSB first).
N */
N    __IO uint32_t DAT;                   
X    volatile uint32_t DAT;                   
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x04  UART0 Interrupt Enable Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable.
N     * |        |          |0 = Mask off RDAINT
N     * |        |          |1 = Enable RDAINT
N     * |[1]     |THREIEN   |Transmit FIFO Register Empty Interrupt Enable
N     * |        |          |0 = Mask off THERINT
N     * |        |          |1 = Enable THERINT
N     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable
N     * |        |          |0 = Mask off RLSINT
N     * |        |          |1 = Enable RLSINT
N     * |[3]     |MODEMIEN  |Modem Status Interrupt Enable
N     * |        |          |0 = Mask off MODEMINT
N     * |        |          |1 = Enable MODEMINT
N     * |[4]     |RXTOIEN   |Receive Time out Interrupt Enable
N     * |        |          |0 = Mask off RXTOINT
N     * |        |          |1 = Enable RXTOINT
N     * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable
N     * |        |          |0 = Mask off BUFERRINT
N     * |        |          |1 = Enable IBUFERRINT
N     * |[8]     |LINIEN    |LIN RX Break Field Detected Interrupt Enable
N     * |        |          |0 = Mask off Lin bus Rx break field interrupt.
N     * |        |          |1 = Enable Lin bus Rx break field interrupt.
N     * |[11]    |TOCNTEN   |Time-Out Counter Enable
N     * |        |          |0 = Disable Time-out counter.
N     * |        |          |1 = Enable.
N     * |[12]    |ATORTSEN  |RTS Auto Flow Control Enable
N     * |        |          |0 = Disable RTS auto flow control.
N     * |        |          |1 = Enable.
N     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals UART_FIFO.RTSTRGLV, the UART will de-assert the RTS signal.
N     * |[13]    |ATOCTSEN  |CTS Auto Flow Control Enable
N     * |        |          |0 = Disable CTS auto flow control.
N     * |        |          |1 = Enable.
N     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input is asserted (UART will not send data to device until CTS is asserted).
N     * |[14]    |DMATXEN   |Transmit DMA Enable
N     * |        |          |If enabled, the UART will request DMA service when space is available in transmit FIFO.
N     * |[15]    |DMARXEN   |Receive DMA Enable
N     * |        |          |If enabled, the UART will request DMA service when data is available in receive FIFO. 
N */
N    __IO uint32_t INTEN;                 
X    volatile uint32_t INTEN;                 
N
N    /**
N     * FIFO
N     * ===================================================================================================
N     * Offset: 0x08  UART0 FIFO Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RXRST     |Receive FIFO Reset
N     * |        |          |When RXRST is set, all the bytes in the receive FIFO are cleared and receive internal state machine is reset.
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the receiving internal state machine and pointers.
N     * |        |          |Note: This bit will auto-clear after 3 UART engine clock cycles.
N     * |[2]     |TXRST     |Transmit FIFO Reset
N     * |        |          |When TXRST is set, all the bytes in the transmit FIFO are cleared and transmit internal state machine is reset.
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the transmitting internal state machine and pointers.
N     * |        |          |Note: This bit will auto-clear after 3 UART engine clock cycles.
N     * |[4:7]   |RFITL     |Receive FIFO Interrupt (RDAINT) Trigger Level
N     * |        |          |When the number of bytes in the receive FIFO equals the RFITL then the RDAIF will be set and, if enabled, an RDAINT interrupt will generated.
N     * |        |          |Value : INTR_RDA Trigger Level (Bytes)
N     * |        |          |0 : 1
N     * |        |          |1 : 4
N     * |        |          |2 : 8
N     * |[16:19] |RTSTRGLV  |RTS Trigger Level for Auto-flow Control
N     * |        |          |Sets the FIFO trigger level when auto-flow control will de-assert RTS (request-to-send).
N     * |        |          |Value : Trigger Level (Bytes)
N     * |        |          |0 : 1
N     * |        |          |1 : 4
N     * |        |          |2 : 8
N */
N    __IO uint32_t FIFO;                  
X    volatile uint32_t FIFO;                  
N
N    /**
N     * LINE
N     * ===================================================================================================
N     * Offset: 0x0C  UART0 Line Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:1]   |WLS       |Word Length Select
N     * |        |          |0 (5bits), 1(6bits), 2(7bits), 3(8bits)
N     * |[2]     |NSB       |Number of STOP bits
N     * |        |          |0= One "STOP bit" is generated after the transmitted data
N     * |        |          |1= Two "STOP bits" are generated when 6-, 7- and 8-bit word length is selected; One and a half "STOP bits" are generated in the transmitted data when 5-bit word length is selected
N     * |[3]     |PBE       |Parity Bit Enable
N     * |        |          |0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
N     * |        |          |1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
N     * |[4]     |EPE       |Even Parity Enable
N     * |        |          |0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
N     * |        |          |1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
N     * |        |          |This bit has effect only when PBE (parity bit enable) is set.
N     * |[5]     |SPE       |Stick Parity Enable
N     * |        |          |0 = Disable stick parity
N     * |        |          |1 = When bits PBE and SPE are set 'Stick Parity' is enabled.
N     * |        |          |If EPE=0 the parity bit is transmitted and checked as always set, if EPE=1, the parity bit is transmitted and checked as always cleared.
N     * |[6]     |BCB       |Break Control Bit
N     * |        |          |When this bit is set to logic 1, the serial data output (Tx) is forced to the 'Space' state (logic 0).
N     * |        |          |Normal condition is serial data output is 'Mark' state.
N     * |        |          |This bit acts only on Tx and has no effect on the transmitter logic.
N */
N    __IO uint32_t LINE;                  
X    volatile uint32_t LINE;                  
N
N    /**
N     * MODEM
N     * ===================================================================================================
N     * Offset: 0x10  UART0 Modem Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |RTS (Request-To-Send) Signal
N     * |        |          |If UART_INTEN.ATORTSEN = 0, this bit controls whether RTS pin is active or not.
N     * |        |          |0 = Drive RTS inactive ( = ~RTSACTLV).
N     * |        |          |1 = Drive RTS active ( = RTSACTLV).
N     * |[4]     |LBMEN     |Loopback Mode Enable
N     * |        |          |0=Disable
N     * |        |          |1=Enable
N     * |[9]     |RTSACTLV  |Request-to-Send (RTS) Active Trigger Level
N     * |        |          |This bit can change the RTS trigger level.
N     * |        |          |0= RTS is active low level.
N     * |        |          |1= RTS is active high level
N     * |[13]    |RTSSTS    |RTS Pin State (read only)
N     * |        |          |This bit is the pin status of RTS.
N */
N    __IO uint32_t MODEM;                 
X    volatile uint32_t MODEM;                 
N
N    /**
N     * MODEMSTS
N     * ===================================================================================================
N     * Offset: 0x14  UART0 Modem Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CTSDETF   |Detect CTS State Change Flag
N     * |        |          |This bit is set whenever CTS input has state change.
N     * |        |          |It will generate Modem interrupt to CPU when UART_INTEN.MODEMIEN = 1.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[4]     |CTSSTS    |CTS Pin Status (read only)
N     * |        |          |This bit is the pin status of CTS. 
N     * |[8]     |CTSACTLV  |Clear-to-Send (CTS) Active Trigger Level
N     * |        |          |This bit can change the CTS trigger level.
N     * |        |          |0= CTS is active low level.
N     * |        |          |1= CTS is active high level 
N */
N    __IO uint32_t MODEMSTS;              
X    volatile uint32_t MODEMSTS;              
N
N    /**
N     * FIFOSTS
N     * ===================================================================================================
N     * Offset: 0x18  UART0 FIFO Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXOVIF    |Rx Overflow Error Interrupt Flag
N     * |        |          |If the Rx FIFO ( UART_DAT) is full, and an additional byte is received by the UART, an overflow condition will occur and set this bit to logic 1.
N     * |        |          |It will also generate a BUFERRIF event and interrupt if enabled.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[4]     |PEF       |Parity Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
N     * |[5]     |FEF       |Framing Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
N     * |[6]     |BIF       |Break Interrupt Flag
N     * |        |          |This bit is set to a logic 1 whenever the receive data input (Rx) is held in the "space" state (logic 0) for longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits).
N     * |        |          |It is reset whenever the CPU writes 1 to this bit.
N     * |[8:13]  |RXPTR     |Rx FIFO pointer (Read Only)
N     * |        |          |This field returns the Rx FIFO buffer pointer.
N     * |        |          |It is the number of bytes available for read in the Rx FIFO.
N     * |        |          |When UART receives one byte from external device, RXPTR is incremented.
N     * |        |          |When one byte of Rx FIFO is read by CPU, RXPTR is decremented.
N     * |[14]    |RXEMPTY   |Receive FIFO Empty (Read Only)
N     * |        |          |This bit indicates whether the Rx FIFO is empty or not.
N     * |        |          |When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when UART receives any new data.
N     * |[15]    |RXFULL    |Receive FIFO Full (Read Only)
N     * |        |          |This bit indicates whether the Rx FIFO is full or not.
N     * |        |          |This bit is set when Rx FIFO is full; otherwise it is cleared by hardware.
N     * |[16:21] |TXPTR     |Tx FIFO Pointer (Read Only)
N     * |        |          |This field returns the Tx FIFO buffer pointer.
N     * |        |          |When CPU writes a byte into the Tx FIFO, TXPTR is incremented.
N     * |        |          |When a byte from Tx FIFO is transferred to the Transmit Shift Register, TXPTR is decremented.
N     * |[22]    |TXEMPTY   |Transmit FIFO Empty (Read Only)
N     * |        |          |This bit indicates whether the Tx FIFO is empty or not.
N     * |        |          |When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared after writing data to FIFO (Tx FIFO not empty).
N     * |[23]    |TXFULL    |Transmit FIFO Full (Read Only)
N     * |        |          |This bit indicates whether the Tx FIFO is full or not.
N     * |        |          |This bit is set when Tx FIFO is full; otherwise it is cleared by hardware.
N     * |        |          |TXFULL=0 indicates there is room to write more data to Tx FIFO.
N     * |[24]    |TXOVIF    |Tx Overflow Error Interrupt Flag
N     * |        |          |If the Tx FIFO ( UART_DAT) is full, an additional write to UART_DAT will cause an overflow condition and set this bit to logic 1.
N     * |        |          |It will also generate a BUFERRIF event and interrupt if enabled.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[28]    |TXEMPTYF  |Transmitter Empty (Read Only)
N     * |        |          |Bit is set by hardware when Tx FIFO is empty and the STOP bit of the last byte has been transmitted.
N     * |        |          |Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
N     * |        |          |NOTE: This bit is read only. 
N */
N    __IO uint32_t FIFOSTS;               
X    volatile uint32_t FIFOSTS;               
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x1C  UART0 Interrupt Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
N     * |        |          |When the number of bytes in the Rx FIFO equals UART_FIFO.RFITL then the RDAIF will be set.
N     * |        |          |If UART_INTEN.RDAIEN is enabled, the RDA interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).
N     * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register.
N     * |        |          |If UART_INTEN.THREIEN is enabled, the THRE interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and it will be cleared when writing data into the Tx FIFO.
N     * |[2]     |RLSIF     |Receive Line Status Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Rx receive data has a parity, framing or break error (at least one of, UART_FIFOSTS.BIF, UART_FIFOSTS.FEF and UART_FIFOSTS.PEF, is set).
N     * |        |          |If UART_INTEN.RLSIEN is enabled, the RLS interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
N     * |[3]     |MODENIF   |MODEM Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the CTS pin has changed state (UART_MODEMSTS.CTSDETF=1).
N     * |        |          |If UART_INTEN.MODEMIEN is enabled, a CPU interrupt request will be generated.
N     * |        |          |NOTE: This bit is read only and reset when bit UART_MODEMSTS.CTSDETF is cleared by a write 1.
N     * |[4]     |RXTOIF    |Time Out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Rx FIFO is not empty and no activity occurs in the Rx FIFO and the time out counter equal to TOIC.
N     * |        |          |If UART_INTEN.TOUT_IEN is enabled a CPU interrupt request will be generated.
N     * |        |          |NOTE: This bit is read only and user can read FIFO to clear it.
N     * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when either the Tx or Rx FIFO overflows (UART_FIFOSTS.TXOVIF or UART_FIFOSTS.RXOVIF is set).
N     * |        |          |When BUFERRIF is set, the serial transfer may be corrupted.
N     * |        |          |If UART_INTEN.BUFERRIEN is enabled a CPU interrupt request will be generated.
N     * |        |          |NOTE: This bit is cleared when both UART_FIFOSTS.TXOVIF and UART_FIFOSTS.RXOVIF are cleared. 
N     * |[7]     |LINIF     |LIN Bus Rx Break Field Detected Flag
N     * |        |          |This bit is set when LIN controller detects a break field. This bit is cleared by writing a 1.
N     * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.RDAIEN and RDAIF.
N     * |[9]     |THERINT   |Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.THREIEN and THREIF.
N     * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.RLSIEN and RLSIF.
N     * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator to Interrupt
N     * |        |          |Logical AND of UART_INTEN.MODEMIEN and MODENIF.
N     * |[12]    |RXTOINT   |Time Out Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.RXTOIEN and RXTOIF.
N     * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.BUFERRIEN and BUFERRIF.
N     * |[15]    |LININT    |LIN Bus Rx Break Field Detected Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.LINIEN and LINIF.
N     * |[18]    |DRLSIF    |DMA MODE Receive Line Status Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Rx receive data has a parity, framing or break error (at least one of, UART_FIFOSTS.BIF, UART_FIFOSTS.FEF and UART_FIFOSTS.PEF, is set).
N     * |        |          |If UART_INTEN.RLSIEN is enabled, the RLS interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
N     * |[19]    |DMODEMIF  |DMA MODE MODEM Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the CTS pin has changed state (UART_MODEMSTS.CTSDETF=1).
N     * |        |          |If UART_INTEN.MODEMIEN is enabled, a CPU interrupt request will be generated.
N     * |        |          |NOTE: This bit is read only and reset when bit UART_MODEMSTS.CTSDETF is cleared by a write 1.
N     * |[20]    |DRXTOIF   |DMA MODE Time Out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Rx FIFO is not empty and no activity occurs in the Rx FIFO and the time out counter equal to TOIC.
N     * |        |          |If UART_INTEN.TOUT_IEN is enabled a CPU interrupt request will be generated.
N     * |        |          |NOTE: This bit is read only and user can read FIFO to clear it.
N     * |[21]    |DBERRIF   |DMA MODE Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when either the Tx or Rx FIFO overflows (UART_FIFOSTS.TXOVIF or UART_FIFOSTS.RXOVIF is set).
N     * |        |          |When BUFERRIF is set, the serial transfer may be corrupted.
N     * |        |          |If UART_INTEN.BUFERRIEN is enabled a CPU interrupt request will be generated.
N     * |        |          |NOTE: This bit is cleared when both UART_FIFOSTS.TXOVIF and UART_FIFOSTS.RXOVIF are cleared. 
N     * |[23]    |DLINIF    |DMA MODE LIN Bus Rx Break Field Detected Flag
N     * |        |          |This bit is set when LIN controller detects a break field. This bit is cleared by writing a 1.
N     * |[26]    |DRLSINT   |DMA MODE Receive Line Status Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DRLSIF.
N     * |[27]    |DMODEMI   |DMA MODE MODEM Status Interrupt Indicator to Interrupt
N     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DMODENIF.
N     * |[28]    |DRXTOINT  |DMA MODE Time Out Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DRXTOIF.
N     * |[29]    |DBERRINT  |DMA MODE Buffer Error Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DBERRIF.
N     * |[31]    |DLININT   |DMA MODE LIN Bus Rx Break Field Detected Interrupt Indicator to Interrupt Controller
N     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DLINIF.
N */
N    __IO  uint32_t INTSTS;                
X    volatile  uint32_t INTSTS;                
N
N    /**
N     * TOUT
N     * ===================================================================================================
N     * Offset: 0x20  UART0 Time Out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:6]   |TOIC      |Time Out Interrupt Comparator
N     * |        |          |The time out counter resets and starts counting whenever the Rx FIFO receives a new data word.
N     * |        |          |Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (RXTOINT) is generated if UART_INTEN.RXTOIEN is set.
N     * |        |          |A new incoming data word or RX FIFO empty clears RXTOIF.
N     * |        |          |The period of the time out counter is the baud rate.
N */
N    __IO uint32_t TOUT;                  
X    volatile uint32_t TOUT;                  
N
N    /**
N     * BAUD
N     * ===================================================================================================
N     * Offset: 0x24  UART0 Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:15]  |BRD       |Baud Rate Divider
N     * |        |          |Refer to Table 5-111 for more information.
N     * |[24:27] |EDIVM1    |Divider X
N     * |        |          |The baud rate divider M = EDIVM1+1.
N     * |[28]    |BAUDM0    |Divider X equal 1
N     * |        |          |0: M = EDIVM1+1, with restriction EDIVM1 >= 8.
N     * |        |          |1: M = 1, with restriction BRD[15:0] >= 3.
N     * |        |          |Refer to Table 5-111 for more information.
N     * |[29]    |BAUDM1    |Divider X Enable
N     * |        |          |The baud rate equation is:
N     * |        |          |Baud Rate = UART_CLK / [ M * (BRD + 2) ] ; The default value of M is 16.
N     * |        |          |0 = Disable divider X ( M = 16)
N     * |        |          |1 = Enable divider X (M = EDIVM1+1, with EDIVM1 >= 8).
N     * |        |          |Refer to Table 5-111 for more information.
N     * |        |          |NOTE: When in IrDA mode, this bit must disabled.
N */
N    __IO uint32_t BAUD;                  
X    volatile uint32_t BAUD;                  
N
N    /**
N     * IRDA
N     * ===================================================================================================
N     * Offset: 0x28  UART0 IrDA Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXEN      |Transmit/Receive Selection
N     * |        |          |0=Enable IrDA receiver.
N     * |        |          |1= Enable IrDA transmitter.
N     * |[2]     |LOOPBACK  |IrDA Loopback Test Mode
N     * |        |          |Loopback Tx to Rx.
N     * |[5]     |TXINV     |Transmit inversion enable
N     * |        |          |0= No inversion
N     * |        |          |1= Invert Tx output signal
N     * |[6]     |RXINV     |Receive Inversion Enable
N     * |        |          |0= No inversion
N     * |        |          |1= Invert Rx input signal
N */
N    __IO uint32_t IRDA;                  
X    volatile uint32_t IRDA;                  
N
N    /**
N     * ALTCTL
N     * ===================================================================================================
N     * Offset: 0x2C  UART0 LIN Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0:3]   |BRKFL     |UART LIN Break Field Length Count
N     * |        |          |This field indicates a 4-bit LIN Tx break field count.
N     * |        |          |NOTE: This break field length is BRKFL + 2
N     * |[6]     |LINRXEN   |LIN RX Enable
N     * |        |          |0 = Disable LIN Rx mode.
N     * |        |          |1 = Enable LIN Rx mode.
N     * |[7]     |LINTXEN   |LIN TX Break Mode Enable
N     * |        |          |0 = Disable LIN Tx Break Mode.
N     * |        |          |1 = Enable LIN Tx Break Mode.
N     * |        |          |NOTE: When Tx break field transfer operation finished, this bit will be cleared automatically.
N */
N    __IO uint32_t ALTCTL;                
X    volatile uint32_t ALTCTL;                
N
N    /**
N     * FUNCSEL
N     * ===================================================================================================
N     * Offset: 0x30  UART0 Function Select Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LINEN     |Enable LIN Function
N     * |        |          |0 = UART Function.
N     * |        |          |1 = Enable LIN Function.
N     * |        |          |Note that IrDA and LIN functions are mutually exclusive: both cannot be active at same time.
N     * |[1]     |IRDAEN    |Enable IrDA Function
N     * |        |          |0 = UART Function.
N     * |        |          |1 = Enable IrDA Function.
N */
N    __IO uint32_t FUNCSEL;               
X    volatile uint32_t FUNCSEL;               
N
N} UART_T;
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART DAT: DAT Position                 */
N#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART DAT: DAT Mask                     */
N
N#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART INTEN: RDAIEN Position            */
N#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART INTEN: RDAIEN Mask                */
N
N#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART INTEN: THREIEN Position           */
N#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART INTEN: THREIEN Mask               */
N
N#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART INTEN: RLSIEN Position            */
N#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART INTEN: RLSIEN Mask                */
N
N#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART INTEN: MODEMIEN Position          */
N#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART INTEN: MODEMIEN Mask              */
N
N#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART INTEN: RXTOIEN Position           */
N#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART INTEN: RXTOIEN Mask               */
N
N#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART INTEN: BUFERRIEN Position         */
N#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART INTEN: BUFERRIEN Mask             */
N
N#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART INTEN: LINIEN Position            */
N#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART INTEN: LINIEN Mask                */
N
N#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART INTEN: TOCNTEN Position           */
N#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART INTEN: TOCNTEN Mask               */
N
N#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART INTEN: ATORTSEN Position          */
N#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART INTEN: ATORTSEN Mask              */
N
N#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART INTEN: ATOCTSEN Position          */
N#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART INTEN: ATOCTSEN Mask              */
N
N#define UART_INTEN_DMATXEN_Pos           (14)                                              /*!< UART INTEN: DMATXEN Position           */
N#define UART_INTEN_DMATXEN_Msk           (0x1ul << UART_INTEN_DMATXEN_Pos)                 /*!< UART INTEN: DMATXEN Mask               */
N
N#define UART_INTEN_DMARXEN_Pos           (15)                                              /*!< UART INTEN: DMARXEN Position           */
N#define UART_INTEN_DMARXEN_Msk           (0x1ul << UART_INTEN_DMARXEN_Pos)                 /*!< UART INTEN: DMARXEN Mask               */
N
N#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART FIFO: RXRST Position              */
N#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART FIFO: RXRST Mask                  */
N
N#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART FIFO: TXRST Position              */
N#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART FIFO: TXRST Mask                  */
N
N#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART FIFO: RFITL Position              */
N#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART FIFO: RFITL Mask                  */
N
N#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART FIFO: RTSTRGLV Position           */
N#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART FIFO: RTSTRGLV Mask               */
N
N#define UART_LINE_WLS_Pos                (0)                                               /*!< UART LINE: WLS Position                */
N#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART LINE: WLS Mask                    */
N
N#define UART_LINE_NSB_Pos                (2)                                               /*!< UART LINE: NSB Position                */
N#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART LINE: NSB Mask                    */
N
N#define UART_LINE_PBE_Pos                (3)                                               /*!< UART LINE: PBE Position                */
N#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART LINE: PBE Mask                    */
N
N#define UART_LINE_EPE_Pos                (4)                                               /*!< UART LINE: EPE Position                */
N#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART LINE: EPE Mask                    */
N
N#define UART_LINE_SPE_Pos                (5)                                               /*!< UART LINE: SPE Position                */
N#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART LINE: SPE Mask                    */
N
N#define UART_LINE_BCB_Pos                (6)                                               /*!< UART LINE: BCB Position                */
N#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART LINE: BCB Mask                    */
N
N#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART MODEM: RTS Position               */
N#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART MODEM: RTS Mask                   */
N
N#define UART_MODEM_LBMEN_Pos             (4)                                               /*!< UART MODEM: LBMEN Position             */
N#define UART_MODEM_LBMEN_Msk             (0x1ul << UART_MODEM_LBMEN_Pos)                   /*!< UART MODEM: LBMEN Mask                 */
N
N#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART MODEM: RTSACTLV Position          */
N#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART MODEM: RTSACTLV Mask              */
N
N#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART MODEM: RTSSTS Position            */
N#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART MODEM: RTSSTS Mask                */
N
N#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART MODEMSTS: CTSDETF Position        */
N#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART MODEMSTS: CTSDETF Mask            */
N
N#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART MODEMSTS: CTSSTS Position         */
N#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART MODEMSTS: CTSSTS Mask             */
N
N#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART MODEMSTS: CTSACTLV Position       */
N#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART MODEMSTS: CTSACTLV Mask           */
N
N#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART FIFOSTS: RXOVIF Position          */
N#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART FIFOSTS: RXOVIF Mask              */
N
N#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART FIFOSTS: PEF Position             */
N#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART FIFOSTS: PEF Mask                 */
N
N#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART FIFOSTS: FEF Position             */
N#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART FIFOSTS: FEF Mask                 */
N
N#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART FIFOSTS: BIF Position             */
N#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART FIFOSTS: BIF Mask                 */
N
N#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART FIFOSTS: RXPTR Position           */
N#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART FIFOSTS: RXPTR Mask               */
N
N#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART FIFOSTS: RXEMPTY Position         */
N#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART FIFOSTS: RXEMPTY Mask             */
N
N#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART FIFOSTS: RXFULL Position          */
N#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART FIFOSTS: RXFULL Mask              */
N
N#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART FIFOSTS: TXPTR Position           */
N#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART FIFOSTS: TXPTR Mask               */
N
N#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART FIFOSTS: TXEMPTY Position         */
N#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART FIFOSTS: TXEMPTY Mask             */
N
N#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART FIFOSTS: TXFULL Position          */
N#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART FIFOSTS: TXFULL Mask              */
N
N#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART FIFOSTS: TXOVIF Position          */
N#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART FIFOSTS: TXOVIF Mask              */
N
N#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART FIFOSTS: TXEMPTYF Position        */
N#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART FIFOSTS: TXEMPTYF Mask            */
N
N#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART INTSTS: RDAIF Position            */
N#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART INTSTS: RDAIF Mask                */
N
N#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART INTSTS: THREIF Position           */
N#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART INTSTS: THREIF Mask               */
N
N#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART INTSTS: RLSIF Position            */
N#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART INTSTS: RLSIF Mask                */
N
N#define UART_INTSTS_MODENIF_Pos          (3)                                               /*!< UART INTSTS: MODENIF Position          */
N#define UART_INTSTS_MODENIF_Msk          (0x1ul << UART_INTSTS_MODENIF_Pos)                /*!< UART INTSTS: MODENIF Mask              */
N
N#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART INTSTS: RXTOIF Position           */
N#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART INTSTS: RXTOIF Mask               */
N
N#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART INTSTS: BUFERRIF Position         */
N#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART INTSTS: BUFERRIF Mask             */
N
N#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART INTSTS: LINIF Position            */
N#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART INTSTS: LINIF Mask                */
N
N#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART INTSTS: RDAINT Position           */
N#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART INTSTS: RDAINT Mask               */
N
N#define UART_INTSTS_THERINT_Pos          (9)                                               /*!< UART INTSTS: THERINT Position          */
N#define UART_INTSTS_THERINT_Msk          (0x1ul << UART_INTSTS_THERINT_Pos)                /*!< UART INTSTS: THERINT Mask              */
N
N#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART INTSTS: RLSINT Position           */
N#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART INTSTS: RLSINT Mask               */
N
N#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART INTSTS: MODEMINT Position         */
N#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART INTSTS: MODEMINT Mask             */
N
N#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART INTSTS: RXTOINT Position          */
N#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART INTSTS: RXTOINT Mask              */
N
N#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART INTSTS: BUFERRINT Position        */
N#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART INTSTS: BUFERRINT Mask            */
N
N#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART INTSTS: LININT Position           */
N#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART INTSTS: LININT Mask               */
N
N#define UART_INTSTS_DRLSIF_Pos           (18)                                              /*!< UART INTSTS: DRLSIF Position           */
N#define UART_INTSTS_DRLSIF_Msk           (0x1ul << UART_INTSTS_DRLSIF_Pos)                 /*!< UART INTSTS: DRLSIF Mask               */
N
N#define UART_INTSTS_DMODEMIF_Pos         (19)                                              /*!< UART INTSTS: DMODEMIF Position         */
N#define UART_INTSTS_DMODEMIF_Msk         (0x1ul << UART_INTSTS_DMODEMIF_Pos)               /*!< UART INTSTS: DMODEMIF Mask             */
N
N#define UART_INTSTS_DRXTOIF_Pos          (20)                                              /*!< UART INTSTS: DRXTOIF Position          */
N#define UART_INTSTS_DRXTOIF_Msk          (0x1ul << UART_INTSTS_DRXTOIF_Pos)                /*!< UART INTSTS: DRXTOIF Mask              */
N
N#define UART_INTSTS_DBERRIF_Pos          (21)                                              /*!< UART INTSTS: DBERRIF Position          */
N#define UART_INTSTS_DBERRIF_Msk          (0x1ul << UART_INTSTS_DBERRIF_Pos)                /*!< UART INTSTS: DBERRIF Mask              */
N
N#define UART_INTSTS_DLINIF_Pos           (23)                                              /*!< UART INTSTS: DLINIF Position           */
N#define UART_INTSTS_DLINIF_Msk           (0x1ul << UART_INTSTS_DLINIF_Pos)                 /*!< UART INTSTS: DLINIF Mask               */
N
N#define UART_INTSTS_DRLSINT_Pos          (26)                                              /*!< UART INTSTS: DRLSINT Position          */
N#define UART_INTSTS_DRLSINT_Msk          (0x1ul << UART_INTSTS_DRLSINT_Pos)                /*!< UART INTSTS: DRLSINT Mask              */
N
N#define UART_INTSTS_DMODEMI_Pos          (27)                                              /*!< UART INTSTS: DMODEMI Position          */
N#define UART_INTSTS_DMODEMI_Msk          (0x1ul << UART_INTSTS_DMODEMI_Pos)                /*!< UART INTSTS: DMODEMI Mask              */
N
N#define UART_INTSTS_DRXTOINT_Pos         (28)                                              /*!< UART INTSTS: DRXTOINT Position         */
N#define UART_INTSTS_DRXTOINT_Msk         (0x1ul << UART_INTSTS_DRXTOINT_Pos)               /*!< UART INTSTS: DRXTOINT Mask             */
N
N#define UART_INTSTS_DBERRINT_Pos         (29)                                              /*!< UART INTSTS: DBERRINT Position         */
N#define UART_INTSTS_DBERRINT_Msk         (0x1ul << UART_INTSTS_DBERRINT_Pos)               /*!< UART INTSTS: DBERRINT Mask             */
N
N#define UART_INTSTS_DLININT_Pos          (31)                                              /*!< UART INTSTS: DLININT Position          */
N#define UART_INTSTS_DLININT_Msk          (0x1ul << UART_INTSTS_DLININT_Pos)                /*!< UART INTSTS: DLININT Mask              */
N
N#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART TOUT: TOIC Position               */
N#define UART_TOUT_TOIC_Msk               (0x7ful << UART_TOUT_TOIC_Pos)                    /*!< UART TOUT: TOIC Mask                   */
N
N#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART BAUD: BRD Position                */
N#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART BAUD: BRD Mask                    */
N
N#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART BAUD: EDIVM1 Position             */
N#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART BAUD: EDIVM1 Mask                 */
N
N#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART BAUD: BAUDM0 Position             */
N#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART BAUD: BAUDM0 Mask                 */
N
N#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART BAUD: BAUDM1 Position             */
N#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART BAUD: BAUDM1 Mask                 */
N
N#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART IRDA: TXEN Position               */
N#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART IRDA: TXEN Mask                   */
N
N#define UART_IRDA_LOOPBACK_Pos           (2)                                               /*!< UART IRDA: LOOPBACK Position           */
N#define UART_IRDA_LOOPBACK_Msk           (0x1ul << UART_IRDA_LOOPBACK_Pos)                 /*!< UART IRDA: LOOPBACK Mask               */
N
N#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART IRDA: TXINV Position              */
N#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART IRDA: TXINV Mask                  */
N
N#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART IRDA: RXINV Position              */
N#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART IRDA: RXINV Mask                  */
N
N#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART ALTCTL: BRKFL Position            */
N#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART ALTCTL: BRKFL Mask                */
N
N#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART ALTCTL: LINRXEN Position          */
N#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART ALTCTL: LINRXEN Mask              */
N
N#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART ALTCTL: LINTXEN Position          */
N#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART ALTCTL: LINTXEN Mask              */
N
N#define UART_FUNCSEL_LINEN_Pos           (0)                                               /*!< UART FUNCSEL: LINEN Position           */
N#define UART_FUNCSEL_LINEN_Msk           (0x1ul << UART_FUNCSEL_LINEN_Pos)                 /*!< UART FUNCSEL: LINEN Mask               */
N
N#define UART_FUNCSEL_IRDAEN_Pos          (1)                                               /*!< UART FUNCSEL: IRDAEN Position          */
N#define UART_FUNCSEL_IRDAEN_Msk          (0x1ul << UART_FUNCSEL_IRDAEN_Pos)                /*!< UART FUNCSEL: IRDAEN Mask              */
N
N/**@}*/ /* UART_CONST */
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N 
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RSTCNT    |Clear Watchdog Timer
N     * |        |          |Set this bit will clear the Watchdog timer.
N     * |        |          |0 = Writing 0 to this bit has no effect
N     * |        |          |1 = Reset the contents of the Watchdog timer
N     * |        |          |NOTE: This bit will auto clear after few clock cycle
N     * |[1]     |RSTEN     |Watchdog Timer Reset Enable
N     * |        |          |Setting this bit will enable the Watchdog timer reset function.
N     * |        |          |0 = Disable Watchdog timer reset function
N     * |        |          |1= Enable Watchdog timer reset function
N     * |[2]     |RSTF      |Watchdog Timer Reset Flag
N     * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit.
N     * |        |          |This flag can be read by software to determine the source of reset.
N     * |        |          |Software is responsible to clear it manually by writing 1 to it.
N     * |        |          |If RSTEN is disabled, then the Watchdog timer has no effect on this bit.
N     * |        |          |0 = Watchdog timer reset has not occurred.
N     * |        |          |1= Watchdog timer reset has occurred.
N     * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
N     * |[3]     |IF        |Watchdog Timer Interrupt Flag
N     * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred.
N     * |        |          |If the Watchdog timer interrupt is not enabled, then this bit indicates that a timeout period has elapsed.
N     * |        |          |0 = Watchdog timer interrupt has not occurred.
N     * |        |          |1 = Watchdog timer interrupt has occurred.
N     * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
N     * |[6]     |INTEN     |Watchdog Timer Interrupt Enable
N     * |        |          |0 = Disable the Watchdog timer interrupt
N     * |        |          |1 = Enable the Watchdog timer interrupt
N     * |[7]     |WDTEN     |Watchdog Timer Enable
N     * |        |          |0 = Disable the Watchdog timer (This action will reset the internal counter)
N     * |        |          |1 = Enable the Watchdog timer
N     * |[8:10]  |TOUTSEL   |Watchdog Timer Interval Select
N     * |        |          |These three bits select the timeout interval for the Watchdog timer, a watchdog reset will occur 1024 clock cycles later if WDG not reset.
N     * |        |          |The timeout is given by:.
N     * |        |          |Interrupt Timeout = 2^(2xWTIS+4) x WDT_CLK
N     * |        |          |Reset Timeout = (2^(2xWTIS+4) +1024) x WDT_CLK
N     * |        |          |Where WDT_CLK is the period of the Watchdog Timer clock source.
N */
N    __IO uint32_t CTL;                   
X    volatile uint32_t CTL;                   
N
N} WDT_T;
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT CTL: RSTCNT Position               */
N#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT CTL: RSTCNT Mask                   */
N
N#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT CTL: RSTEN Position                */
N#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT CTL: RSTEN Mask                    */
N
N#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT CTL: RSTF Position                 */
N#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT CTL: RSTF Mask                     */
N
N#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT CTL: IF Position                   */
N#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT CTL: IF Mask                       */
N
N#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT CTL: INTEN Position                */
N#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT CTL: INTEN Mask                    */
N
N#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT CTL: WDTEN Position                */
N#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT CTL: WDTEN Mask                    */
N
N#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT CTL: TOUTSEL Position              */
N#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT CTL: TOUTSEL Mask                  */
N
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* end of WDT register group */
N
N/**@}*/ /* end of SBRAM register group */
Ntypedef struct
N{
N    __IO uint32_t	D[64];
X    volatile uint32_t	D[64];
N} SBRAM_T;
N/**@}*/ /* end of REGISTER group */
N
N
N/**@}*/ /* end of REGISTER group */
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup ISD9100_PERIPHERAL_MEM_MAP ISD9100 Peripheral Memory Map
N  Memory Mapped Structure for ISD9100 Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N
N/* Peripheral memory map */
N
N#define WDT_BASE       	     (APB1_BASE      + 0x04000)
N#define RTC_BASE             (APB1_BASE      + 0x08000)
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)
N#define I2C0_BASE            (APB1_BASE      + 0x20000)
N#define SPI0_BASE            (APB1_BASE      + 0x30000)
N#define PWM0_BASE            (APB1_BASE      + 0x40000)
N#define UART0_BASE           (APB1_BASE      + 0x50000)
N#define DPWM_BASE            (APB1_BASE      + 0x70000)
N#define ANA_BASE             (APB1_BASE      + 0x80000)
N#define BODTALM_BASE         (APB1_BASE      + 0x84000)
N#define CRC_BASE             (APB1_BASE      + 0x90000)
N#define I2S0_BASE            (APB1_BASE      + 0xA0000)
N#define BIQ_BASE             (APB1_BASE      + 0xB0000)
N#define ALC_BASE             (APB1_BASE      + 0xB0048)
N#define ACMP_BASE            (APB1_BASE      + 0xD0000)
N#define ADC_BASE             (APB1_BASE      + 0xE0000)
N#define SBRAM_BASE           (APB1_BASE      + 0xF0000)
N
N#define SYS_BASE             (AHB_BASE       + 0x00000)
N#define CLK_BASE             (AHB_BASE       + 0x00200)
N#define INT_BASE             (AHB_BASE       + 0x00300)
N#define GPIO_BASE            (AHB_BASE       + 0x04000)
N#define GPIOA_BASE           (GPIO_BASE               )
N#define GPIOB_BASE           (GPIO_BASE      + 0x00040)
N#define GPIO_DBNCECON_BASE   (GPIO_BASE      + 0x00180)
N
N#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
N#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
N#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
N#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
N
N#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Grobal Base Address                         */
N
N
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)
N
N/*@}*/ /* end of group ISD9100_PERIPHERAL_MEM_MAP */
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N/** @addtogroup ISD9100_PeripheralDecl ISD9100 Peripheral Declaration
N    @{
N*/
N#define PA                  ((GPIO_T *) GPIOA_BASE)
N#define PB                  ((GPIO_T *) GPIOB_BASE)
N#define GPIO                ((GPIO_DB_T *) GPIO_DBNCECON_BASE)
N
N#define UART0               ((UART_T *) UART0_BASE)
N#define DPWM                ((DPWM_T *) DPWM_BASE)
N
N#define TIMER0              ((TMR_T *) TIMER0_BASE)
N#define TIMER1              ((TMR_T *) TIMER1_BASE)
N
N#define WDT                 ((WDT_T *) WDT_BASE)
N
N#define SPI0                ((SPI_T *) SPI0_BASE)
N
N#define I2C0                ((I2C_T *) I2C0_BASE)
N
N#define I2S0                ((I2S_T *) I2S0_BASE)
N
N#define RTC                 ((RTC_T *) RTC_BASE)
N
N#define ADC                 ((ADC_T*) ADC_BASE)
N
N#define ACMP                ((ACMP_T *) ACMP_BASE)
N#define ANA					((ANA_T *) ANA_BASE)
N#define BODTALM             ((BODTALM_T *) BODTALM_BASE)
N
N#define BIQ                 ((BIQ_T *) BIQ_BASE)
N#define ALC                 ((ALC_T *) ALC_BASE)
N#define SBRAM				((SBRAM_T *) SBRAM_BASE)
N
N#define CLK                 ((CLK_T *) CLK_BASE)
N#define SYS                 ((SYS_T *) SYS_BASE)
N
N#define FMC                 ((FMC_T *) FMC_BASE)
N
N#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
N#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
N#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
N#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
N
N#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
N
N#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
N
N#define PWM0                ((PWM_T *) PWM0_BASE)
N
N/*@}*/ /* end of group ISD9100_PeripheralDecl */
N
N#define UNLOCKREG(x)        do{*((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(SYS_BASE + 0x100))==0)
N#define LOCKREG(x)          *((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x00
N
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
N
N//=============================================================================
N/** @addtogroup ISD9100_IO_ROUTINE ISD9100 I/O routines
N  The Declaration of ISD9100 I/O routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N/*@}*/ /* end of group ISD9100_IO_ROUTINE */
N
N
N
N
N/** @addtogroup ISD9100_legacy_Constants ISD9100 Legacy Constants
N  ISD9100 Legacy Constants
N  @{
N*/
N
N
N#define E_SUCCESS   0
N#ifndef NULL
N#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE     1
N#define DISABLE    0
N
N/* Define one bit mask */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group ISD9100_legacy_Constants */
N
N/*@}*/ /* end of group ISD9100_Definitions */
N
N#define __ISD9100_SERIES__  (0x91000000)
N#define __CHIP_SERIES__     __ISD9100_SERIES__
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "acmp.h"
L 1 "..\..\..\..\Library\StdDriver\inc\acmp.h" 1
N/**************************************************************************//**
N * @file     ACMP.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/04 16:25p $
N * @brief    ISD9100 Series ACMP Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_ACMP_Driver ACMP Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/  
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP CTL0 And CTL1 Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define ACMP_CMP0VNEG_VBG    (0x0ul << ACMP_CTL0_NEGSEL_Pos)       /*!<CMP0 Negative Input Selects VBG 1.2V */
N#define ACMP_CMP0VNEG_VMID   (0x1ul << ACMP_CTL0_NEGSEL_Pos)       /*!<CMP0 Negative Input Selects VMID  */
N
N#define ACMP_CMP1VNEG_GPB7   (0x0ul << ACMP_CTL1_NEGSEL_Pos)       /*!<CMP1 Negative Input Selects GPIOB[7] */
N#define ACMP_CMP1VNEG_VBG    (0x1ul << ACMP_CTL1_NEGSEL_Pos)       /*!<CMP1 Negative Input Selects VBG 1.2V */
N
N#define ACMP_CH0_POSPIN_GPB0  (0)          /*!<CMP0 Positive Input Selects GPB0 */  
N#define ACMP_CH0_POSPIN_GPB1  (1)          /*!<CMP0 Positive Input Selects GPB1 */ 
N#define ACMP_CH0_POSPIN_GPB2  (2)          /*!<CMP0 Positive Input Selects GPB2 */ 
N#define ACMP_CH0_POSPIN_GPB3  (3)          /*!<CMP0 Positive Input Selects GPB3 */ 
N#define ACMP_CH0_POSPIN_GPB4  (4)          /*!<CMP0 Positive Input Selects GPB4 */ 
N#define ACMP_CH0_POSPIN_GPB5  (5)          /*!<CMP0 Positive Input Selects GPB5 */ 
N#define ACMP_CH0_POSPIN_GPB6  (6)          /*!<CMP0 Positive Input Selects GPB6 */ 
N#define ACMP_CH0_POSPIN_GPB7  (7)          /*!<CMP0 Positive Input Selects GPB7 */ 
N
N/*@}*/ /* end of group ISD9100_ACMP_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/**
N  * @brief     This macro is used to select ACMP negative input source
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @param[in] Src is comparator negative input selection source
N  *            - \ref ACMP_CMP0VNEG_VBG
N  *            - \ref ACMP_CMP0VNEG_VMID
N  *            - \ref ACMP_CMP1VNEG_GPB7
N  *            - \ref ACMP_CMP1VNEG_VBG
N  * @note      VMID block must be powered up if using VMID, programmer can 
N  *            call ADC_ENABLE_VMID macro to enable VMID.
N  */
N#define ACMP_SET_NEG_SRC(acmp, Ch, Src)  (acmp->CTL##Ch |= Src)
N
N/**
N  * @brief     This macro is used to enable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return    None
N  */
N#define ACMP_ENABLE_INT(acmp, Ch) (acmp->CTL##Ch |= ACMP_CTL##Ch##_NEGSEL_Msk)
N
N/**
N  * @brief     This macro is used to disable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return None
N  */
N#define ACMP_DISABLE_INT(acmp, Ch) (acmp->CTL##Ch &= ~ACMP_CTL##Ch##_NEGSEL_Msk)
N
N/**
N  * @brief     This macro is used to enable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return None
N  */
N#define ACMP_ENABLE(acmp, Ch) (acmp->CTL##Ch |= ACMP_CTL##Ch##_ACMPEN_Msk)
N
N/**
N  * @brief     This macro is used to disable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return None
N  */
N#define ACMP_DISABLE(acmp, Ch) (acmp->CTL##Ch &= ~ACMP_CTL##Ch##_ACMPEN_Msk)
N
N/**
N  * @brief     This macro is used to get ACMP output value
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return    1 or 0
N  */
N#define ACMP_GET_OUTPUT(acmp, Ch) ((acmp->STATUS & ACMP_STATUS_ACMPO##Ch_Msk)?1:0)
N
N/**
N  * @brief     This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return    ACMP interrupt occurred or not
N  */
N#define ACMP_GET_INT_FLAG(acmp, Ch) ((acmp->STATUS & ACMP_STATUS_ACMPIF##Ch_Msk)?1:0)
N
N/**
N  * @brief     This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] Ch is ACMP number, could 0 or 1.
N  * @return    None
N  */
N#define ACMP_CLR_INT_FLAG(acmp, Ch) (acmp->STATUS |= ACMP_STATUS_ACMPIF##Ch_Msk)
N
N/**
N  * @brief     This macro is used to select the V+ pin of ACMP only for CMP0
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32Pin CMP0 positive input pin
N  *            - \ref ACMP_CH0_POSPIN_GPB0
N  *            - \ref ACMP_CH0_POSPIN_GPB1
N  *            - \ref ACMP_CH0_POSPIN_GPB2
N  *            - \ref ACMP_CH0_POSPIN_GPB3
N  *            - \ref ACMP_CH0_POSPIN_GPB4
N  *            - \ref ACMP_CH0_POSPIN_GPB5
N  *            - \ref ACMP_CH0_POSPIN_GPB6
N  *            - \ref ACMP_CH0_POSPIN_GPB7
N  * @return    None
N  * @note      Multi-function pin needs to be configured and set as input mode        
N  */
N#define ACMP_CH0SELECT_P(acmp, u32Pin)  (acmp->POSSEL = u32Pin)
N
Nvoid ACMP_Open(ACMP_T *acmp, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32PosPin);
Nvoid ACMP_Close(ACMP_T *acmp, uint32_t u32ChNum);
N
N
N/*@}*/ /* end of group ISD9100_ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_ACMP_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 9147 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "adc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 14/06/20 13:27p $
N * @brief    ISD9100 Series ADC Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/  
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Over-sampling Ratio Of The Decimation Filter Constant Definitions                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_OSR_RATION_64   0       /*!< ADC 64 ration over-sampling            */
N#define ADC_OSR_RATION_128  1       /*!< ADC 128 ration over-sampling           */
N#define ADC_OSR_RATION_192  2       /*!< ADC 192 ration over-sampling           */
N#define ADC_OSR_RATION_384  3       /*!< ADC 384 ration over-sampling           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC And ALC Interrupt Flag Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_FIFO_INT        (1)             /*!< ADC FIFO level interrupt enable flag   */
N#define ADC_CMP0_INT        (2)             /*!< ADC compared 0 interrupt enable flag   */
N#define ADC_CMP1_INT        (4)             /*!< ADC compared 1 interrupt enable flag   */
N#define ADC_ALC_INT         (8)             /*!< ALC interrupt enable flag   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC ADCMPR Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0UL << 2)           /*!< The compare condition is "less than"          */
N#define ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL   (1UL << 2)           /*!< The compare condition is "greater than or equal to" */
N#define ADC_ADCMPR_CMPEN_DISABLE    (0UL << 0)            /*!< The compare function disable */
N#define ADC_ADCMPR_CMPEN_ENABLE     (1UL << 0)            /*!< The compare function enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* VMID Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_VMID_HIRES_CONNECT      (0x0ul << ANA_VMID_PDHIRES_Pos)     /*!< Connect the High Resistance reference to VMID */
N#define ADC_VMID_HIRES_DISCONNECT   (0x1ul << ANA_VMID_PDHIRES_Pos)     /*!< The High Resistance reference is disconnected from VMID */
N#define ADC_VMID_LORES_CONNECT      (0x0ul << ANA_VMID_PDLORES_Pos)     /*!< Connect the Low Resistance reference to VMID */
N#define ADC_VMID_LORES_DISCONNECT   (0x1ul << ANA_VMID_PDLORES_Pos)     /*!< The Low Resistance reference is disconnected from VMID */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* MICBSEL constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_MICBSEL_90_VCCA         ((0x0ul << ANA_MICBSEL_REFSEL_Pos)|0x0)   /*!< Microphone bias voltage is 90% VCCA  */
N#define ADC_MICBSEL_65_VCCA         ((0x0ul << ANA_MICBSEL_REFSEL_Pos)|0x1)   /*!< Microphone bias voltage is 65% VCCA  */
N#define ADC_MICBSEL_75_VCCA         ((0x0ul << ANA_MICBSEL_REFSEL_Pos)|0x2)   /*!< Microphone bias voltage is 75% VCCA  */
N#define ADC_MICBSEL_50_VCCA         ((0x0ul << ANA_MICBSEL_REFSEL_Pos)|0x3)   /*!< Microphone bias voltage is 50% VCCA  */
N#define ADC_MICBSEL_24V          ((0x1ul << ANA_MICBSEL_REFSEL_Pos)|0x0)   /*!< Microphone bias voltage is 2.4V VBG   */
N#define ADC_MICBSEL_17V          ((0x1ul << ANA_MICBSEL_REFSEL_Pos)|0x1)   /*!< Microphone bias voltage is 1.7V VBG   */
N#define ADC_MICBSEL_20V          ((0x1ul << ANA_MICBSEL_REFSEL_Pos)|0x2)   /*!< Microphone bias voltage is 2.0V VBG   */
N#define ADC_MICBSEL_13V          ((0x1ul << ANA_MICBSEL_REFSEL_Pos)|0x3)   /*!< Microphone bias voltage is 1.3V VBG   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* MUXCTL constant definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_MUXCTL_MIC_PATH          (ANA_MUXCTL_PGAINSEL_Msk)                           /*!< Select MICP/MICN To PGA Inputs   */
N#define ADC_MUXCTL_TEMP_PATH         (ANA_MUXCTL_PTATCUR_Msk)                            /*!< Negative input to PGA, for temperature measurement   */
N#define ADC_MUXCTL_GPIO_PATH         (ANA_MUXCTL_POSINSEL_Msk|ANA_MUXCTL_NEGINSEL_Msk)   /*!< GPIOB/A to PGA_INP/PGA_INN   */
N
N#define ADC_MUXCTL_POSINSEL_NONE     (0x0ul << ANA_MUXCTL_POSINSEL_Pos)
N#define ADC_MUXCTL_POSINSEL_GPB1     (0x1ul << ANA_MUXCTL_POSINSEL_Pos)           /*!< GPIOB[1] connected to PGA_INP   */
N#define ADC_MUXCTL_POSINSEL_GPB3     (0x2ul << ANA_MUXCTL_POSINSEL_Pos)           /*!< GPIOB[3] connected to PGA_INP   */
N#define ADC_MUXCTL_POSINSEL_GPB5     (0x4ul << ANA_MUXCTL_POSINSEL_Pos)           /*!< GPIOB[5] connected to PGA_INP   */
N#define ADC_MUXCTL_POSINSEL_GPB7     (0x8ul << ANA_MUXCTL_POSINSEL_Pos)           /*!< GPIOB[7] connected to PGA_INP   */
N
N#define ADC_MUXCTL_NEGINSEL_NONE     (0x00ul << ANA_MUXCTL_NEGINSEL_Pos)
N#define ADC_MUXCTL_NEGINSEL_GPB0     (0x01ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[0] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB1     (0x02ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[1] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB2     (0x04ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[2] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB3     (0x08ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[3] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB4     (0x10ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[4] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB5     (0x20ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[5] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB6     (0x40ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[6] connected to PGA_INN   */
N#define ADC_MUXCTL_NEGINSEL_GPB7     (0x80ul << ANA_MUXCTL_NEGINSEL_Pos)           /*!< GPIOB[7] connected to PGA_INN   */
N
N#define ADC_GPIO_SINGLEEND_CH0_N     ((BIT0 << 12) | ADC_MUXCTL_NEGINSEL_GPB0 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[0] connected to PGA_INN    */  
N#define ADC_GPIO_SINGLEEND_CH1_P     ((BIT1 << 12) | ADC_MUXCTL_NEGINSEL_NONE | ADC_MUXCTL_POSINSEL_GPB1)        /*!< singel-end mode, GPIOB[1] connected to PGA_INP    */
N#define ADC_GPIO_SINGLEEND_CH1_N     ((BIT1 << 12) | ADC_MUXCTL_NEGINSEL_GPB1 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[1] connected to PGA_INN    */ 
N#define ADC_GPIO_SINGLEEND_CH2_N     ((BIT2 << 12) | ADC_MUXCTL_NEGINSEL_GPB2 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[2] connected to PGA_INN    */ 
N#define ADC_GPIO_SINGLEEND_CH3_P     ((BIT3 << 12) | ADC_MUXCTL_NEGINSEL_NONE | ADC_MUXCTL_POSINSEL_GPB3)        /*!< singel-end mode, GPIOB[3] connected to PGA_INP    */
N#define ADC_GPIO_SINGLEEND_CH3_N     ((BIT3 << 12) | ADC_MUXCTL_NEGINSEL_GPB3 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[3] connected to PGA_INN    */ 
N#define ADC_GPIO_SINGLEEND_CH4_N     ((BIT4 << 12) | ADC_MUXCTL_NEGINSEL_GPB4 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[4] connected to PGA_INN    */ 
N#define ADC_GPIO_SINGLEEND_CH5_P     ((BIT5 << 12) | ADC_MUXCTL_NEGINSEL_NONE | ADC_MUXCTL_POSINSEL_GPB5)        /*!< singel-end mode, GPIOB[5] connected to PGA_INP    */
N#define ADC_GPIO_SINGLEEND_CH5_N     ((BIT5 << 12) | ADC_MUXCTL_NEGINSEL_GPB5 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[5] connected to PGA_INN    */ 
N#define ADC_GPIO_SINGLEEND_CH6_N     ((BIT6 << 12) | ADC_MUXCTL_NEGINSEL_GPB6 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[6] connected to PGA_INN    */ 
N#define ADC_GPIO_SINGLEEND_CH7_P     ((BIT7 << 12) | ADC_MUXCTL_NEGINSEL_NONE | ADC_MUXCTL_POSINSEL_GPB7)        /*!< singel-end mode, GPIOB[7] connected to PGA_INP    */
N#define ADC_GPIO_SINGLEEND_CH7_N     ((BIT7 << 12) | ADC_MUXCTL_NEGINSEL_GPB7 | ADC_MUXCTL_POSINSEL_NONE)        /*!< singel-end mode, GPIOB[7] connected to PGA_INN    */ 
N#define ADC_GPIO_DIFFERENTIAL_CH01   (((BIT0 | BIT1) << 12) | ADC_MUXCTL_NEGINSEL_GPB0 | ADC_MUXCTL_POSINSEL_GPB1)       /*!< differential mode, GPIOB[0] connected to PGA_INN and GPIOB[1] connected to PGA_INP  */ 
N#define ADC_GPIO_DIFFERENTIAL_CH23   (((BIT2 | BIT3) << 12) | ADC_MUXCTL_NEGINSEL_GPB2 | ADC_MUXCTL_POSINSEL_GPB3)       /*!< differential mode, GPIOB[2] connected to PGA_INN and GPIOB[3] connected to PGA_INP  */  
N#define ADC_GPIO_DIFFERENTIAL_CH45   (((BIT4 | BIT5) << 12) | ADC_MUXCTL_NEGINSEL_GPB4 | ADC_MUXCTL_POSINSEL_GPB5)       /*!< differential mode, GPIOB[4] connected to PGA_INN and GPIOB[5] connected to PGA_INP  */ 
N#define ADC_GPIO_DIFFERENTIAL_CH67   (((BIT6 | BIT7) << 12) | ADC_MUXCTL_NEGINSEL_GPB6 | ADC_MUXCTL_POSINSEL_GPB7)       /*!< differential mode, GPIOB[6] connected to PGA_INN and GPIOB[7] connected to PGA_INP  */ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* PGACTL constant definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/ 
N#define ADC_PGACTL_BOSST_GAIN_0DB    (0x0ul << ANA_PGACTL_BSTGAIN_Pos)          /*!< Boost Stage Gain is 0dB   */
N#define ADC_PGACTL_BOSST_GAIN_26DB   (0x1ul << ANA_PGACTL_BSTGAIN_Pos)          /*!< Boost Stage Gain is 26dB   */
N
N#define ADC_PGACTL_REFSEL_VMID       (0x0ul << ANA_PGACTL_REFSEL_Pos)           /*!< Select VMID(VCCA/2) voltage as analog ground reference.   */
N#define ADC_PGACTL_REFSEL_VBG        (0x1ul << ANA_PGACTL_REFSEL_Pos)           /*!<  Select Bandgap(1.2V) voltage as analog ground reference.   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SIGCTL constant definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SIGCTL_MUTE_PGA      (ANA_SIGCTL_MUTEPGA_Msk)
N#define ADC_SIGCTL_MUTE_IPBOOST  (ANA_SIGCTL_MUTEBST_Msk)
N	
N#define ADC_SIGCTL_ADCMOD_POWER      (ANA_SIGCTL_PUADCOP_Msk)      /*!<  Power for ADC UG modulator.   */
N#define ADC_SIGCTL_IBGEN_POWER       (ANA_SIGCTL_PUCURB_Msk)       /*!<  Power for current bias generation.   */
N#define ADC_SIGCTL_BUFADC_POWER      (ANA_SIGCTL_PUBUFADC_Msk)     /*!<  Power for ADC reference buffer.   */
N#define ADC_SIGCTL_BUFPGA_POWER      (ANA_SIGCTL_PUBUFPGA_Msk)     /*!<  Power for PGA reference buffer.   */
N#define ADC_SIGCTL_ZCD_POWER         (ANA_SIGCTL_PUZCDCMP_Msk)     /*!<  Power for zero cross detect comparator.   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ALC CTL constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ALCCTL_NORMAL_MODE     (0x0ul << ALC_CTL_MODESEL_Pos)  /*!<  ALC operates on normal mode.   */
N#define ADC_ALCCTL_LIMITER_MODE    (0x1ul << ALC_CTL_MODESEL_Pos)  /*!<  ALC operates on limiter mode.   */
N
N#define ADC_ALCCTL_ABS_PEAK       (0x0ul << ALC_CTL_PKSEL_Pos)   /*!<  use absolute peak value for ALC training.    */
N#define ADC_ALCCTL_P2P_PEAK       (0x1ul << ALC_CTL_PKSEL_Pos)   /*!<  use peak-to-peak value for ALC training.   */
N
N#define ADC_ALCCTL_FASTDEC_ON     (0x0ul << ALC_CTL_PKLIMEN_Pos)  /*!< enable fast decrement when signal exceeds 87.5% of full scale.    */
N#define ADC_ALCCTL_FASTDEC_OFF    (0x1ul << ALC_CTL_PKLIMEN_Pos)  /*!< disable fast decrement when signal exceeds 87.5% of full scale.    */
N
N#define ADC_ALCCTL_NGPEAK_ABS     (0x1ul << ALC_CTL_NGPKSEL_Pos)   /*!<  use absolute peak value for for noise gate threshold determination.    */
N#define ADC_ALCCTL_NGPEAK_P2P     (0x0ul << ALC_CTL_NGPKSEL_Pos)   /*!<  use peak-to-peak value for for noise gate threshold determination.   */
N
N#define ADC_ALCCTL_NGTH0     (0)   /*!<   Noise Gate Threshold 0 level.    */
N#define ADC_ALCCTL_NGTH1     (1)   /*!<   Noise Gate Threshold 1 level.    */
N#define ADC_ALCCTL_NGTH2     (2)   /*!<   Noise Gate Threshold 2 level.    */
N#define ADC_ALCCTL_NGTH3     (3)   /*!<   Noise Gate Threshold 3 level.    */
N#define ADC_ALCCTL_NGTH4     (4)   /*!<   Noise Gate Threshold 4 level.    */
N#define ADC_ALCCTL_NGTH5     (5)   /*!<   Noise Gate Threshold 5 level.    */
N#define ADC_ALCCTL_NGTH6     (6)   /*!<   Noise Gate Threshold 6 level.    */
N#define ADC_ALCCTL_NGTH7     (7)   /*!<   Noise Gate Threshold 7 level.    */
N
N/*@}*/ /* end of group ISD9100_ADC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N/**
N  * @brief     Set SDCLK divisor.
N  * @param     adc Base address of ADC module.
N  * @param     u8Divisor SDCLK divisore whcih must be greater than 2.
N  * @return    None
N  * @details   The clock division ration is between the incoming ADC_CLK (default HCLK)
N  *            and the Delta-Sigma sampling clock of the ADC.
N  */
N#define ADC_SET_SDCLKDIV(adc, \
N                         u8Divisor)   (adc->CLKDIV = (u8Divisor&0xff))
X#define ADC_SET_SDCLKDIV(adc,                          u8Divisor)   (adc->CLKDIV = (u8Divisor&0xff))
N                         
N/**
N  * @brief     Set over sampling ratio.
N  * @param     adc Base address of ADC module.
N  * @param     u8Ration over sampling ratio.
N  *            - \ref ADC_OSR_RATION_64 
N  *            - \ref ADC_OSR_RATION_128
N  *            - \ref ADC_OSR_RATION_192
N  *            - \ref ADC_OSR_RATION_384
N  * @return    None
N  * @details   This macro determines the over-sampling ratio of the decimation filter.
N  */
N#define ADC_SET_OSRATION(adc, \
N                         u8Ration)   (adc->DCICTL = (adc->DCICTL&(~ADC_DCICTL_OVSPLRAT_Msk))|(u8Ration&0xf))                         
X#define ADC_SET_OSRATION(adc,                          u8Ration)   (adc->DCICTL = (adc->DCICTL&(~ADC_DCICTL_OVSPLRAT_Msk))|(u8Ration&0xf))                         
N
N/**
N  * @brief     Set CIC filter additional gain.
N  * @param     adc Base address of ADC module.
N  * @param     u8Gain gain is value.
N  * @return    None.
N  * @details   This should normally remain default 0. It can be set to non-zero values to 
N  *            provide additional digital gain from the decimation filter. An additional
N  *            gain is applied to signal of GAIN/2.
N  */
N#define ADC_SET_CICGAIN(adc, \
N                        u8Gain)   (adc->DCICTL = (adc->DCICTL&(~ADC_DCICTL_GAIN_Msk))|((u8Gain&0xf)<<ADC_DCICTL_GAIN_Pos))
X#define ADC_SET_CICGAIN(adc,                         u8Gain)   (adc->DCICTL = (adc->DCICTL&(~ADC_DCICTL_GAIN_Msk))|((u8Gain&0xf)<<ADC_DCICTL_GAIN_Pos))
N                         
N                        
N/**
N  * @brief     read data from the audio FIFO.
N  * @param     adc Base address of ADC module.
N  * @return    Signed 16 bits audio data.
N  * @details   A read of this register will read data from the audio FIFO
N  *            and increment the read pointer.
N  */
N#define ADC_GET_FIFODATA(adc)   (adc->DAT&0xffff)
N
N/**
N  * @brief     Set FIFO interrupt level.
N  * @param     adc Base address of ADC module.
N  * @param     u8Level is number of words present in ADC FIFO, total 8 word levels.
N  * @return    None.
N  * @details   Determines at what level the ADC FIFO will generate a servicing
N  *            interrupt to the CPU. Interrupt will be generated when number of
N  *            words present in ADC FIFO is greater than u8Level.
N  */
N#define ADC_SET_FIFOINTLEVEL(adc, \
N                             u8Level)    (adc->INTCTL = (adc->INTCTL&(~ADC_INTCTL_FIFOINTLV_Msk))|(u8Level&0x7))
X#define ADC_SET_FIFOINTLEVEL(adc,                              u8Level)    (adc->INTCTL = (adc->INTCTL&(~ADC_INTCTL_FIFOINTLV_Msk))|(u8Level&0x7))
N
N/**
N  * @brief     Enable ADC PDMA receive channel.
N  * @param     adc Base address of ADC module.
N  * @return    None.
N  * @details   ADC will request PDMA service when data is available. When PDMA transfer is enabled,
N  *            the ADC interrupt must be disabled.
N  */
N#define ADC_ENABLE_PDMA(adc)     adc->PDMACTL |= ADC_PDMACTL_RXDMAEN_Msk; \
N                                 adc->INTCTL &= (~ADC_INTCTL_INTEN_Msk)
X#define ADC_ENABLE_PDMA(adc)     adc->PDMACTL |= ADC_PDMACTL_RXDMAEN_Msk;                                  adc->INTCTL &= (~ADC_INTCTL_INTEN_Msk)
N                                  
N/**
N  * @brief     Disable ADC PDMA receive channel.
N  * @param     adc Base address of ADC module.
N  * @return    None.
N  */
N#define ADC_DISABLE_PDMA(adc)     (adc->PDMACTL &= (~ADC_PDMACTL_RXDMAEN_Msk))
N
N/**
N  * @brief     Configure the comparator 0 and enable it.
N  * @param     adc Base address of ADC module.
N  * @param     u32Condition Specifies the compare condition. Valid values are:
N  *            - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *            - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param     u32Data Specifies the compare value, valid value are between 0 ~ 0xFFFF.
N  * @param     u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return    None
N  * @details   For example, ADC_ENABLE_CMP0(ADC, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *            Means ADC will assert comparator 0 flag if conversion result is greater or
N  *            equal to 0x800 for 10 times continuously.
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (adc->CMP0 = u32Condition | \
N                                                    ((u32Data) << 16) | \
N                                                    (((u32MatchCount) - 1) << 8) |\
N                                                    ADC_ADCMPR_CMPEN_ENABLE)
X#define ADC_ENABLE_CMP0(adc,                         u32Condition,                         u32Data,                         u32MatchCount) (adc->CMP0 = u32Condition |                                                     ((u32Data) << 16) |                                                     (((u32MatchCount) - 1) << 8) |                                                    ADC_ADCMPR_CMPEN_ENABLE)
N
N/**
N  * @brief     Disable comparator 0.
N  * @param     adc Base address of ADC module.
N  * @return    None
N  * @details   Set CMPEN (CMP0[0]) to 0 to disable ADC controller to compare CMPDAT (CMP1[16:31]).
N  */
N#define ADC_DISABLE_CMP0(adc) (adc->CMP0 = ADC_ADCMPR_CMPEN_DISABLE)
N
N/**
N  * @brief     Configure the comparator 1 and enable it.
N  * @param     adc Base address of ADC module.
N  * @param     u32Condition Specifies the compare condition. Valid values are:
N  *            - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *            - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param     u32Data Specifies the compare value, valid value are between 0 ~ 0xFFFF.
N  * @param     u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return    None
N  * @details   For example, ADC_ENABLE_CMP0(ADC, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *            Means ADC will assert comparator 1 flag if conversion result is greater or
N  *            equal to 0x800 for 10 times continuously.
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (adc->CMP1 = u32Condition | \
N                                                    ((u32Data) << 16) | \
N                                                    (((u32MatchCount) - 1) << 8) |\
N                                                    ADC_ADCMPR_CMPEN_ENABLE)
X#define ADC_ENABLE_CMP1(adc,                         u32Condition,                         u32Data,                         u32MatchCount) (adc->CMP1 = u32Condition |                                                     ((u32Data) << 16) |                                                     (((u32MatchCount) - 1) << 8) |                                                    ADC_ADCMPR_CMPEN_ENABLE)
N
N/**
N  * @brief     Disable comparator 1.
N  * @param     adc Base address of ADC module.
N  * @return    None
N  * @details   Set CMPEN (CMP1[0]) to 0 to disable ADC controller to compare CMPDAT (CMP1[16:31]).
N  */
N#define ADC_DISABLE_CMP1(adc) (adc->CMP1 = ADC_ADCMPR_CMPEN_DISABLE)
N
N/**
N  * @brief     Start the A/D conversion.
N  * @param     adc Base address of ADC module.
N  * @return    None
N  * @details   CHEN (CHEN[0]) can be set to 1 for ADC conversion enabling. 
N  */
N#define ADC_START_CONV(adc) (adc->CHEN = ADC_CHEN_CHEN_Msk)
N
N/**
N  * @brief     Stop the A/D conversion.
N  * @param     adc Base address of ADC module.
N  * @return    None
N  * @details   CHEN (CHEN[0]) can be set to 0 for ADC conversion disabling
N  */
N#define ADC_STOP_CONV(adc) (adc->CHEN = ~ADC_CHEN_CHEN_Msk)
N
N/**
N  * @brief      Enable VMID reference voltage
N  * @param      adc Base address of ADC module
N  * @param      Hires is High Resistance reference to VMID
N  *             - \ref ADC_VMID_HIRES_CONNECT
N  *             - \ref ADC_VMID_HIRES_DISCONNECT
N  * @param      Lores is Low Resistance reference to VMID
N  *             - \ref ADC_VMID_LORES_CONNECT
N  *             - \ref ADC_VMID_LORES_DISCONNECT
N  * @return     None
N  * @details    The VMID needs to be enabled for operation before using the ADC, PGA or other analog blocks.
N  */
N#define ADC_ENABLE_VMID(adc, \
N                        Hires, \
N						Lores)  (ANA->VMID = (0x0|Hires|Lores))
X#define ADC_ENABLE_VMID(adc,                         Hires, 						Lores)  (ANA->VMID = (0x0|Hires|Lores))
N
N/**
N  * @brief      Disable VMID reference voltage
N  * @param      adc Base address of ADC module
N  * @return     None
N  */
N#define ADC_DISABLE_VMID(adc)	(ANA->VMID |= 0x7)
N
N/**
N  * @brief      Enable programmable gain amplifier (PGA) 
N  * @param      adc The base address of ADC module
N  * @param      u32REFSel is reference voltage for analog path
N  *             - \ref ADC_PGACTL_REFSEL_VMID
N	*             - \ref ADC_PGACTL_REFSEL_VBG
N  * @param      u32BoostGain is boost stage gain setting
N  *             - \ref ADC_PGACTL_BOSST_GAIN_0DB
N	*             - \ref ADC_PGACTL_BOSST_GAIN_26DB
N  * @return     None
N  * @details    ISD9100 provides a Programmable Gain Amplifier (PGA) as the front-end
N  *             to the ADC to allow the adjustment of signal path gain. It is used in conjunction
N  *             with the ALC block to provide automatic level control of incoming audio signals.  
N  */
N#define ADC_ENABLE_PGA(adc, \
N                       u32REFSel, \
N                       u32BoostGain)  (ANA->PGACTL = (ANA->PGACTL&~(ANA_PGACTL_BSTGAIN_Msk|ANA_PGACTL_REFSEL_Msk))|(ANA_PGACTL_PUPGA_Msk|ANA_PGACTL_PUBOOST_Msk|u32REFSel|u32BoostGain))
X#define ADC_ENABLE_PGA(adc,                        u32REFSel,                        u32BoostGain)  (ANA->PGACTL = (ANA->PGACTL&~(ANA_PGACTL_BSTGAIN_Msk|ANA_PGACTL_REFSEL_Msk))|(ANA_PGACTL_PUPGA_Msk|ANA_PGACTL_PUBOOST_Msk|u32REFSel|u32BoostGain))
N
N/**
N  * @brief      Disable programmable gain amplifier
N  * @param      adc The base address of ADC module
N  * @return     None
N  */
N#define ADC_DISABLE_PGA(adc)   (ANA->PGACTL = 0x0)
N
N/**
N  * @brief      Boost stage and PGA mute-on control
N  * @param      adc The base address of ADC module
N  * @param      u8PGAStage is mute stage
N  *             - \ref ADC_SIGCTL_MUTE_PGA
N  *             - \ref ADC_SIGCTL_MUTE_IPBOOST
N  * @return     None
N  */
N#define ADC_MUTEON_PGA(adc, \
N                       u8PGAStage)    (ANA->SIGCTL |= (u8PGAStage&(ANA_SIGCTL_MUTEPGA_Msk|ANA_SIGCTL_MUTEBST_Msk)))
X#define ADC_MUTEON_PGA(adc,                        u8PGAStage)    (ANA->SIGCTL |= (u8PGAStage&(ANA_SIGCTL_MUTEPGA_Msk|ANA_SIGCTL_MUTEBST_Msk)))
N/**
N  * @brief      Boost stage and PGA mute-off control
N  * @param      adc The base address of ADC module
N  * @param      u8PGAStage is mute stage
N  *             - \ref ADC_SIGCTL_MUTE_PGA
N  *             - \ref ADC_SIGCTL_MUTE_IPBOOST
N  * @return     None
N  */
N#define ADC_MUTEOFF_PGA(adc, \
N                        u8PGAStage)    (ANA->SIGCTL &= ~(u8PGAStage&(ANA_SIGCTL_MUTEPGA_Msk|ANA_SIGCTL_MUTEBST_Msk))) 
X#define ADC_MUTEOFF_PGA(adc,                         u8PGAStage)    (ANA->SIGCTL &= ~(u8PGAStage&(ANA_SIGCTL_MUTEPGA_Msk|ANA_SIGCTL_MUTEBST_Msk))) 
N
N/**
N  * @brief      Signal path power up control
N  * @param      adc The base address of ADC module
N  * @param      u8SignalType is signal type
N  *             - \ref ADC_SIGCTL_ADCMOD_POWER
N  *             - \ref ADC_SIGCTL_IBGEN_POWER
N  *             - \ref ADC_SIGCTL_BUFADC_POWER
N  *             - \ref ADC_SIGCTL_BUFPGA_POWER
N  *             - \ref ADC_SIGCTL_ZCD_POWER
N  * @return     None
N  */
N#define ADC_ENABLE_SIGNALPOWER(adc, \
N                               u8SignalType)    (ANA->SIGCTL = (ANA->SIGCTL&(~0x1F))|(u8SignalType&(0x1F)))
X#define ADC_ENABLE_SIGNALPOWER(adc,                                u8SignalType)    (ANA->SIGCTL = (ANA->SIGCTL&(~0x1F))|(u8SignalType&(0x1F)))
N
N/**
N  * @brief      Signal path power up control
N  * @param      adc The base address of ADC module
N  * @param      u8SignalType is signal type
N  *             - \ref ADC_SIGCTL_ADCMOD_POWER
N  *             - \ref ADC_SIGCTL_IBGEN_POWER
N  *             - \ref ADC_SIGCTL_BUFADC_POWER
N  *             - \ref ADC_SIGCTL_BUFPGA_POWER
N  *             - \ref ADC_SIGCTL_ZCD_POWER
N  * @return     None
N  */
N#define ADC_DISABLE_SIGNALPOWER(adc, \
N                                u8SignalType)    (ANA->SIGCTL &= ~(u8SignalType&(0x1F)))                                                                                                            
X#define ADC_DISABLE_SIGNALPOWER(adc,                                 u8SignalType)    (ANA->SIGCTL &= ~(u8SignalType&(0x1F)))                                                                                                            
N
N/**
N  * @brief      Enable ALC operation
N  * @param      adc The base address of ADC module
N  * @param      u32Mode is ALC operation mod
N  *             - \ref ADC_ALCCTL_NORMAL_MODE
N  *             - \ref ADC_ALCCTL_LIMITER_MODE
N  * @param      u32PeakSel is ALC gain peak detector selection
N  *             - \ref ADC_ALCCTL_ABS_PEAK   (default)
N  *             - \ref ADC_ALCCTL_P2P_PEAK
N  * @param      u32FastDec is fast decrement on/off selection if ALC operates on ADC_ALCCTL_LIMITER_MODE.
N  *             - \ref ADC_ALCCTL_FASTDEC_ON (default)
N  *             - \ref ADC_ALCCTL_FASTDEC_OFF  
N  * @return     None
N  */
N#define ADC_ENABLE_ALC(adc, \
N                       u32Mode, \
N                       u32PeakSel, \
N                       u32FastDec)  (ALC->CTL = (ALC->CTL &~(ALC_CTL_MODESEL_Msk|ALC_CTL_PKSEL_Msk|ALC_CTL_PKLIMEN_Msk))|(u32Mode|u32PeakSel|u32FastDec|ALC_CTL_ALCEN_Msk))
X#define ADC_ENABLE_ALC(adc,                        u32Mode,                        u32PeakSel,                        u32FastDec)  (ALC->CTL = (ALC->CTL &~(ALC_CTL_MODESEL_Msk|ALC_CTL_PKSEL_Msk|ALC_CTL_PKLIMEN_Msk))|(u32Mode|u32PeakSel|u32FastDec|ALC_CTL_ALCEN_Msk))
N
N/**
N  * @brief      Disable ALC operation
N  * @param      adc The base address of ADC module
N  * @return     None
N  */
N#define ADC_DISABLE_ALC(adc)       (ALC->CTL &= (~ALC_CTL_ALCEN_Msk))
N
N/**
N  * @brief      Enable noise gate operation
N  * @param      adc The base address of ADC module
N  * @param      u32PeakSel is ALC gain peak detector selection
N  *             - \ref ADC_ALCCTL_NGPEAK_ABS   
N  *             - \ref ADC_ALCCTL_NGPEAK_P2P   (default)
N  * @return     None
N  */
N#define ADC_ENABLE_NOISEGATE(adc, \
N                             u32PeakSel)  (ALC->CTL = ( ALC->CTL&~ALC_CTL_NGPKSEL_Msk)|(u32PeakSel|ALC_CTL_ALCEN_Msk|ADC_ALCCTL_NORMAL_MODE|ALC_CTL_NGEN_Msk))
X#define ADC_ENABLE_NOISEGATE(adc,                              u32PeakSel)  (ALC->CTL = ( ALC->CTL&~ALC_CTL_NGPKSEL_Msk)|(u32PeakSel|ALC_CTL_ALCEN_Msk|ADC_ALCCTL_NORMAL_MODE|ALC_CTL_NGEN_Msk))
N
N/**
N  * @brief      Disable noise gate operation
N  * @param      adc The base address of ADC module
N  * @return     None
N  */
N#define ADC_DISABLE_NOISEGATE(adc)       (ALC->CTL &= (~ALC_CTL_NGEN_Msk))                        
N
N/**
N  * @brief      Enable zero Crossing
N  * @param      adc The base address of ADC module
N  * @return     None
N  */
N#define ADC_ENABLE_ZEROCROSSING(adc)    (ALC->CTL |= (ALC_CTL_ZCEN_Msk))
N
N/**
N  * @brief      Enable zero Crossing
N  * @param      adc The base address of ADC module
N  * @return     None
N  */
N#define ADC_DISABLE_ZEROCROSSING(adc)    (ALC->CTL &= (~ALC_CTL_ZCEN_Msk))
N  
N/**
N  * @brief      Set ALC attack time
N  * @param      adc The base address of ADC module
N  * @param      u8Step is range N = 0~10 Steps
N  * @return     None
N  * @details    Normal mode (500us~512ms):  Time = 500us * 2^N
N  *             Limiter mode(125us~128ms):  Time = 125us * 2^N 
N  */
N#define ADC_SET_ALCATTACKTIME(adc, \
N                              u8Step)    (ALC->CTL = (ALC->CTL&~ALC_CTL_ATKSEL_Msk)|((u8Step&0xf) << ALC_CTL_ATKSEL_Pos))
X#define ADC_SET_ALCATTACKTIME(adc,                               u8Step)    (ALC->CTL = (ALC->CTL&~ALC_CTL_ATKSEL_Msk)|((u8Step&0xf) << ALC_CTL_ATKSEL_Pos))
N
N/**
N  * @brief      Set ALC decay time
N  * @param      adc The base address of ADC module
N  * @param      u8Step is range N = 0~10 Steps
N  * @return     None
N  * @details    Normal mode (125us~128ms):  Time = 125us * 2^N 
N  *             Limiter mode( 31us~ 32ms):  Time =  31us * 2^N
N  */
N#define ADC_SET_ALCDECAYTIME(adc, \
N                             u8Step)    (ALC->CTL = (ALC->CTL&~ALC_CTL_DECAYSEL_Msk)|((u8Step&0xf) << ALC_CTL_DECAYSEL_Pos))
X#define ADC_SET_ALCDECAYTIME(adc,                              u8Step)    (ALC->CTL = (ALC->CTL&~ALC_CTL_DECAYSEL_Msk)|((u8Step&0xf) << ALC_CTL_DECAYSEL_Pos))
N
N/**
N  * @brief      Set ALC hold time
N  * @param      adc The base address of ADC module
N  * @param      u8Step is range N = 0~10 Steps
N  * @return     None
N  * @details    0ms~1sec:  Time = 0 + 2^N (ms) 
N  */
N#define ADC_SET_ALCHOLDTIME(adc, \
N                            u8Step)    (ALC->CTL = (ALC->CTL&~ALC_CTL_HOLDTIME_Msk)|((u8Step&0xf) << ALC_CTL_HOLDTIME_Pos))
X#define ADC_SET_ALCHOLDTIME(adc,                             u8Step)    (ALC->CTL = (ALC->CTL&~ALC_CTL_HOLDTIME_Msk)|((u8Step&0xf) << ALC_CTL_HOLDTIME_Pos))
N
N/**
N  * @brief      Set ALC hold time
N  * @param      adc The base address of ADC module
N  * @param      u8Th is noise gate threshold levle.
N  *             - \ref ADC_ALCCTL_NGTH0
N  *             - \ref ADC_ALCCTL_NGTH1
N  *             - \ref ADC_ALCCTL_NGTH2
N  *             - \ref ADC_ALCCTL_NGTH3
N  *             - \ref ADC_ALCCTL_NGTH4
N  *             - \ref ADC_ALCCTL_NGTH5
N  *             - \ref ADC_ALCCTL_NGTH6
N  *             - \ref ADC_ALCCTL_NGTH7
N  * @return     None
N  * @details    Boost disabled:    Threshold aaa (-81+6*ADC_ALCCTL_NGTHX) dB 
N  *             Boost enabled:     Threshold aaa (-87+6*ADC_ALCCTL_NGTHX) dB
N  */
N#define ADC_SET_NOISEGATE_TH(adc, \
N                             u8Th)     (ALC->CTL = (ALC->CTL&~ALC_CTL_NGTHBST_Msk)|(u8Th))
X#define ADC_SET_NOISEGATE_TH(adc,                              u8Th)     (ALC->CTL = (ALC->CTL&~ALC_CTL_NGTHBST_Msk)|(u8Th))
N
N/**
N  * @brief      Get noise gate flag
N  * @param      adc The base address of ADC module
N  * @return     Asserted flag
N  * @details    Asserted when signal level is detected to be below NGTH
N  */
N#define ADC_GET_NOISEFLAG(adc)    (ALC->STS&ALC_STS_NOISEF_Msk)
N
N/**
N  * @brief      Get clipping flag
N  * @param      adc The base address of ADC module
N  * @return     Asserted flag
N  * @details    Asserted when signal level is detected to be above 87.5% of full scale
N  */
N#define ADC_GET_CLIPFLAG(adc)    (ALC->STS&ALC_STS_CLIPFLAG_Msk)
N
N/**
N  * @brief      Get peak-to-peak Value
N  * @param      adc The base address of ADC module
N  * @return     9 MSBs of measured peak-to-peak value
N  */
N#define ADC_GET_P2PVALUE(adc)    ((ALC->STS&ALC_STS_P2PVAL_Msk) >> ALC_STS_P2PVAL_Pos)
N
N/**
N  * @brief      Get peak Value
N  * @param      adc The base address of ADC module
N  * @return     9 MSBs of measured absolute peak value
N  */
N#define ADC_GET_PEAKVALUE(adc)    ((ALC->STS&ALC_STS_PEAKVAL_Msk) >> ALC_STS_PEAKVAL_Pos)
N
N
Nvoid ADC_Open(void);
Nvoid ADC_Close(void);
Nuint32_t ADC_GetSampleRate(void);
Nvoid ADC_EnableInt(uint32_t u32Mask);
Nvoid ADC_DisableInt(uint32_t u32Mask);
Nuint32_t ADC_GetIntFlag(uint32_t u32Mask);
Nvoid ADC_ClearIntFlag(uint32_t u32Mask);
Nvoid ADC_SetAMUX(uint32_t u32AMUXSel, uint32_t u32MUXPSel, uint32_t u32MUXNSel);
Nvoid ADC_SetGPIOChannel(uint32_t u32Mode);
Nvoid ADC_EnableMICBias(uint32_t u32BiasSel);
Nvoid ADC_DisableMICBias(void);
Nint32_t ADC_SetPGAGaindB(int32_t i32PGAGainIndB);
Nint32_t ADC_SetALCMaxGaindB(int32_t i32MaxGaindB);
Nint32_t ADC_SetALCMinGaindB(int32_t i32MinGaindB);
Nint32_t ADC_SetALCTargetLevel(int32_t i32TargetLevel);
Nint32_t ADC_GetPGAGaindB(void);
N
N/*@}*/ /* end of group ISD9100_ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_ADC_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9148 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "biq.h"
L 1 "..\..\..\..\Library\StdDriver\inc\biq.h" 1
N/**************************************************************************//**
N * @file     BIQ.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/07/04 11:27a $
N * @brief    ISD9100 Series BIQ Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __BIQ_H__
N#define __BIQ_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_BIQ_Driver BIQ Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_BIQ_EXPORTED_CONSTANTS BIQ Exported Constants
N  @{
N*/  
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* BIQ CTL Constant Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define BIQ_CTL_ADCPATH        (0x0ul << BIQ_CTL_PATHSEL_Pos)       /*!< BIQ is used in ADC path  */     
N#define BIQ_CTL_DPWMPATH       (0x1ul << BIQ_CTL_PATHSEL_Pos)       /*!< BIQ is used in DPWM path  */ 
N
N/*@}*/ /* end of group ISD9100_BIQ_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_BIQ_EXPORTED_FUNCTIONS BIQ Exported Functions
N  @{
N*/
N
N/**
N  * @brief     Set BIQ in ADC path.
N  * @param     biq Base address of BIQ module.
N  * @param     u16SRDiv is sample rate divisor.
N  * @param     u8DownRation is down sample ration
N  * @return    None
N  * @details   The sample rate is defined as (HCLK/(u16SRDiv+1).
N  *            Default value is 3071, so the sampling rate is 16K when HCLK is 49.152MHz.
N  */
N#define BIQ_SET_ADCPATH(biq, \
N                        u16SRDiv, \
N						u8DownRation)        (biq->CTL = (biq->CTL&~(BIQ_CTL_SRDIV_Msk|BIQ_CTL_DPWMPUSR_Msk))|(BIQ_CTL_ADCPATH|((u16SRDiv&0x1fff) << BIQ_CTL_SRDIV_Pos)|((u8DownRation&0x7) << BIQ_CTL_DPWMPUSR_Pos)))
X#define BIQ_SET_ADCPATH(biq,                         u16SRDiv, 						u8DownRation)        (biq->CTL = (biq->CTL&~(BIQ_CTL_SRDIV_Msk|BIQ_CTL_DPWMPUSR_Msk))|(BIQ_CTL_ADCPATH|((u16SRDiv&0x1fff) << BIQ_CTL_SRDIV_Pos)|((u8DownRation&0x7) << BIQ_CTL_DPWMPUSR_Pos)))
N
N/**
N  * @brief     Set BIQ in DPWM path.
N  * @param     biq Base address of BIQ module.
N  * @param     u16SRDiv is sample rate divisor.
N  * @param     u8UpRation is up Sample ration.
N  * @return    None
N  * @details   The DPWM sample rate is defined as (u16SRDiv+1)*HCLK/(u16SRDiv+1).
N  *            Default value is 3 for u8UpRation, up sample x4.
N  */
N#define BIQ_SET_DPWMPATH(biq, \
N                         u16SRDiv, \
N                         u8UpRation)     (biq->CTL = (biq->CTL&~(BIQ_CTL_SRDIV_Msk|BIQ_CTL_DPWMPUSR_Msk))|(BIQ_CTL_DPWMPATH|((u16SRDiv&0x1fff) << BIQ_CTL_SRDIV_Pos)|((u8UpRation&0x7) << BIQ_CTL_DPWMPUSR_Pos)))
X#define BIQ_SET_DPWMPATH(biq,                          u16SRDiv,                          u8UpRation)     (biq->CTL = (biq->CTL&~(BIQ_CTL_SRDIV_Msk|BIQ_CTL_DPWMPUSR_Msk))|(BIQ_CTL_DPWMPATH|((u16SRDiv&0x1fff) << BIQ_CTL_SRDIV_Pos)|((u8UpRation&0x7) << BIQ_CTL_DPWMPUSR_Pos)))
N
N/**
N  * @brief     BIQ filter start to run.
N  * @param     biq Base address of BIQ module.
N  * @return    None
N  */
N#define BIQ_START_RUN(biq)      (biq->CTL |= BIQ_CTL_BIQEN_Msk)
N
N/**
N  * @brief     BIQ filter stop to run.
N  * @param     biq Base address of BIQ module.
N  * @return    None
N  */
N#define BIQ_STOP_RUN(biq)      (biq->CTL |= (~BIQ_CTL_BIQEN_Msk))
N
Nvoid BIQ_SetCoeff(uint32_t u32BiqCoeff[15]);
Nvoid BIQ_Reset(void);
N
N/*@}*/ /* end of group ISD9100_BIQ_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_BIQ_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__BIQ_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/    
L 9149 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "bod.h"
L 1 "..\..\..\..\Library\StdDriver\inc\bod.h" 1
N/**************************************************************************//**
N * @file     BOD.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/06/25 7:06p $
N * @brief    ISD9100 BOD driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __BOD_H
N#define __BOD_H
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_BOD_Driver BOD Driver
N  @{
N*/
N
N
N/** @addtogroup ISD9100_BOD_EXPORTED_CONSTANTS BOD Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  BODSEL constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BOD_BODHYS_DISABLE      (0x0ul << BODTALM_BODSEL_BODHYS_Pos)           /*!< Hysteresis Disabled */
N#define BOD_BODHYS_ENABLE       (0x1ul << BODTALM_BODSEL_BODHYS_Pos)           /*!< Enable Hysteresis of BOD detection */
N
N#define BOD_BODVL_21V        (0x0)      /*!< BOD Voltage Level 2.1V */
N#define BOD_BODVL_22V        (0x1)      /*!< BOD Voltage Level 2.2V */
N#define BOD_BODVL_24V        (0x2)      /*!< BOD Voltage Level 2.4V */
N#define BOD_BODVL_25V        (0x3)      /*!< BOD Voltage Level 2.5V */
N#define BOD_BODVL_265V       (0x4)      /*!< BOD Voltage Level 2.65V */
N#define BOD_BODVL_28V        (0x5)      /*!< BOD Voltage Level 2.8V */
N#define BOD_BODVL_30V        (0x6)      /*!< BOD Voltage Level 3.0V */
N#define BOD_BODVL_46V        (0x7)      /*!< BOD Voltage Level 4.6V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  BODCTL constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BOD_BODEN_DISABLE              (0x0)       /*!< Disable BOD Detection */
N#define BOD_BODEN_CONTINUOUS           (0x1)       /*!< Enable continuous BOD detection */
N#define BOD_BODEN_TIME_MULTIPLEXED     (0x2)       /*!< Enable time multiplexed BOD detection */
N
N
N/*@}*/ /* end of group ISD9100_BOD_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_BOD_EXPORTED_FUNCTIONS BOD Exported Functions
N  @{
N*/
N
N/**
N  * @brief     This function will enable BOD Interrupt.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void BOD_EnableInt(BODTALM_T *BOD)
Xstatic __inline void BOD_EnableInt(BODTALM_T *BOD)
N{
N     BOD->BODCTL |= BODTALM_BODCTL_BODINTEN_Msk;    
X     BOD->BODCTL |= (0x1ul << (2));    
N}
N
N/**
N  * @brief     This function will disable BOD Interrupt.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void BOD_DisableInt(BODTALM_T *BOD)
Xstatic __inline void BOD_DisableInt(BODTALM_T *BOD)
N{
N     BOD->BODCTL &= (~BODTALM_BODCTL_BODINTEN_Msk);    
X     BOD->BODCTL &= (~(0x1ul << (2)));    
N}
N
N/**
N  * @brief     This function clears the BOD interrupt flag.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void BOD_ClearIntFlag(BODTALM_T *BOD)
Xstatic __inline void BOD_ClearIntFlag(BODTALM_T *BOD)
N{
N    BOD->BODCTL |= BODTALM_BODCTL_BODIF_Msk;
X    BOD->BODCTL |= (0x1ul << (3));
N}
N
N
N/**
N  * @brief     This function latched BOD interrupt occurred or not.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    BOD interrupt occurred or not
N  * @retval    0 BOD interrupt did not occur
N  * @retval    1 BOD interrupt occurred
N  */
N__STATIC_INLINE uint32_t BOD_GetIntFlag(BODTALM_T *BOD)
Xstatic __inline uint32_t BOD_GetIntFlag(BODTALM_T *BOD)
N{
N    return ((BOD->BODCTL&BODTALM_BODCTL_BODIF_Msk) ? 1 : 0 );
X    return ((BOD->BODCTL&(0x1ul << (3))) ? 1 : 0 );
N}
N
N/**
N  * @brief     This function will enable Hysteresis of BOD detect.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void BOD_EnableHyst(BODTALM_T *BOD)
Xstatic __inline void BOD_EnableHyst(BODTALM_T *BOD)
N{
N     BOD->BODSEL |= BODTALM_BODSEL_BODHYS_Msk;    
X     BOD->BODSEL |= (0x1ul << (3));    
N}
N
N/**
N  * @brief     This function will disable Hysteresis of BOD detect.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void BOD_DisableHyst(BODTALM_T *BOD)
Xstatic __inline void BOD_DisableHyst(BODTALM_T *BOD)
N{
N     BOD->BODSEL &= (~BODTALM_BODSEL_BODHYS_Msk);    
X     BOD->BODSEL &= (~(0x1ul << (3)));    
N}
N
N/**
N  * @brief     This function will monitored to determine the current state of the BOD comparator.
N  * @param[in] BOD The base address of BODTALM module
N  * @return    implies that VCC is less than BODVL or not.
N  * @retval    0 VCC is more than BODVL 
N  * @retval    1 VCC is less than BODVL 
N  */
N__STATIC_INLINE uint32_t BOD_GetOutput(BODTALM_T *BOD)
Xstatic __inline uint32_t BOD_GetOutput(BODTALM_T *BOD)
N{
N     return ((BOD->BODCTL&BODTALM_BODCTL_BODOUT_Msk) ? 1 : 0);    
X     return ((BOD->BODCTL&(0x1ul << (4))) ? 1 : 0);    
N}
N
Nvoid BOD_Open(uint8_t u8Mode, uint8_t u8BODLevel);
Nvoid BOD_Close(void);
Nvoid BOD_SetDetectionTime(uint8_t u8OnDUR, uint16_t u16OffDUR);
N
N
N
N/*@}*/ /* end of group ISD9100_BOD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_BOD_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__BOD_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
N
N
L 9150 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "capsense.h"
L 1 "..\..\..\..\Library\StdDriver\inc\capsense.h" 1
N/**************************************************************************//**
N * @file     CapSense.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/07/07 11:00a $
N * @brief    ISD9100 Series Capture Sense Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N 
N#ifndef __CAPSENSE_H__
N#define __CAPSENSE_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_CAPSENSE_Driver CapSense Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_CAPSENSE_EXPORTED_CONSTANTS CapSense Exported Constants
N  @{
N*/
N	
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CURCTL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CAPSENSE_CURCTL0_VALSEL_500NA      ( 0x0UL<<ANA_CURCTL0_VALSEL_Pos )
N#define CAPSENSE_CURCTL0_VALSEL_1000NA     ( 0x1UL<<ANA_CURCTL0_VALSEL_Pos )
N#define CAPSENSE_CURCTL0_VALSEL_2500NA     ( 0x2UL<<ANA_CURCTL0_VALSEL_Pos )
N#define CAPSENSE_CURCTL0_VALSEL_5000NA     ( 0x3UL<<ANA_CURCTL0_VALSEL_Pos )
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CURCTL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB0    ( 0x1UL<<0 )
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB1    ( 0x1UL<<1 ) 
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB2    ( 0x1UL<<2 ) 
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB3    ( 0x1UL<<3 ) 	
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB4    ( 0x1UL<<4 )
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB5    ( 0x1UL<<5 )
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB6    ( 0x1UL<<6 ) 
N#define CAPSENSE_CURCTL0_CURSRCEN_GPIOB7    ( 0x1UL<<7 ) 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CTRL constant definitions.                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CAPSENSE_CTRL_LOWTIME_1CYCLES       ( 0x0UL )
N#define CAPSENSE_CTRL_LOWTIME_2CYCLES       ( 0x1UL )
N#define CAPSENSE_CTRL_LOWTIME_8CYCLES       ( 0x2UL )
N#define CAPSENSE_CTRL_LOWTIME_16CYCLES      ( 0x3UL )
N
N/*@}*/ /* end of group ISD9100_CAPSENSE_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_CAPSENSE_EXPORTED_FUNCTIONS CapSense Exported Functions
N  @{
N*/
N
N#define CAPSENSE_ENABLE_CURRENT_SOURCE_PIN( u16Pin )               ( ANA->CURCTL0 |= u16Pin )
N#define CAPSENSE_ENABLE_INTERRUPT()                                ( ANA->CAPSCTL |= ANA_CAPSCTL_INTEN_Msk )
N#define CAPSENSE_DISABLE_INTERRUPT()                               ( ANA->CAPSCTL &= (~ANA_CAPSCTL_INTEN_Msk) )
N#define CAPSENSE_ENABLE()                                          ( ANA->CAPSCTL |= ANA_CAPSCTL_CAPSEN_Msk )
N#define CAPSENSE_DISABLE()                                         ( ANA->CAPSCTL &= (~ANA_CAPSCTL_CAPSEN_Msk) )
N
Nvoid     CapSense_SelectCurrentSourceValue( uint16_t u16SrcSel );
Nvoid     CapSense_SetCycleCounts( uint32_t u32Count, uint16_t u16LowTime );
N
Nvoid     CapSense_ResetCounter(void);
Nuint32_t CapSense_GetCounter(void);
N
N/*@}*/ /* end of group ISD9100_CAPSENSE_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_CAPSENSE_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9151 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "clk.h"
L 1 "..\..\..\..\Library\StdDriver\inc\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V1.00
N * $Revision: 6$
N * $Date: 14/07/17 2:35p $
N * @brief    ISD9100 series CLK driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWRCON constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PWRCON_LXT_EN       (0x1ul << CLK_PWRCTL_LXTEN_Pos) /*!< Enable 32.768 kHz External Low Speed Crystal (LXT) */
N#define CLK_PWRCON_HIRC_EN      (0x1ul << CLK_PWRCTL_HIRCEN_Pos) /*!< Enable 49 MHz Internal High Speed RC Oscillator (HIRC) */
N#define CLK_PWRCON_LIRC_EN      (0x1ul << CLK_PWRCTL_LIRCEN_Pos) /*!< Enable 16 kHz Internal Low Speed RC Oscillator (LIRC) */
N
N#define CLK_DPDWAKEUP_PINOSC16K   0      /*!< DPD wake up from WAKEUP pin and OSC 16k */  
N#define CLK_DPDWAKEUP_PIN         1      /*!< DPD wake up from WAKEUP pin */
N#define CLK_DPDWAKEUP_OSC16K      2      /*!< DPD wake up from OSC 16k */
N#define CLK_DPDWAKEUP_POR         3      /*!< DPD wake up from POR event trigger */
N
N#define CLK_DPDWAKETIME_12ms    (0x1ul << CLK_PWRCTL_SELWKTMR_Pos)    /*!< WAKEUP after 128 OSC16K clocks (12.8 ms) */
N#define CLK_DPDWAKETIME_25ms    (0x2ul << CLK_PWRCTL_SELWKTMR_Pos)    /*!< WAKEUP after 128 OSC16K clocks (25.6 ms) */
N#define CLK_DPDWAKETIME_50ms    (0x4ul << CLK_PWRCTL_SELWKTMR_Pos)    /*!< WAKEUP after 128 OSC16K clocks (51.2 ms) */
N#define CLK_DPDWAKETIME_100ms   (0x8ul << CLK_PWRCTL_SELWKTMR_Pos)    /*!< WAKEUP after 128 OSC16K clocks (102.4 ms) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.  (Write-protection)                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLKSEL_HIRC        (0x00UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting clock source as internal 48MHz RC clock  \hideinitializer */
N#define CLK_CLKSEL0_HCLKSEL_LXT         (0x01UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting clock source as external XTAL 32.768KHz \hideinitializer */
N#define CLK_CLKSEL0_HCLKSEL_LIRC        (0x02UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting clock source as internal 16KHz RC clock  \hideinitializer */
N
N#define CLK_CLKSEL0_STCLKSEL_LIRC        (0x00UL<<CLK_CLKSEL0_STCLKSEL_Pos)  /*!< Setting clock source as internal 16KHz RC clock  \hideinitializer */
N#define CLK_CLKSEL0_STCLKSEL_LXT         (0x01UL<<CLK_CLKSEL0_STCLKSEL_Pos)  /*!< Setting clock source as external XTAL 32.768KHz \hideinitializer */
N#define CLK_CLKSEL0_STCLKSEL_LIRC_DIV2   (0x02UL<<CLK_CLKSEL0_STCLKSEL_Pos)  /*!< Setting clock source as external 16KHz/2  \hideinitializer */
N#define CLK_CLKSEL0_STCLKSEL_HIRC_DIV2   (0x03UL<<CLK_CLKSEL0_STCLKSEL_Pos)  /*!< Setting clock source as internal 48MHz RC clock/2 \hideinitializer */
N#define CLK_CLKSEL0_STCLKSEL_HCLK_DIV2   (0x07UL<<CLK_CLKSEL0_STCLKSEL_Pos)  /*!< Setting clock source as HCLK/2  \hideinitializer */
N
N#define CLK_CLKSEL0_HIRCFSEL_48M         (0x00UL<<CLK_CLKSEL0_HIRCFSEL_Pos)  /*!< 49.152MHz RC trim clock for OSC48M(default)  \hideinitializer */
N#define CLK_CLKSEL0_HIRCFSEL_32M         (0x01UL<<CLK_CLKSEL0_HIRCFSEL_Pos)  /*!< 32.768MHz RC trim clock for OSC48M  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDTSEL_HIRC          (0x0UL<<CLK_CLKSEL1_WDTSEL_Pos)       /*!< Setting WDT clock source as internal 48MHz RC clock  \hideinitializer */
N#define CLK_CLKSEL1_WDTSEL_LXT           (0x1UL<<CLK_CLKSEL1_WDTSEL_Pos)       /*!< Setting WDT clock source as external XTAL 32.768KHz \hideinitializer */
N#define CLK_CLKSEL1_WDTSEL_HCLK_DIV2048  (0x2UL<<CLK_CLKSEL1_WDTSEL_Pos)       /*!< Setting WDT clock source as HCLK/2048  \hideinitializer */
N#define CLK_CLKSEL1_WDTSEL_LIRC          (0x3UL<<CLK_CLKSEL1_WDTSEL_Pos)       /*!< Setting WDT clock source as internal 16KHz RC clock  \hideinitializer */
N
N#define CLK_CLKSEL1_DPWMSEL_HIRC         (0x0UL<<CLK_CLKSEL1_DPWMCKSEL_Pos)    /*!< Setting DPWM clock source as internal 48MHz RC clock  \hideinitializer */
N#define CLK_CLKSEL1_DPWMSEL_HIRC2X       (0x1UL<<CLK_CLKSEL1_DPWMCKSEL_Pos)    /*!< Setting DPWM clock source as internal 2X 48MHz RC clock  \hideinitializer */
N
N#define CLK_CLKSEL1_TMR0SEL_LIRC         (0x0UL<<CLK_CLKSEL1_TMR0SEL_Pos)      /*!< Setting Timer 0 clock source as internal 16KHz RC clock  \hideinitializer */
N#define CLK_CLKSEL1_TMR0SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR0SEL_Pos)      /*!< Setting Timer 0 clock source as external XTAL 32.768KHz  \hideinitializer */
N#define CLK_CLKSEL1_TMR0SEL_HCLK         (0x2UL<<CLK_CLKSEL1_TMR0SEL_Pos)      /*!< Setting Timer 0 clock source as HCLK  \hideinitializer */
N#define CLK_CLKSEL1_TMR0SEL_EXT          (0x3UL<<CLK_CLKSEL1_TMR0SEL_Pos)      /*!< Setting Timer 0 clock source as external trigger (GPIOA[14])  \hideinitializer */    
N#define CLK_CLKSEL1_TMR0SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR0SEL_Pos)      /*!< Setting Timer 0 clock source as internal 48MHz RC clock  \hideinitializer */
N
N#define CLK_CLKSEL1_TMR1SEL_LIRC         (0x0UL<<CLK_CLKSEL1_TMR1SEL_Pos)      /*!< Setting Timer 1 clock source as internal 16KHz RC clock  \hideinitializer */
N#define CLK_CLKSEL1_TMR1SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR1SEL_Pos)      /*!< Setting Timer 1 clock source as external XTAL 32.768KHz  \hideinitializer */
N#define CLK_CLKSEL1_TMR1SEL_HCLK         (0x2UL<<CLK_CLKSEL1_TMR1SEL_Pos)      /*!< Setting Timer 1 clock source as HCLK  \hideinitializer */
N#define CLK_CLKSEL1_TMR1SEL_EXT          (0x3UL<<CLK_CLKSEL1_TMR1SEL_Pos)      /*!< Setting Timer 1 clock source as external trigger (GPIOA[15])  \hideinitializer */    
N#define CLK_CLKSEL1_TMR1SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR1SEL_Pos)      /*!< Setting Timer 1 clock source as internal 48MHz RC clock  \hideinitializer */
N
N#define CLK_CLKSEL1_PWM0CH01SEL_LIRC     (0x0UL<<CLK_CLKSEL1_PWM0CH01CKSEL_Pos)   /*!< Setting PWM0 and PWM1 clock source as internal 16KHz RC clock  \hideinitializer */
N#define CLK_CLKSEL1_PWM0CH01SEL_LXT      (0x1UL<<CLK_CLKSEL1_PWM0CH01CKSEL_Pos)   /*!< Setting PWM0 and PWM1 clock source as external XTAL 32.768KHz  \hideinitializer */
N#define CLK_CLKSEL1_PWM0CH01SEL_HCLK     (0x2UL<<CLK_CLKSEL1_PWM0CH01CKSEL_Pos)   /*!< Setting PWM0 and PWM1 clock source as HCLK  \hideinitializer */
N#define CLK_CLKSEL1_PWM0CH01SEL_HIRC     (0x3UL<<CLK_CLKSEL1_PWM0CH01CKSEL_Pos)   /*!< Setting PWM0 and PWM1 clock source as internal 48MHz RC clock  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_I2S0SEL_LIRC         (0x0UL<<CLK_CLKSEL2_I2S0SEL_Pos)      /*!< Setting I2S0 clock source as internal 16KHz RC clock  \hideinitializer */
N#define CLK_CLKSEL2_I2S0SEL_LXT          (0x1UL<<CLK_CLKSEL2_I2S0SEL_Pos)      /*!< Setting I2S0 clock source as external XTAL 32.768KHz  \hideinitializer */
N#define CLK_CLKSEL2_I2S0SEL_HCLK         (0x2UL<<CLK_CLKSEL2_I2S0SEL_Pos)      /*!< Setting I2S0 clock source as HCLK  \hideinitializer */
N#define CLK_CLKSEL2_I2S0SEL_HIRC         (0x3UL<<CLK_CLKSEL2_I2S0SEL_Pos)      /*!< Setting I2S0 clock source as internal 48MHz RC clock  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV0_HCLK(x)    (((x)-1) << CLK_CLKDIV0_HCLKDIV_Pos)    /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16  \hideinitializer */
N#define CLK_CLKDIV0_UART(x)    (((x)-1) << CLK_CLKDIV0_UARTDIV_Pos)    /*!< CLKDIV Setting for UR clock divider. It could be 1~16  \hideinitializer */
N#define CLK_CLKDIV0_ADC(x)     (((x)-1) << CLK_CLKDIV0_ADCDIV_Pos)     /*!< CLKDIV Setting for ADC clock divider. It could be 1~256  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWRSTSF constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PWRSTSF_SPDF		(CLK_PWRSTSF_SPDF_Msk)		/*!< Powered Down Flag (Standby (SPD))  \hideinitializer */
N#define CLK_PWRSTSF_STOPF		(CLK_PWRSTSF_STOPF_Msk)		/*!< Stop Flag  \hideinitializer */
N#define CLK_PWRSTSF_DSF			(CLK_PWRSTSF_DSF_Msk)		  /*!< Deep Sleep Flag  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  LDOSEL constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_LDOSEL_3_0V			(0x0ul<<ANA_LDOSEL_LDOSEL_Pos)		/*!< Select LDO Output 3.0 Voltage  \hideinitializer */
N#define CLK_LDOSEL_1_8V			(0x1ul<<ANA_LDOSEL_LDOSEL_Pos)		/*!< Select LDO Output 1.8 Voltage  \hideinitializer */
N#define CLK_LDOSEL_2_4V			(0x2ul<<ANA_LDOSEL_LDOSEL_Pos)	  	/*!< Select LDO Output 2.4 Voltage  \hideinitializer */
N#define CLK_LDOSEL_3_3V			(0x3ul<<ANA_LDOSEL_LDOSEL_Pos)		/*!< Select LDO Output 3.3 Voltage  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define MODULE_AHPBCLK(x)                  ((x >>30) & 0x3)    /*!< Calculate AHBCLK/APBCLK offset on MODULE index  \hideinitializer */
N#define MODULE_CLKSEL(x)                   ((x >>28) & 0x3)    /*!< Calculate CLKSEL0~1 register offset by MODULE index  \hideinitializer */
N#define MODULE_CLKSEL_Msk(x)               ((x >>25) & 0x7)    /*!< Calculate mask bits of CLKSEL0~1 by MODULE index  \hideinitializer */
N#define MODULE_CLKSEL_Pos(x)               ((x >>20) & 0x1f)   /*!< Calculate mask bits offset of CLKSEL0~1 by MODULE index  \hideinitializer */
N#define MODULE_CLKDIV(x)                   ((x >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV by MODULE index  \hideinitializer */
N#define MODULE_CLKDIV_Msk(x)               ((x >>10) & 0xff)   /*!< Calculate mask bits of CLKDIV by MODULE index  \hideinitializer */
N#define MODULE_CLKDIV_Pos(x)               ((x >>5 ) & 0x1f)   /*!< Calculate ask bits offset of CLKDIV by MODULE index  \hideinitializer */
N#define MODULE_IP_EN_Pos(x)                ((x >>0 ) & 0x1f)   /*!< Calculate APBCLK enabled offset by MODULE index  \hideinitializer */
N#define MODULE_NoMsk                       0x0                 /*!< Not mask by MODULE index  \hideinitializer */
N/*--------------------------------------------------------------------------------------------------------------------------------------*/
N/*   AHBCLK/APBCLK(2) | CLKSEL(2) | CLKSEL_Msk(3) |    CLKSEL_Pos(5)    | CLKDIV(2) | CLKDIV_Msk(8) |     CLKDIV_Pos(5)  |  IP_EN_Pos(5)*/
N/*--------------------------------------------------------------------------------------------------------------------------------------*/
N#define PDMA_MODULE      ((0UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_PDMACKEN_Pos)    /*!< PDMA Module  \hideinitializer */
N#define ISP_MODULE       ((0UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_ISPCKEN_Pos)     /*!< ISP Module  \hideinitializer */
N#define WDT_MODULE       ((1UL<<30)|(1<<28)|(           3<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_WDTCKEN_Pos)    /*!< Watchdog Timer Module  \hideinitializer */
N#define RTC_MODULE       ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_RTCCKEN_Pos)    /*!< RTC Module  \hideinitializer */
N#define TMR0_MODULE      ((1UL<<30)|(1<<28)|(           7<<25)|( 8<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_TMR0CKEN_Pos)   /*!< Timer0 Module  \hideinitializer */
N#define TMR1_MODULE      ((1UL<<30)|(1<<28)|(           7<<25)|(12<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_TMR1CKEN_Pos)   /*!< Timer1 Module  \hideinitializer */
N#define I2C0_MODULE      ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_I2C0CKEN_Pos)   /*!< I2C0 Module  \hideinitializer */
N#define SPI0_MODULE      ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_SPI0CKEN_Pos)   /*!< SPI0 Module  \hideinitializer */
N#define DPWM_MODULE      ((1UL<<30)|(1<<28)|(           1<<25)|( 4<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_DPWMCKEN_Pos)   /*!< DPWM Module  \hideinitializer */
N#define UART_MODULE      ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(         0xF<<10)|( 8<<5)|CLK_APBCLK0_UARTCKEN_Pos)   /*!< UART Module  \hideinitializer */
N#define BFAL_MODULE      ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_BFALCKEN_Pos)   /*!< BIQ And ALC Module  \hideinitializer */
N#define CRC_MODULE       ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_CRCCKEN_Pos)    /*!< CRC Module  \hideinitializer */
N#define PWM0_MODULE      ((1UL<<30)|(1<<28)|(           3<<25)|( 28<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_PWM0CH01CKEN_Pos) /*!< PWM0CH01 Module  \hideinitializer */
N#define ACMP_MODULE      ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_ACMPCKEN_Pos)   /*!< ACMP Module  \hideinitializer */
N#define SBRAM_MODULE     ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_SBRAMCKEN_Pos)   /*!< Standby RAM Module  \hideinitializer */
N#define ADC_MODULE       ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(        0xFF<<10)|(16<<5)|CLK_APBCLK0_ADCCKEN_Pos)    /*!< ADC Module  \hideinitializer */
N#define I2S0_MODULE      ((1UL<<30)|(3<<28)|(           3<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_I2S0CKEN_Pos)   /*!< I2S0 Module  \hideinitializer */
N#define ANA_MODULE       ((1UL<<30)|(0<<28)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK0_ANACKEN_Pos)   /*!< Analog Block Module  \hideinitializer */
N
N/*@}*/ /* end of group ISD9100_CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N/**
N  * @brief     Get power down state.
N  * @param[in] clk Base address of CLK module.
N  * @param[in] u8Flag Power state flag.
N  *            - \ref CLK_PWRSTSF_SPDF
N  *            - \ref CLK_PWRSTSF_STOPF
N  *            - \ref CLK_PWRSTSF_DSF
N  * @return    1: power down flag assert, 0: opposite.
N  */
N#define CLK_GET_POWERDOWNFLAG(clk, u8Flag)		(clk->PWRSTSF&u8Flag)
N
N/**
N  * @brief     Clear power down state.
N  * @param[in] clk Base address of CLK module.
N  * @param[in] u8Flag Power state flag.
N  *            - \ref CLK_PWRSTSF_SPDF
N  *            - \ref CLK_PWRSTSF_STOPF
N  *            - \ref CLK_PWRSTSF_DSF
N  * @return    None.
N  */
N#define CLK_CLEAR_POWERDOWNFLAG(clk, u8Flag)	(clk->PWRSTSF |= u8Flag)
N
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetHIRCFreq(void);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32HIRCType, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_SysTickDelay(uint32_t us);
Nvoid CLK_DeepPowerDown(uint32_t u32DPDWakeupMode, uint32_t u32TimerSel);
Nvoid CLK_StandbyPowerDown(void);
Nvoid CLK_DeepSleep(void);
Nvoid CLK_Sleep(void);
Nvoid CLK_EnableLDO( uint32_t u32LDOSel );
Nvoid CLK_DisableLDO(void);
N
N/*@}*/ /* end of group ISD9100_CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_CLK_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CLK_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9152 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "crc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\crc.h" 1
N/**************************************************************************//**
N * @file     crc.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 CRC Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N#ifndef __CRC_H__
N#define __CRC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N	/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_CRC_Driver CRC Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_CRC_EXPORTED_TYPEDEF CRC Exported Type Defines
N  @{
N*/
N
N#define	CRC_MSB (0)
N#define	CRC_LSB (CRC_CTL_MODE_Msk)
N
N/*@}*/ /* end of group ISD9100_CRC_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_CRC_EXPORTED_FUNCTIONS CRC Exported Functions
N  @{
N*/
N	
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Function Prototypes                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t CRC_Open(void);
Nint32_t CRC_Init(uint32_t eLSB, int32_t i32PacketLen);
Nint16_t CRC_Calc( uint32_t *Data, int32_t i32PacketLen);
Nvoid CRC_Close(void);
N
N/*@}*/ /* end of group ISD9100_CRC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_CRC_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9153 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "dpwm.h"
L 1 "..\..\..\..\Library\StdDriver\inc\dpwm.h" 1
N/**************************************************************************//**
N * @file     DPWM.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 14/07/04 07:27p $
N * @brief    ISD9100 Series DPWM Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __DPWM_H__
N#define __DPWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_DPWM_Driver DPWM Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_DPWM_EXPORTED_CONSTANTS DPWM Exported Constants
N  @{
N*/ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* DPWM CTL Constant Definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DPWM_CTL_MODUFRQ0       (0)       /*!< carrier modulation frequency0    */
N#define DPWM_CTL_MODUFRQ1       (1)       /*!< carrier modulation frequency1    */
N#define DPWM_CTL_MODUFRQ2       (2)       /*!< carrier modulation frequency2    */
N#define DPWM_CTL_MODUFRQ3       (3)       /*!< carrier modulation frequency3    */
N#define DPWM_CTL_MODUFRQ4       (4)       /*!< carrier modulation frequency4    */
N#define DPWM_CTL_MODUFRQ5       (5)       /*!< carrier modulation frequency5    */
N#define DPWM_CTL_MODUFRQ6       (6)       /*!< carrier modulation frequency6    */
N#define DPWM_CTL_MODUFRQ7       (7)       /*!< carrier modulation frequency7    */
N
N#define DPWM_CTL_DITHER_NONE    (0x0ul << DPWM_CTL_DITHEREN_Pos)       /*!< DPWM no dither bit    */
N#define DPWM_CTL_DITHER_ONE     (0x1ul << DPWM_CTL_DITHEREN_Pos)       /*!< DPWM +/- 1 dither bit    */
N#define DPWM_CTL_DITHER_TWO     (0x3ul << DPWM_CTL_DITHEREN_Pos)       /*!< DPWM +/- 2 dither bit    */
N
N/*@}*/ /* end of group ISD9100_DPWM_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_DPWM_EXPORTED_FUNCTIONS DPWM Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set DPWM dither type
N  * @param[in]  dpwm The base address of DPWM module
N  * @param[in]  u8Type is dither type
N  *             - \ref DPWM_CTL_DITHER_NONE
N  *             - \ref DPWM_CTL_DITHER_ONE
N  *             - \ref DPWM_CTL_DITHER_TWO
N  * @return     None
N  * @details    In order to prevent structured noise on PWM output due to DC offsets in the
N  *             input signal, it is possible to add random dither to the PWM signal.
N  */
N#define DPWM_SET_DITHER(dpwm, \
N                        u8Type)     (dpwm->CTL = (dpwm->CTL&~DPWM_CTL_DITHEREN_Msk)|u8Type)
X#define DPWM_SET_DITHER(dpwm,                         u8Type)     (dpwm->CTL = (dpwm->CTL&~DPWM_CTL_DITHEREN_Msk)|u8Type)
N
N/**
N  * @brief      Enable DPWM dead time
N  * @param[in]  dpwm The base address of DPWM module
N  * @return     None
N  * @details    Enabling dead time will insert an additional clock cycle 
N  *             into the switching of PMOS and NMOS driver transistors.
N  */
N#define DPWM_ENABLE_DEADTIME(dpwm)   (dpwm->CTL |= DPWM_CTL_DEADTIME_Msk)
N
N/**
N  * @brief      Disable DPWM dead time
N  * @param[in]  dpwm The base address of DPWM module
N  * @return     None
N  */
N#define DPWM_DISABLE_DEADTIME(dpwm)   (dpwm->CTL &= (~DPWM_CTL_DEADTIME_Msk))
N
N/**
N  * @brief      Set DPWM modulation frequency
N  * @param[in]  dpwm The base address of DPWM module
N  * @param[in]  u8Frq is modulation frequency type
N  *             - \ref DPWM_CTL_MODUFRQ0
N  *             - \ref DPWM_CTL_MODUFRQ1
N  *             - \ref DPWM_CTL_MODUFRQ2
N  *             - \ref DPWM_CTL_MODUFRQ3
N  *             - \ref DPWM_CTL_MODUFRQ4
N  *             - \ref DPWM_CTL_MODUFRQ5
N  *             - \ref DPWM_CTL_MODUFRQ6
N  *             - \ref DPWM_CTL_MODUFRQ7
N  * @return     None
N  * @details    This parameter controls the carrier modulation frequency of 
N  *             the PWM signal as a proportion of DPWM_CLK.
N  */
N#define DPWM_SET_MODFREQUENCY(dpwm, \
N                              u8Frq)  (dpwm->CTL = (dpwm->CTL&~DPWM_CTL_MODUFRQ_Msk)|u8Frq)
X#define DPWM_SET_MODFREQUENCY(dpwm,                               u8Frq)  (dpwm->CTL = (dpwm->CTL&~DPWM_CTL_MODUFRQ_Msk)|u8Frq)
N
N/**
N  * @brief      Get DPWM modulation frequency
N  * @param[in]  dpwm The base address of DPWM module
N  * @return     modulation frequency type
N  */
N#define DPWM_GET_MODFREQUENCY(dpwm)    (dpwm->CTL & DPWM_CTL_MODUFRQ_Msk)
N
N/**
N  * @brief      Check DPWM FIFO full or not
N  * @param[in]  dpwm The base address of DPWM module
N  * @return     0 = FIFO is not full
N  *             1 = FIFO is full
N  */
N#define DPWM_IS_FIFOFULL(dpwm)    (dpwm->STS&DPWM_STS_FULL_Msk)
N
N/**
N  * @brief      Check DPWM FIFO empty or not
N  * @param[in]  dpwm The base address of DPWM module
N  * @return     0 = FIFO is not empty
N  *             1 = FIFO is empty
N  */
N#define DPWM_IS_FIFOEMPTY(dpwm)    (dpwm->STS&DPWM_STS_EMPTY_Msk)
N
N/**
N  * @brief     Enable DPWM PDMA interface.
N  * @param[in] dpwm The base address of DPWM module
N  * @return    None.
N  * @details   DPWM will request data from PDMA controller whenever there is space in FIFO.
N  */
N#define DPWM_ENABLE_PDMA(dpwm)     (dpwm->DMACTL = 1)
N
N/**
N  * @brief     Disable DPWM PDMA interface.
N  * @param[in] dpwm The base address of DPWM module
N  * @return    None.
N  */
N#define DPWM_DISABLE_PDMA(dpwm)     (dpwm->DMACTL = 0)
N
N/**
N  * @brief     DPWM, SPK pins are enabled and driven, data is transferred from FIFO
N  * @param[in] dpwm The base address of DPWM module
N  * @return    None.
N  */
N#define DPWM_START_PLAY(dpwm)    (dpwm->CTL |= DPWM_CTL_DPWMEN_Msk)
N
N/**
N  * @brief     DPWM, SPK pins are tri-state, CIC filter is reset, FIFO pointers are reset
N  * @param[in] dpwm The base address of DPWM module
N  * @return    None.
N  */
N#define DPWM_STOP_PLAY(dpwm)     (dpwm->CTL &= (~DPWM_CTL_DPWMEN_Msk))
N
N/**
N  * @brief     Set input sample rate divisor of the DPWM
N  * @param[in] dpwm The base address of DPWM module
N  * @param[in] u8Divisor is zero order Hold, down-sampling divisor.
N  * @return    None
N  * @details   The input sample rate of the DPWM is set by HCLK frequency and the divisor 
N  *            set in this register by the following formula: 
N  *            
N  *            Fs = HCLK/u8Divisor/64
N  *            
N  *            Valid range is 1 to 255. Default is 48, which gives a sample rate of 16kHz 
N  *            for a 49.152MHz (default) HCLK.
N  *            The audio stream is sampled by a zero-order hold and fed to an up-sampling Cascaded
N  *            Integrator Comb (CIC) filter with an up-sampling ratio of 64.
N  */
N#define DPWM_SET_FSDIV(dpwm, \
N                       u8Divisor)    (dpwm->ZOHDIV = (u8Divisor&0xff))
X#define DPWM_SET_FSDIV(dpwm,                        u8Divisor)    (dpwm->ZOHDIV = (u8Divisor&0xff))
N
Nvoid DPWM_Open(void);
Nvoid DPWM_Close(void);
Nvoid DPWM_WriteFIFO(int16_t *pi16Stream, uint32_t u32count);
Nuint32_t DPWM_SetSampleRate(uint32_t u32SampleRate);
Nuint32_t DPWM_GetSampleRate(void);
N
N/*@}*/ /* end of group ISD9100_DPWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_DPWM_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__DPWM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9154 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "fmc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     fmc.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM Base Address           \hideinitializer */
N#define FMC_APROM_END           0x00023400UL    /*!< APROM End Address            \hideinitializer */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM Base Address           \hideinitializer */
N#define FMC_LDROM_END           0x00101000UL    /*!< LDROM End Address            \hideinitializer */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< User Configuration Address   \hideinitializer */
N
N#define FMC_FLASH_PAGE_SIZE     0x400           /*!< Flash Page Size (1 Kbytes)   \hideinitializer */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 Kbytes)        \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00            /*!< ISP Command: Read flash word          \hideinitializer */
N#define FMC_ISPCMD_WRITE        0x21            /*!< ISP Command: Write flash word         \hideinitializer */
N#define FMC_ISPCMD_PAGE_ERASE   0x22            /*!< ISP Command: Page Erase Flash         \hideinitializer */
N#define FMC_ISPCMD_READ_CID     0x0B            /*!< ISP Command: Read Company ID          \hideinitializer */
N#define FMC_ISPCMD_READ_DID     0x0C            /*!< ISP Command: Read Device ID           \hideinitializer */
N
N#define IS_BOOT_FROM_APROM      0               /*!< Is booting from APROM                 \hideinitializer */
N#define IS_BOOT_FROM_LDROM      1               /*!< Is booting from LDROM                 \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Flash Access Wait State constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_WAIT_ABOVE_72M	0x00
N#define FMC_WAIT_50M_72M		0x01
N#define FMC_WAIT_UNDER_50M	0x02
N
N/*@}*/ /* end of group ISD9100_FMC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Macros                                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define FMC_SET_APROM_BOOT()        (FMC->ISPCTL &= ~FMC_ISPCTL_BS_Msk)         /*!< Select booting from APROM   \hideinitializer */
N#define FMC_SET_LDROM_BOOT()        (FMC->ISPCTL |= FMC_ISPCTL_BS_Msk)          /*!< Select booting from LDROM   \hideinitializer */
N#define FMC_ENABLE_CFG_UPDATE()     (FMC->ISPCTL |=  FMC_ISPCTL_CFGUEN_Msk)     /*!< Enable User Config update   \hideinitializer */
N#define FMC_DISABLE_CFG_UPDATE()    (FMC->ISPCTL &= ~FMC_ISPCTL_CFGUEN_Msk)     /*!< Disable User Config update  \hideinitializer */
N#define FMC_ENABLE_LD_UPDATE()      (FMC->ISPCTL |=  FMC_ISPCTL_LDUEN_Msk)      /*!< Enable LDROM update         \hideinitializer */
N#define FMC_DISABLE_LD_UPDATE()     (FMC->ISPCTL &= ~FMC_ISPCTL_LDUEN_Msk)      /*!< Disable LDROM update        \hideinitializer */
N#define FMC_DISABLE_ISP()           (FMC->ISPCTL &= ~FMC_ISPCTL_ISPEN_Msk)      /*!< Disable ISP function        \hideinitializer */
N#define FMC_ENABLE_ISP()            (FMC->ISPCTL |=  FMC_ISPCTL_ISPEN_Msk)      /*!< Enable ISP function         \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Functions                                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
Nextern void FMC_SetBootSource(int32_t i32BootSrc);
Nextern void FMC_Close(void);
Nextern void FMC_DisableConfigUpdate(void);
Nextern void FMC_DisableLDUpdate(void);
Nextern void FMC_EnableConfigUpdate(void);
Nextern void FMC_EnableLDUpdate(void);
Nextern int32_t FMC_Erase(uint32_t u32PageAddr);
Nextern int32_t FMC_GetBootSource(void);
Nextern void FMC_Open(void);
Nextern void FMC_SetWaitState(uint32_t u32WaitCfg);
Nextern uint32_t FMC_Read(uint32_t u32Addr);
Nextern uint32_t FMC_ReadCID(void);
Nextern uint32_t FMC_ReadDID(void);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
Nextern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
N
N
N/*@}*/ /* end of group ISD9100_FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_FMC_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9155 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "gpio.h"
L 1 "..\..\..\..\Library\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     gpio.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 GPIO driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N	
N#define GPIO_PIN_MAX    16   /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_MODE_INPUT              0x0UL           /*!< Input Mode */
N#define GPIO_MODE_OUTPUT             0x1UL           /*!< Output Mode */
N#define GPIO_MODE_OPEN_DRAIN         0x2UL           /*!< Open-Drain Mode */
N#define GPIO_MODE_QUASI              0x3UL           /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL    /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL    /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL    /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL    /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW                0x01000001UL    /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  INTTYPE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INTTYPE_EDGE               0UL             /*!< INTTYPE Setting for Edge Trigger Mode */
N#define GPIO_INTTYPE_LEVEL              1UL             /*!< INTTYPE Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBCTL Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBCTL_ICLK_ON           0x00000020UL /*!< DBCTL setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_DBCTL_ICLK_OFF          0x00000000UL /*!< DBCTL setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCTL_DBCLKSRC_IRC10K   0x00000010UL /*!< DBCTL setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCTL_DBCLKSRC_HCLK     0x00000000UL /*!< DBCTL setting for de-bounce counter clock source is the internal HCLK */
N
N#define GPIO_DBCTL_DBCLKSEL_1        0x00000000UL /*!< DBCTL setting for sampling cycle = 1 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2        0x00000001UL /*!< DBCTL setting for sampling cycle = 2 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4        0x00000002UL /*!< v setting for sampling cycle = 4 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8        0x00000003UL /*!< DBCTL setting for sampling cycle = 8 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16       0x00000004UL /*!< DBCTL setting for sampling cycle = 16 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32       0x00000005UL /*!< DBCTL setting for sampling cycle = 32 clocks */
N#define GPIO_DBCTL_DBCLKSEL_64       0x00000006UL /*!< DBCTL setting for sampling cycle = 64 clocks */
N#define GPIO_DBCTL_DBCLKSEL_128      0x00000007UL /*!< DBCTL setting for sampling cycle = 128 clocks */
N#define GPIO_DBCTL_DBCLKSEL_256      0x00000008UL /*!< DBCTL setting for sampling cycle = 256 clocks */
N#define GPIO_DBCTL_DBCLKSEL_512      0x00000009UL /*!< DBCTL setting for sampling cycle = 512 clocks */
N#define GPIO_DBCTL_DBCLKSEL_1024     0x0000000AUL /*!< DBCTL setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2048     0x0000000BUL /*!< DBCTL setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4096     0x0000000CUL /*!< DBCTL setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8192     0x0000000DUL /*!< DBCTL setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16384    0x0000000EUL /*!< DBCTL setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32768    0x0000000FUL /*!< DBCTL setting for sampling cycle = 32768 clocks */
N
N/*@}*/ /* end of group ISD9100_GPIO_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(gpio, u32PinMask)   ((gpio)->INTSRC = u32PinMask)
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(gpio, u32PinMask)   ((gpio)->DBEN &= ~u32PinMask)
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(gpio, u32PinMask)    ((gpio)->DBEN |= u32PinMask)
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(gpio, u32PinMask)   ((gpio)->DINOFF |= (u32PinMask << 16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(gpio, u32PinMask)    ((gpio)->DINOFF &= ~(u32PinMask << 16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DATMSK |= u32PinMask)
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DATMSK &= ~u32PinMask)
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(gpio, u32PinMask)   ((gpio)->INTSRC & u32PinMask)
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be GPIO_DBCTL_DBCLKSRC_HCLK or GPIO_DBCTL_DBCLKSRC_IRC10K.
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be \n
N *                              GPIO_DBCTL_DBCLKSEL_1, GPIO_DBCTL_DBCLKSEL_2, GPIO_DBCTL_DBCLKSEL_4, GPIO_DBCTL_DBCLKSEL_8, \n
N *                              GPIO_DBCTL_DBCLKSEL_16, GPIO_DBCTL_DBCLKSEL_32, GPIO_DBCTL_DBCLKSEL_64, GPIO_DBCTL_DBCLKSEL_128, \n
N *                              GPIO_DBCTL_DBCLKSEL_256, GPIO_DBCTL_DBCLKSEL_512, GPIO_DBCTL_DBCLKSEL_1024, GPIO_DBCTL_DBCLKSEL_2048, \n
N *                              GPIO_DBCTL_DBCLKSEL_4096, GPIO_DBCTL_DBCLKSEL_8192, GPIO_DBCTL_DBCLKSEL_16384, GPIO_DBCTL_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_IRC10K, GPIO_DBCTL_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)  (GPIO->DBCTL = (GPIO_DBCTL_ICLKON_Msk | u32ClkSrc | u32ClkSel))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N *
N * @retval      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(gpio)   ((gpio)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N * @param[in]   u32Data     GPIO port data.
N *
N * @retval      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(gpio, u32Data)   ((gpio)->DOUT = (u32Data))
N
N/**
N * @brief       Get GPIO Port OUT Data
N *
N * @param[in]   gpio        GPIO port. It could be PA, PB.
N *
N * @retval      None
N *
N * @details     Get the Data into specified GPIO port.
N */
N#define GPIO_GET_OUT_DATA(gpio)   ((gpio)->DOUT)
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin       Pxy
N *
N * @retval      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin)   ((u32Pin) ^= 1)
N
N
Nvoid GPIO_SetMode(GPIO_T *gpio, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *gpio, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *gpio, uint32_t u32Pin);
N
N/*@}*/ /* end of group ISD9100_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_GPIO_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9156 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "i2c.h"
L 1 "..\..\..\..\Library\StdDriver\inc\i2c.h" 1
N/****************************************************************************//**
N * @file     i2c.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 I2C driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N#define I2C_STA 0x20    /*!< I2C START bit value  \hideinitializer */
N#define I2C_STO 0x10    /*!< I2C STOP bit value  \hideinitializer */
N#define I2C_SI  0x08    /*!< I2C SI bit value  \hideinitializer */
N#define I2C_AA  0x04    /*!< I2C ACK bit value  \hideinitializer */
N
N#define I2C_GCMODE_ENABLE   1    /*!< Enable I2C GC Mode  \hideinitializer */
N#define I2C_GCMODE_DISABLE  0    /*!< Disable I2C GC Mode  \hideinitializer */
N
N/*@}*/ /* end of group ISD9100_I2C_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro sets the I2C control register at one time.
N  * @param i2c is the base address of I2C module.
N  * @param u8Ctrl is the register value of I2C control register.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ( (i2c)->CTL = ((i2c)->CTL & ~0x3c) | u8Ctrl )
N
N/**
N  * @brief This macro only set START bit to the control register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_START(i2c) ( (i2c)->CTL = ((i2c)->CTL & ~I2C_CTL_SI_Msk) | I2C_CTL_STA_Msk )
N
N/**
N  * @brief This macro only set STOP bit to the control register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_STOP(i2c) ( (i2c)->CTL = ((i2c)->CTL & ~0x3c) | I2C_CTL_SI_Msk | I2C_CTL_STO_Msk )
N
N/**
N  * @brief This macro will return when I2C module is ready.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_WAIT_READY(i2c) while(!((i2c)->CTL & I2C_CTL_SI_Msk))
N
N/**
N  * @brief This macro returns the data stored in data register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return Data.
N  * \hideinitializer
N  */
N#define I2C_GET_DATA(i2c) ( (i2c)->DAT )
N
N/**
N  * @brief This macro writes the data to data register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @param u8Data is the data which will be write to data register of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_SET_DATA(i2c, u8Data) ( (i2c)->DAT = u8Data )
N
N/**
N  * @brief This macro returns the status of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  * \hideinitializer
N  */
N#define I2C_GET_STATUS(i2c) ( (i2c)->STATUS )
N
N/**
N  * @brief This macro returns timeout flag.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  * \hideinitializer
N  */
N#define I2C_GET_TIMEOUT_FLAG(i2c) ( ((i2c)->TOCTL & I2C_TOCTL_TOIF_Msk) == I2C_TOCTL_TOIF_Msk ? 1:0  )
N
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
N
N/*@}*/ /* end of group ISD9100_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_I2C_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__I2C_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9157 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "i2s.h"
L 1 "..\..\..\..\Library\StdDriver\inc\i2s.h" 1
N/******************************************************************************
N * @file     i2s.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 I2S driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __I2S_H__
N#define __I2S_H__
N
N#include "ISD9100.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 1
N/**************************************************************************//**
N * @file     ISD9100.h
N * @version  V3.0
N * $Revision: 32 $
N * $Date: 14/07/11 11:06a $
N * @brief    ISD9100 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of ISD9100 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_DIR Directory Structure
N  * 
N  * Please refer to Readme.pdf under BSP root directory for the BSP directory structure. 
N  *
N  * \page PG_REV Revision History
N  *
N  *
N  * <b>Revision 3.00.001</b>
N  * \li Updated to support new API
N*/
N
N#ifndef __ISD9100_H__
S#define __ISD9100_H__
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S*/
S
S/** @addtogroup ISD93XX_CMSIS Device Definitions for CMSIS
S  ISD93XX Interrupt Number Definition and Configurations for CMSIS
S  @{
S*/
S
S/**
S * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
S */
S
Stypedef enum IRQn
S    {
S        /******  Cortex-M0 Processor Exceptions Numbers *************************************************/
S        NonMaskableInt_IRQn       = -14,    /*!< 2 Non Maskable Interrupt                               */
S        HardFault_IRQn		      = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
S        SVCall_IRQn               = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                         */
S        PendSV_IRQn               = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                         */
S        SysTick_IRQn              = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                     */
S        /******  ARMIKMCU Swift specific Interrupt Numbers **********************************************/
S        BOD_IRQn                  = 0,      /*!< 16 Brown Out Detector Device Interrupt               */
S        WDT_IRQn                  = 1,      /*!< 17 Watchdog Timer Device Interrupt                   */
S        EINT0_IRQn                = 2,      /*!< 18 External Interrupt PB0 Interrupt                  */
S        EINT1_IRQn                = 3,      /*!< 19 External Interrupt PB1 Interrupt                  */
S        GPAB_IRQn                 = 4,      /*!< 20 GPIO Interrupt                                    */
S        ALC_IRQn                  = 5,      /*!< 21 ALC Interrupt                                     */
S        PWM0_IRQn                 = 6,      /*!< 22 PWM 0 Peripheral Device Interrupt                 */
S        IRQ7n                     = 7,
S        TMR0_IRQn                 = 8,      /*!< 24 Timer 0 Interrupt                                 */
S        TMR1_IRQn                 = 9,      /*!< 25 Timer 1 Interrupt                                 */
S        IRQ10n                    = 10,
S        IRQ11n                    = 11,
S        UART0_IRQn                = 12,     /*!< 28 UART Device Interrupt                            */
S        IRQ13n                    = 13,
S        SPI0_IRQn                 = 14,     /*!< 30 SPI Interface Interrupt                          */
S        IRQ15n                    = 15,
S        IRQ16n                    = 16,
S        IRQ17n                    = 17,
S        I2C0_IRQn                 = 18,     /*!< 34 I2C Interface Interrupt                          */
S        IRQ19n                    = 19,
S        IRQ20n                    = 20,
S        TALARM_IRQn               = 21,     /*!< 37 Temperature Alaram Interrupt                     */
S        IRQ22n                    = 22,
S        IRQ23n                    = 23,
S        IRQ24n                    = 24,
S        ACMP_IRQn                 = 25,     /*!< 41 Analog Comparator Interrupt                      */
S        PDMA_IRQn                 = 26,     /*!< 42 Peripheral DMA Interrupt                         */
S        I2S0_IRQn                  = 27,    /*!< 43 I2S Interface Device Interrupt                   */
S        CAPS_IRQn                 = 28,     /*!< 44 CapSense Device Interrupt                        */
S        ADC_IRQn                  = 29,     /*!< 45 Audio ADC Device Interrupt                       */
S        IRQ30n                    = 30,
S        RTC_IRQn                  = 31      /*!< 47 Real Time Clock Interrupt                        */
S
S        /*!< maximum of 32 Interrupts are possible                */
S    } IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S/*@}*/ /* end of group ISD9100_CMSIS */
S
S#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
S#include "system_ISD9100.h"              /* ISD9xx System include file                             */
S
S#if defined ( __CC_ARM   )
S  #pragma anon_unions
S#elif  ( defined (__ICCARM__) )
S// IAR C compiler detected
S  #define __wfi       __WFI
S  #ifndef __STATIC_INLINE
S    #define __STATIC_INLINE  static inline
S  #endif
S/*
SUsage of #define
S  #define A(x)  T_##x
S  #define B]x) #@x
S  #define C]x) #x
S
S  A(1)------>T_1
S  B(1)------>'1'
S  C(1)------>"1"
S*/
S  #define __quote(n)      #n
S  #define __iar_align(n)  __quote(data_alignment=##n)
S  #define __align(n)      _Pragma(__iar_align(n))
S#endif
S
S
S/******************************************************************************/
S/*                Device Specific Peripheral registers structures             */
S/******************************************************************************/
S
S/** @addtogroup REGISTER Control Register
S
S  @{
S
S*/
S
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/**
S    @addtogroup ACMP Analog Comparator Controller(ACMP)
S    Memory Mapped Structure for ACMP Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL0
S     * ===================================================================================================
S     * Offset: 0x00  Analog Comparator 0 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ACMPEN    |Comparator Enable
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |[1]     |ACMPIE    |CMP0 Interrupt Enable
S     * |        |          |0 = Disable CMP0 interrupt function
S     * |        |          |1 = Enable CMP0 interrupt function
S     * |[4]     |NEGSEL    |Comparator0 Negative Input Select
S     * |        |          |0 = VBG, Bandgap reference voltage = 1.2V
S     * |        |          |1 = VMID reference voltage = VCCA/2
S */
S    __IO uint32_t CTL0;                  
S
S    /**
S     * CTL1
S     * ===================================================================================================
S     * Offset: 0x04  Analog Comparator 1 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ACMPEN    |Comparator Enable
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |[1]     |ACMPIE    |CMP1 Interrupt Enable
S     * |        |          |0 = Disable CMP1interrupt function
S     * |        |          |1 = Enable CMP1 interrupt function
S     * |[4]     |NEGSEL    |Comparator1 Negative Input Select
S     * |        |          |0 = GPIOB[7]
S     * |        |          |1 = VBG, Bandgap reference voltage = 1.2V 
S */
S    __IO uint32_t CTL1;                  
S
S    /**
S     * STATUS
S     * ===================================================================================================
S     * Offset: 0x08  Comparator Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ACMPIF0   |Compare 0 Flag
S     * |        |          |This bit is set by hardware whenever the comparator output changes state.
S     * |        |          |This bit will cause a hardware interrupt if enabled.
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[1]     |ACMPIF1   |Compare 1 Flag
S     * |        |          |This bit is set by hardware whenever the comparator output changes state.
S     * |        |          |This bit will cause a hardware interrupt if enabled.
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[2]     |ACMPO0    |Comparator0 Output
S     * |        |          |Synchronized to the APB clock to allow reading by software.
S     * |        |          |Cleared when the comparator is disabled (CMP0EN = 0).
S     * |[3]     |ACMPO1    |Comparator1 Output
S     * |        |          |Synchronized to the APB clock to allow reading by software.
S     * |        |          |Cleared when the comparator is disabled (CMP1EN = 0).
S */
S    __IO uint32_t STATUS;                
S
S    /**
S     * POSSEL
S     * ===================================================================================================
S     * Offset: 0x0C  Comparator Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |POSSEL    |Comparator0 GPIO Selection
S     * |        |          |GPIOB[POSSEL] is the active analog GPIO input selected to Comparator 0 positive input. 
S */
S    __IO uint32_t POSSEL;                
S
S} ACMP_T;
S
S/**
S    @addtogroup ACMP_CONST ACMP Bit Field Definition
S    Constant Definitions for ACMP Controller
S@{ */
S
S#define ACMP_CTL0_ACMPEN_Pos             (0)                                               /*!< ACMP CTL0: ACMPEN Position             */
S#define ACMP_CTL0_ACMPEN_Msk             (0x1ul << ACMP_CTL0_ACMPEN_Pos)                   /*!< ACMP CTL0: ACMPEN Mask                 */
S
S#define ACMP_CTL0_ACMPIE_Pos             (1)                                               /*!< ACMP CTL0: ACMPIE Position             */
S#define ACMP_CTL0_ACMPIE_Msk             (0x1ul << ACMP_CTL0_ACMPIE_Pos)                   /*!< ACMP CTL0: ACMPIE Mask                 */
S
S#define ACMP_CTL0_NEGSEL_Pos             (4)                                               /*!< ACMP CTL0: NEGSEL Position             */
S#define ACMP_CTL0_NEGSEL_Msk             (0x1ul << ACMP_CTL0_NEGSEL_Pos)                   /*!< ACMP CTL0: NEGSEL Mask                 */
S
S#define ACMP_CTL1_ACMPEN_Pos             (0)                                               /*!< ACMP CTL1: ACMPEN Position             */
S#define ACMP_CTL1_ACMPEN_Msk             (0x1ul << ACMP_CTL1_ACMPEN_Pos)                   /*!< ACMP CTL1: ACMPEN Mask                 */
S
S#define ACMP_CTL1_ACMPIE_Pos             (1)                                               /*!< ACMP CTL1: ACMPIE Position             */
S#define ACMP_CTL1_ACMPIE_Msk             (0x1ul << ACMP_CTL1_ACMPIE_Pos)                   /*!< ACMP CTL1: ACMPIE Mask                 */
S
S#define ACMP_CTL1_NEGSEL_Pos             (4)                                               /*!< ACMP CTL1: NEGSEL Position             */
S#define ACMP_CTL1_NEGSEL_Msk             (0x1ul << ACMP_CTL1_NEGSEL_Pos)                   /*!< ACMP CTL1: NEGSEL Mask                 */
S
S#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP STATUS: ACMPIF0 Position          */
S#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP STATUS: ACMPIF0 Mask              */
S
S#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP STATUS: ACMPIF1 Position          */
S#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP STATUS: ACMPIF1 Mask              */
S
S#define ACMP_STATUS_ACMPO0_Pos           (2)                                               /*!< ACMP STATUS: ACMPO0 Position           */
S#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP STATUS: ACMPO0 Mask               */
S
S#define ACMP_STATUS_ACMPO1_Pos           (3)                                               /*!< ACMP STATUS: ACMPO1 Position           */
S#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP STATUS: ACMPO1 Mask               */
S
S#define ACMP_POSSEL_POSSEL_Pos           (0)                                               /*!< ACMP POSSEL: POSSEL Position           */
S#define ACMP_POSSEL_POSSEL_Msk           (0x7ul << ACMP_POSSEL_POSSEL_Pos)                 /*!< ACMP POSSEL: POSSEL Mask               */
S
S/**@}*/ /* ACMP_CONST */
S/**@}*/ /* end of ACMP register group */
S
S
S/*---------------------- Analog to Digital Converter -------------------------*/
S/**
S    @addtogroup ADC Analog to Digital Converter(ADC)
S    Memory Mapped Structure for ADC Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * DAT
S     * ===================================================================================================
S     * Offset: 0x00  ADC FIFO Data Out.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |RESULT    |ADC Audio Data FIFO Read
S     * |        |          |A read of this register will read data from the audio FIFO and increment the read pointer.
S     * |        |          |A read past empty will repeat the last data.
S     * |        |          |Can be used with FIFOINTLV interrupt to determine if valid data is present in FIFO.
S */
S    __I  uint32_t DAT;                   
S
S    /**
S     * CHEN
S     * ===================================================================================================
S     * Offset: 0x04  ADC Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHEN      |ADC Enable
S     * |        |          |0 = Conversion stopped and ADC is reset including FIFO pointers.
S     * |        |          |1 = ADC Conversion enabled.
S */
S    __IO uint32_t CHEN;                  
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x08  ADC Clock Divider Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |CLKDIV    |ADC Clock Divider
S     * |        |          |This register determines the clock division ration between the incoming ADC_CLK (= HCLK by default) and the Delta-Sigma sampling clock of the ADC.
S     * |        |          |This together with the over-sampling ratio (OSR) determines the audio sample rate of the converter.
S     * |        |          |CLKDIV should be set to give a SD_CLK frequency in the range of 1.024-6.144MHz.
S     * |        |          |CLKDIV must be greater than 2.
S     * |        |          |SD_CLK frequency = HCLK / CLKDIV
S */
S    __IO uint32_t CLKDIV;                
S
S    /**
S     * DCICTL
S     * ===================================================================================================
S     * Offset: 0x0C  ADC Decimation Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |OVSPLRAT  |Decimation Over-Sampling Ratio
S     * |        |          |This term determines the over-sampling ratio of the decimation filter. Valid values are:
S     * |        |          |0: OVSPLRAT = 64
S     * |        |          |1: OVSPLRAT = 128
S     * |        |          |2: OVSPLRAT = 192
S     * |        |          |3: OVSPLRAT = 384
S     * |[16:19] |GAIN      |CIC Filter Additional Gain
S     * |        |          |This should normally remain default 0.
S     * |        |          |Can be set to non-zero values to provide additional digital gain from the decimation filter.
S     * |        |          |An additional gain is applied to signal of GAIN/2.
S */
S    __IO uint32_t DCICTL;                
S
S    /**
S     * INTCTL
S     * ===================================================================================================
S     * Offset: 0x10  ADC Interrupt Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |FIFOINTLV |FIFO Interrupt Level
S     * |        |          |Determines at what level the ADC FIFO will generate a servicing interrupt to the CPU.
S     * |        |          |Interrupt will be generated when number of words present in ADC FIFO is > FIFOINTLV.
S     * |[31]    |INTEN     |Interrupt Enable
S     * |        |          |If set to '1' an interrupt is generated whenever FIFO level exceeds that set in FIFOINTLV.
S */
S    __IO uint32_t INTCTL;                
S
S    /**
S     * PDMACTL
S     * ===================================================================================================
S     * Offset: 0x14  ADC PDMA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXDMAEN   |Enable ADC PDMA Receive Channel
S     * |        |          |Enable ADC PDMA. If set, then ADC will request PDMA service when data is available.
S */
S    __IO uint32_t PDMACTL;               
S
S    /**
S     * CMP0
S     * ===================================================================================================
S     * Offset: 0x18  ADC Comparator 0 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADCMPEN   |Compare Enable
S     * |        |          |0 = Disable compare.
S     * |        |          |1 = Enable compare.
S     * |        |          |Set this bit to 1 to enable compare CMPDAT with FIFO data output.
S     * |[1]     |ADCMPIE   |Compare Interrupt Enable
S     * |        |          |0 = Disable compare function interrupt.
S     * |        |          |1 = Enable compare function interrupt.
S     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, CMPFLAG bit will be asserted, if ADCMPIE is set to 1, a compare interrupt request is generated.
S     * |[2]     |CMPCOND   |Compare Condition
S     * |        |          |0= Set the compare condition that result is less than CMPDAT
S     * |        |          |1= Set the compare condition that result is greater or equal to CMPDAT
S     * |        |          |Note: When the internal counter reaches the value (CMPMCNT +1), the CMPFLAG bit will be set.
S     * |[7]     |CMPFLAG   |Compare Flag
S     * |        |          |When the conversion result meets condition in ADCMPR0 this bit is set to 1.
S     * |        |          |It is cleared by writing 1 to self.
S     * |[8:11]  |CMPMCNT   |Compare Match Count
S     * |        |          |When the A/D FIFO result matches the compare condition defined by CMPCOND, the internal match counter will increase by 1.
S     * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the CMPFLAG bit will be set.
S     * |[16:31] |CMPDAT    |Comparison Data
S     * |        |          |16 bit value to compare to FIFO output word.
S */
S    __IO uint32_t CMP0;                  
S
S    /**
S     * CMP1
S     * ===================================================================================================
S     * Offset: 0x1C  ADC Comparator 1 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADCMPEN   |Compare Enable
S     * |        |          |0 = Disable compare.
S     * |        |          |1 = Enable compare.
S     * |        |          |Set this bit to 1 to enable compare CMPDAT with FIFO data output.
S     * |[1]     |ADCMPIE   |Compare Interrupt Enable
S     * |        |          |0 = Disable compare function interrupt.
S     * |        |          |1 = Enable compare function interrupt.
S     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, CMPFLAG bit will be asserted, if ADCMPIE is set to 1, a compare interrupt request is generated.
S     * |[2]     |CMPCOND   |Compare Condition
S     * |        |          |0= Set the compare condition that result is less than CMPDAT
S     * |        |          |1= Set the compare condition that result is greater or equal to CMPDAT
S     * |        |          |Note: When the internal counter reaches the value (CMPMCNT +1), the CMPFLAG bit will be set.
S     * |[7]     |CMPFLAG   |Compare Flag
S     * |        |          |When the conversion result meets condition in ADCMPR0 this bit is set to 1.
S     * |        |          |It is cleared by writing 1 to self.
S     * |[8:11]  |CMPMCNT   |Compare Match Count
S     * |        |          |When the A/D FIFO result matches the compare condition defined by CMPCOND, the internal match counter will increase by 1.
S     * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the CMPFLAG bit will be set.
S     * |[16:31] |CMPDAT    |Comparison Data
S     * |        |          |16 bit value to compare to FIFO output word.
S */
S    __IO uint32_t CMP1;                  
S
S} ADC_T;
S
S/**
S    @addtogroup ADC_CONST ADC Bit Field Definition
S    Constant Definitions for ADC Controller
S@{ */
S
S#define ADC_DAT_RESULT_Pos               (0)                                               /*!< ADC DAT: RESULT Position               */
S#define ADC_DAT_RESULT_Msk               (0xfffful << ADC_DAT_RESULT_Pos)                  /*!< ADC DAT: RESULT Mask                   */
S
S#define ADC_CHEN_CHEN_Pos                (0)                                               /*!< ADC CHEN: CHEN Position                */
S#define ADC_CHEN_CHEN_Msk                (0x1ul << ADC_CHEN_CHEN_Pos)                      /*!< ADC CHEN: CHEN Mask                    */
S
S#define ADC_CLKDIV_CLKDIV_Pos            (0)                                               /*!< ADC CLKDIV: CLKDIV Position            */
S#define ADC_CLKDIV_CLKDIV_Msk            (0xfful << ADC_CLKDIV_CLKDIV_Pos)                 /*!< ADC CLKDIV: CLKDIV Mask                */
S
S#define ADC_DCICTL_OVSPLRAT_Pos          (0)                                               /*!< ADC DCICTL: OVSPLRAT Position          */
S#define ADC_DCICTL_OVSPLRAT_Msk          (0xful << ADC_DCICTL_OVSPLRAT_Pos)                /*!< ADC DCICTL: OVSPLRAT Mask              */
S
S#define ADC_DCICTL_GAIN_Pos              (16)                                              /*!< ADC DCICTL: GAIN Position              */
S#define ADC_DCICTL_GAIN_Msk              (0xful << ADC_DCICTL_GAIN_Pos)                    /*!< ADC DCICTL: GAIN Mask                  */
S
S#define ADC_INTCTL_FIFOINTLV_Pos         (0)                                               /*!< ADC INTCTL: FIFOINTLV Position         */
S#define ADC_INTCTL_FIFOINTLV_Msk         (0x7ul << ADC_INTCTL_FIFOINTLV_Pos)               /*!< ADC INTCTL: FIFOINTLV Mask             */
S
S#define ADC_INTCTL_INTEN_Pos             (31)                                              /*!< ADC INTCTL: INTEN Position             */
S#define ADC_INTCTL_INTEN_Msk             (0x1ul << ADC_INTCTL_INTEN_Pos)                   /*!< ADC INTCTL: INTEN Mask                 */
S
S#define ADC_PDMACTL_RXDMAEN_Pos          (0)                                               /*!< ADC PDMACTL: RXDMAEN Position          */
S#define ADC_PDMACTL_RXDMAEN_Msk          (0x1ul << ADC_PDMACTL_RXDMAEN_Pos)                /*!< ADC PDMACTL: RXDMAEN Mask              */
S
S#define ADC_CMP0_ADCMPEN_Pos             (0)                                               /*!< ADC CMP0: ADCMPEN Position             */
S#define ADC_CMP0_ADCMPEN_Msk             (0x1ul << ADC_CMP0_ADCMPEN_Pos)                   /*!< ADC CMP0: ADCMPEN Mask                 */
S
S#define ADC_CMP0_ADCMPIE_Pos             (1)                                               /*!< ADC CMP0: ADCMPIE Position             */
S#define ADC_CMP0_ADCMPIE_Msk             (0x1ul << ADC_CMP0_ADCMPIE_Pos)                   /*!< ADC CMP0: ADCMPIE Mask                 */
S
S#define ADC_CMP0_CMPCOND_Pos             (2)                                               /*!< ADC CMP0: CMPCOND Position             */
S#define ADC_CMP0_CMPCOND_Msk             (0x1ul << ADC_CMP0_CMPCOND_Pos)                   /*!< ADC CMP0: CMPCOND Mask                 */
S
S#define ADC_CMP0_CMPFLAG_Pos             (7)                                               /*!< ADC CMP0: CMPFLAG Position             */
S#define ADC_CMP0_CMPFLAG_Msk             (0x1ul << ADC_CMP0_CMPFLAG_Pos)                   /*!< ADC CMP0: CMPFLAG Mask                 */
S
S#define ADC_CMP0_CMPMCNT_Pos             (8)                                               /*!< ADC CMP0: CMPMCNT Position             */
S#define ADC_CMP0_CMPMCNT_Msk             (0xful << ADC_CMP0_CMPMCNT_Pos)                   /*!< ADC CMP0: CMPMCNT Mask                 */
S
S#define ADC_CMP0_CMPDAT_Pos              (16)                                              /*!< ADC CMP0: CMPDAT Position              */
S#define ADC_CMP0_CMPDAT_Msk              (0xfffful << ADC_CMP0_CMPDAT_Pos)                 /*!< ADC CMP0: CMPDAT Mask                  */
S
S#define ADC_CMP1_ADCMPEN_Pos             (0)                                               /*!< ADC CMP1: ADCMPEN Position             */
S#define ADC_CMP1_ADCMPEN_Msk             (0x1ul << ADC_CMP1_ADCMPEN_Pos)                   /*!< ADC CMP1: ADCMPEN Mask                 */
S
S#define ADC_CMP1_ADCMPIE_Pos             (1)                                               /*!< ADC CMP1: ADCMPIE Position             */
S#define ADC_CMP1_ADCMPIE_Msk             (0x1ul << ADC_CMP1_ADCMPIE_Pos)                   /*!< ADC CMP1: ADCMPIE Mask                 */
S
S#define ADC_CMP1_CMPCOND_Pos             (2)                                               /*!< ADC CMP1: CMPCOND Position             */
S#define ADC_CMP1_CMPCOND_Msk             (0x1ul << ADC_CMP1_CMPCOND_Pos)                   /*!< ADC CMP1: CMPCOND Mask                 */
S
S#define ADC_CMP1_CMPFLAG_Pos             (7)                                               /*!< ADC CMP1: CMPFLAG Position             */
S#define ADC_CMP1_CMPFLAG_Msk             (0x1ul << ADC_CMP1_CMPFLAG_Pos)                   /*!< ADC CMP1: CMPFLAG Mask                 */
S
S#define ADC_CMP1_CMPMCNT_Pos             (8)                                               /*!< ADC CMP1: CMPMCNT Position             */
S#define ADC_CMP1_CMPMCNT_Msk             (0xful << ADC_CMP1_CMPMCNT_Pos)                   /*!< ADC CMP1: CMPMCNT Mask                 */
S
S#define ADC_CMP1_CMPDAT_Pos              (16)                                              /*!< ADC CMP1: CMPDAT Position              */
S#define ADC_CMP1_CMPDAT_Msk              (0xfffful << ADC_CMP1_CMPDAT_Pos)                 /*!< ADC CMP1: CMPDAT Mask                  */
S
S/**@}*/ /* ADC_CONST */
S/**@}*/ /* end of ADC register group */
S
S
S/*---------------------- Automatic Level Control -------------------------*/
S/**
S    @addtogroup ALC Automatic Level Control(ALC)
S    Memory Mapped Structure for ALC Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  ALC Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |NGTHBST   |Noise Gate Threshold
S     * |        |          |Boost disabled: Threshold = (-81+6xNGTHBST) dB
S     * |        |          |Boost enabled: Threshold = (-87+6xNGTHBST) dB
S     * |[3]     |NGEN      |Noise Gate Enable
S     * |        |          |0 = Noise gate disabled
S     * |        |          |1 = Noise gate enabled
S     * |[4:7]   |ATKSEL    |ALC Attack Time
S     * |        |          |(Value: 0~10)
S     * |        |          |When MODESEL = 0, Range: 500us to 512ms
S     * |        |          |When MODESEL = 1,Range: 125us to 128ms (Both ALC time doubles with every step)
S     * |[8:11]  |DECAYSEL  |ALC Decay Time
S     * |        |          |(Value: 0~10)
S     * |        |          |When MODESEL = 0, Range: 125us to 128ms
S     * |        |          |When MODESEL = 1, Range: 31us to 32ms (time doubles with every step)
S     * |[12]    |MODESEL   |ALC Mode
S     * |        |          |0 = ALC normal operation mode
S     * |        |          |1 = ALC limiter mode
S     * |[13:16] |TARGETLV  |ALC Target Level
S     * |        |          |0 = -28.5 dB
S     * |        |          |1 = -27 dB
S     * |        |          |2 = -25.5 dB
S     * |        |          |3 = -24 dB
S     * |        |          |4 = -22.5 dB
S     * |        |          |5 = -21 dB
S     * |        |          |6 = -19.5 dB
S     * |        |          |7 = -18 dB
S     * |        |          |8 = -16.5 dB
S     * |        |          |9 = -15 dB
S     * |        |          |10 = -13.5 dB
S     * |        |          |11 = -12 dB
S     * |        |          |12 = -10.5 dB
S     * |        |          |13 = -9 dB
S     * |        |          |14 = -7.5 dB
S     * |        |          |15 = -6 dB
S     * |[17:20] |HOLDTIME  |ALC Hold Time
S     * |        |          |(Value: 0~10). Hold Time = (2^HOLDTIME) ms
S     * |[21]    |ZCEN      |ALC Zero Crossing
S     * |        |          |0 = zero crossing disabled
S     * |        |          |1 = zero crossing enabled
S     * |[22:24] |MINGAIN   |ALC Minimum Gain
S     * |        |          |0 = -12 dB
S     * |        |          |1 = -6 dB
S     * |        |          |2 = 0 dB
S     * |        |          |3 = 6 dB
S     * |        |          |4 = 12 dB
S     * |        |          |5 = 18 dB
S     * |        |          |6 = 24 dB
S     * |        |          |7 = 30 dB
S     * |[25:27] |MAXGAIN   |ALC Maximum Gain
S     * |        |          |0 = -6.75 dB
S     * |        |          |1 = -0.75 dB
S     * |        |          |2 = +5.25 dB
S     * |        |          |3 = +11.25 dB
S     * |        |          |4 = +17.25 dB
S     * |        |          |5 = +23.25 dB
S     * |        |          |6 = +29.25 dB
S     * |        |          |7 = +35.25 dB
S     * |[28]    |ALCEN     |ALC select
S     * |        |          |0 = ALC disabled (default)
S     * |        |          |1 = ALC enabled
S     * |[29]    |NGPKSEL   |ALC noise gate peak detector select
S     * |        |          |0 = use peak-to-peak value for noise gate threshold determination (default)
S     * |        |          |1 = use absolute peak value for noise gate threshold determination
S     * |[30]    |PKSEL     |ALC gain peak detector select
S     * |        |          |0 = use absolute peak value for ALC training (default)
S     * |        |          |1 = use peak-to-peak value for ALC training
S     * |[31]    |PKLIMEN   |ALC peak limiter enable
S     * |        |          |0 = enable fast decrement when signal exceeds 87.5% of full scale (default)
S     * |        |          |1 = disable fast decrement when signal exceeds 87.5% of full scale
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * STS
S     * ===================================================================================================
S     * Offset: 0x04  ALC status register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CLIPFLAG  |Clipping Flag
S     * |        |          |Asserted when signal level is detected to be above 87.5% of full scale
S     * |[1]     |NOISEF    |Noise Flag
S     * |        |          |Asserted when signal level is detected to be below NGTHBST
S     * |[2:10]  |P2PVAL    |Peak-To-Peak Value
S     * |        |          |9 MSBs of measured peak-to-peak value
S     * |[11:18] |PEAKVAL   |Peak Value
S     * |        |          |9 MSBs of measured absolute peak value
S */
S    __I  uint32_t STS;                   
S
S    /**
S     * INTSTS
S     * ===================================================================================================
S     * Offset: 0x08  ALC interrupt register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INTFLAG   |ALC interrupt flag
S     * |        |          |This interrupt flag asserts whenever the interrupt is enabled and the PGA gain is updated, either through an ALC change with the ALC enabled or through a PGA gain write with the ALC disabled.
S     * |        |          |Write a 1 to this register to clear.
S */
S    __IO uint32_t INTSTS;                
S
S    /**
S     * INTCTL
S     * ===================================================================================================
S     * Offset: 0x0C  ALC interrupt enable register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INTEN     |ALC Interrupt Enable
S     * |        |          |0 = ALC INT disabled
S     * |        |          |1 = ALC INT enabled
S */
S    __IO uint32_t INTCTL;                
S
S} ALC_T;
S
S/**
S    @addtogroup ALC_CONST ALC Bit Field Definition
S    Constant Definitions for ALC Controller
S@{ */
S
S#define ALC_CTL_NGTHBST_Pos              (0)                                               /*!< ALC CTL: NGTHBST Position              */
S#define ALC_CTL_NGTHBST_Msk              (0x7ul << ALC_CTL_NGTHBST_Pos)                    /*!< ALC CTL: NGTHBST Mask                  */
S
S#define ALC_CTL_NGEN_Pos                 (3)                                               /*!< ALC CTL: NGEN Position                 */
S#define ALC_CTL_NGEN_Msk                 (0x1ul << ALC_CTL_NGEN_Pos)                       /*!< ALC CTL: NGEN Mask                     */
S
S#define ALC_CTL_ATKSEL_Pos               (4)                                               /*!< ALC CTL: ATKSEL Position               */
S#define ALC_CTL_ATKSEL_Msk               (0xful << ALC_CTL_ATKSEL_Pos)                     /*!< ALC CTL: ATKSEL Mask                   */
S
S#define ALC_CTL_DECAYSEL_Pos             (8)                                               /*!< ALC CTL: DECAYSEL Position             */
S#define ALC_CTL_DECAYSEL_Msk             (0xful << ALC_CTL_DECAYSEL_Pos)                   /*!< ALC CTL: DECAYSEL Mask                 */
S
S#define ALC_CTL_MODESEL_Pos              (12)                                              /*!< ALC CTL: MODESEL Position              */
S#define ALC_CTL_MODESEL_Msk              (0x1ul << ALC_CTL_MODESEL_Pos)                    /*!< ALC CTL: MODESEL Mask                  */
S
S#define ALC_CTL_TARGETLV_Pos             (13)                                              /*!< ALC CTL: TARGETLV Position             */
S#define ALC_CTL_TARGETLV_Msk             (0xful << ALC_CTL_TARGETLV_Pos)                   /*!< ALC CTL: TARGETLV Mask                 */
S
S#define ALC_CTL_HOLDTIME_Pos             (17)                                              /*!< ALC CTL: HOLDTIME Position             */
S#define ALC_CTL_HOLDTIME_Msk             (0xful << ALC_CTL_HOLDTIME_Pos)                   /*!< ALC CTL: HOLDTIME Mask                 */
S
S#define ALC_CTL_ZCEN_Pos                 (21)                                              /*!< ALC CTL: ZCEN Position                 */
S#define ALC_CTL_ZCEN_Msk                 (0x1ul << ALC_CTL_ZCEN_Pos)                       /*!< ALC CTL: ZCEN Mask                     */
S
S#define ALC_CTL_MINGAIN_Pos              (22)                                              /*!< ALC CTL: MINGAIN Position              */
S#define ALC_CTL_MINGAIN_Msk              (0x7ul << ALC_CTL_MINGAIN_Pos)                    /*!< ALC CTL: MINGAIN Mask                  */
S
S#define ALC_CTL_MAXGAIN_Pos              (25)                                              /*!< ALC CTL: MAXGAIN Position              */
S#define ALC_CTL_MAXGAIN_Msk              (0x7ul << ALC_CTL_MAXGAIN_Pos)                    /*!< ALC CTL: MAXGAIN Mask                  */
S
S#define ALC_CTL_ALCEN_Pos                (28)                                              /*!< ALC CTL: ALCEN Position                */
S#define ALC_CTL_ALCEN_Msk                (0x1ul << ALC_CTL_ALCEN_Pos)                      /*!< ALC CTL: ALCEN Mask                    */
S
S#define ALC_CTL_NGPKSEL_Pos              (29)                                              /*!< ALC CTL: NGPKSEL Position              */
S#define ALC_CTL_NGPKSEL_Msk              (0x1ul << ALC_CTL_NGPKSEL_Pos)                    /*!< ALC CTL: NGPKSEL Mask                  */
S
S#define ALC_CTL_PKSEL_Pos                (30)                                              /*!< ALC CTL: PKSEL Position                */
S#define ALC_CTL_PKSEL_Msk                (0x1ul << ALC_CTL_PKSEL_Pos)                      /*!< ALC CTL: PKSEL Mask                    */
S
S#define ALC_CTL_PKLIMEN_Pos              (31)                                              /*!< ALC CTL: PKLIMEN Position              */
S#define ALC_CTL_PKLIMEN_Msk              (0x1ul << ALC_CTL_PKLIMEN_Pos)                    /*!< ALC CTL: PKLIMEN Mask                  */
S
S#define ALC_STS_CLIPFLAG_Pos             (0)                                               /*!< ALC STS: CLIPFLAG Position             */
S#define ALC_STS_CLIPFLAG_Msk             (0x1ul << ALC_STS_CLIPFLAG_Pos)                   /*!< ALC STS: CLIPFLAG Mask                 */
S
S#define ALC_STS_NOISEF_Pos               (1)                                               /*!< ALC STS: NOISEF Position               */
S#define ALC_STS_NOISEF_Msk               (0x1ul << ALC_STS_NOISEF_Pos)                     /*!< ALC STS: NOISEF Mask                   */
S
S#define ALC_STS_P2PVAL_Pos               (2)                                               /*!< ALC STS: P2PVAL Position               */
S#define ALC_STS_P2PVAL_Msk               (0x1fful << ALC_STS_P2PVAL_Pos)                   /*!< ALC STS: P2PVAL Mask                   */
S
S#define ALC_STS_PEAKVAL_Pos              (11)                                              /*!< ALC STS: PEAKVAL Position              */
S#define ALC_STS_PEAKVAL_Msk              (0xfful << ALC_STS_PEAKVAL_Pos)                   /*!< ALC STS: PEAKVAL Mask                  */
S
S#define ALC_INTSTS_INTFLAG_Pos           (0)                                               /*!< ALC INTSTS: INTFLAG Position           */
S#define ALC_INTSTS_INTFLAG_Msk           (0x1ul << ALC_INTSTS_INTFLAG_Pos)                 /*!< ALC INTSTS: INTFLAG Mask               */
S
S#define ALC_INTCTL_INTEN_Pos             (0)                                               /*!< ALC INTCTL: INTEN Position             */
S#define ALC_INTCTL_INTEN_Msk             (0x1ul << ALC_INTCTL_INTEN_Pos)                   /*!< ALC INTCTL: INTEN Mask                 */
S
S/**@}*/ /* ALC_CONST */
S/**@}*/ /* end of ALC register group */
S
S
S/*---------------------- Analog Functional Blocks -------------------------*/
S/**
S    @addtogroup ANA Analog Functional Blocks(ANA)
S    Memory Mapped Structure for ANA Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * VMID
S     * ===================================================================================================
S     * Offset: 0x00  VMID Reference Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PULLDOWN  |VMID Pulldown
S     * |        |          |0= Release VMID pin for reference operation.
S     * |        |          |1= Pull VMID pin to ground. Default power down and reset condition.
S     * |[1]     |PDLORES   |Power Down Low (4.8kOhm) Resistance Reference
S     * |        |          |0= Connect the Low Resistance reference to VMID.
S     * |        |          |Use this setting for fast power up of VMID.
S     * |        |          |Can be turned off after 50ms to save power.
S     * |        |          |1= The Low Resistance reference is disconnected from VMID. Default power down and reset condition.
S     * |[2]     |PDHIRES   |Power Down High (360kOhm) Resistance Reference
S     * |        |          |0= Connect the High Resistance reference to VMID. Use this setting for minimum power consumption.
S     * |        |          |1= The High Resistance reference is disconnected from VMID. Default power down and reset condition.
S */
S    __IO uint32_t VMID;                  
S         uint32_t RESERVE0[1];
S
S
S    /**
S     * CURCTL0
S     * ===================================================================================================
S     * Offset: 0x08  Current Source Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |CURSRCEN  |Enable Current Source to GPIOB[x]
S     * |        |          |Individually enable current source to GPIOB pins. Each GPIOB pin has a separate current source.
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable current source to pin GPIOB[x]
S     * |[8:9]   |VALSEL    |Current Source Value
S     * |        |          |Select master current for source generation
S     * |        |          |0= 0.5 uA
S     * |        |          |1= 1 uA
S     * |        |          |2= 2.5 uA
S     * |        |          |3= 5 uA
S */
S    __IO uint32_t CURCTL0;               
S         uint32_t RESERVE1[5];
S
S
S    /**
S     * LDOSEL
S     * ===================================================================================================
S     * Offset: 0x20  LDO Voltage Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |LDOSEL    |Select LDO Output Voltage
S     * |        |          |Note that maximum I/O pad operation speed only specified for voltage >2.4V.
S     * |        |          |0= 3.0V
S     * |        |          |1= 1.8V
S     * |        |          |2= 2.4V
S     * |        |          |3= 3.3V
S */
S    __IO uint32_t LDOSEL;                
S
S    /**
S     * LDOPD
S     * ===================================================================================================
S     * Offset: 0x24  LDO Power Down Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PD        |Power Down LDO
S     * |        |          |When powered down no current delivered to VD33.
S     * |        |          |0= Enable LDO
S     * |        |          |1= Power Down.
S     * |[1]     |DISCHAR   |Discharge
S     * |        |          |0 = No load on VD33
S     * |        |          |1 = Switch discharge resistor to VD33.
S */
S    __IO uint32_t LDOPD;                 
S
S    /**
S     * MICBSEL
S     * ===================================================================================================
S     * Offset: 0x28  Microphone Bias Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |VOLSEL    |Select Microphone Bias Voltage
S     * |        |          |MICBMODE = 0
S     * |        |          |0: 90% VCCA
S     * |        |          |1: 65% VCCA
S     * |        |          |2: 75% VCCA
S     * |        |          |3: 50% VCCA
S     * |        |          |MICBMODE = 1
S     * |        |          |0: 2.4V
S     * |        |          |1: 1.7V
S     * |        |          |2: 2.0V
S     * |        |          |3: 1.3V
S     * |[2]     |REFSEL    |Select Reference Source For MICBIAS Generator
S     * |        |          |VMID provides superior noise performance for MICBIAS generation and should be used unless fixed voltage is absolutely necessary, then noise performance can be sacrificed and bandgap voltage used as reference.
S     * |        |          |0= VMID = VCCA/2 is reference source.
S     * |        |          |1= VBG (bandgap voltage reference) is reference source.
S */
S    __IO uint32_t MICBSEL;               
S
S    /**
S     * MICBEN
S     * ===================================================================================================
S     * Offset: 0x2C  Microphone Bias Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |MICBEN    |Enable Microphone Bias Generator
S     * |        |          |0 = Powered Down.
S     * |        |          |1 = Enabled.
S */
S    __IO uint32_t MICBEN;                
S         uint32_t RESERVE2[8];
S
S
S    /**
S     * MUXCTL
S     * ===================================================================================================
S     * Offset: 0x50  Analog Multiplexer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |NEGINSEL  |Selects Connection Of GPIOB[7:0] To PGA_INN, Negative Input Of PGA
S     * |        |          |If NEGINSEL[n] = 1 then GPIOB[n] is connected to PGA_INN.
S     * |[8:11]  |POSINSEL  |Selects Connection Of GPIOB[7,5,3,1] To PGA_INP, Positive Input Of PGA
S     * |        |          |1000b: GPIOB[7] connected to PGA_INP
S     * |        |          |0100b: GPIOB[5] connected to PGA_INP
S     * |        |          |0010b: GPIOB[3] connected to PGA_INP
S     * |        |          |0001b: GPIOB[1] connected to PGA_INP
S     * |[12]    |PTATCUR   |Select PTAT Current
S     * |        |          |I_PTAT, to PGA_INN, negative input to PGA, for temperature measurement.
S     * |[13]    |PGAINSEL  |Select MICP/MICN To PGA Inputs
S     * |[14]    |MUXEN     |Enable The Analog Multiplexer
S     * |        |          |0 = All channels disabled
S     * |        |          |1 = Selection determined by register setting.
S */
S    __IO uint32_t MUXCTL;                
S         uint32_t RESERVE3[3];
S
S
S    /**
S     * PGACTL
S     * ===================================================================================================
S     * Offset: 0x60  PGA Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |REFSEL    |Select Reference For Analog Path
S     * |        |          |Signal path is normally referenced to VMID (VCCA/2).
S     * |        |          |To use an absolute reference this can be set to VBG = 1.2V.
S     * |        |          |0 = Select VMID voltage as analog ground reference.
S     * |        |          |1 = Select Bandgap voltage as analog ground reference. 
S     * |[1]     |PUPGA     |Power Up Control For PGA Amplifier
S     * |        |          |This amplifier must be powered up for signal path operation.
S     * |        |          |0 = Power Down.
S     * |        |          |1 = Power up.
S     * |[2]     |PUBOOST   |Power Up Control For Boost Stage Amplifier
S     * |        |          |This amplifier must be powered up for signal path operation.
S     * |        |          |0 = Power Down.
S     * |        |          |1 = Power up.
S     * |[3]     |BSTGAIN   |Boost Stage Gain Setting
S     * |        |          |0 = Gain = 0dB.
S     * |        |          |1 = Gain = 26dB
S */
S    __IO uint32_t PGACTL;                
S
S    /**
S     * SIGCTL
S     * ===================================================================================================
S     * Offset: 0x64  Signal Path Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PUZCDCMP  |Power Up And Enable Control For Zero Cross Detect Comparator
S     * |        |          |When enabled PGA gain settings will only be updated when ADC input signal crosses zero signal threshold.
S     * |        |          |To operate ZCD the ALC peripheral clock (CLK_APBCLK0.BFALCKEN) must also be enabled and BIQ_CTL.DLCOEFF = 1 to allow ZCD clocks to be generated.
S     * |        |          |0 = Power down.
S     * |        |          |1 = Power up and enable zero cross detection. 
S     * |[1]     |PUBUFPGA  |Power Up Control For PGA Reference Buffer
S     * |        |          |This block must be powered up for signal path operation.
S     * |        |          |0 = Power down.
S     * |        |          |1 = Power up.
S     * |[2]     |PUBUFADC  |Power Up Control For ADC Reference Buffer
S     * |        |          |This block must be powered up for signal path operation.
S     * |        |          |0 = Power down.
S     * |        |          |1 = Power up.
S     * |[3]     |PUCURB    |Power Up Control For Current Bias Generation
S     * |        |          |This block must be powered up for signal path operation.
S     * |        |          |0 = Power down.
S     * |        |          |1 = Power up.
S     * |[4]     |PUADCOP   |Power Up ADC Sigma-Delta Modulator
S     * |        |          |This block must be powered up for ADC operation.
S     * |        |          |0 = Power down.
S     * |        |          |1 = Power up.
S     * |[5]     |MUTEPGA   |PGA Mute Control
S     * |        |          |0 = Normal.
S     * |        |          |1 = Signal Muted.
S     * |[6]     |MUTEBST   |Boost Stage Mute Control
S     * |        |          |0 = Normal.
S     * |        |          |1 = Signal Muted. 
S */
S    __IO uint32_t SIGCTL;                
S
S    /**
S     * PGAGAIN
S     * ===================================================================================================
S     * Offset: 0x68  PGA Gain Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:5]   |GAINSET   |Select The PGA Gain Setting
S     * |        |          |From -12dB to 35.25dB in 0.75dB step size.
S     * |        |          |0x00 is lowest gain setting at -12dB and 0x3F is largest gain at 35.25dB.
S     * |[8:13]  |GAINREAD  |Current PGA Gain
S     * |        |          |Read Only. May be different from GAIN register when AGC is enabled and is controlling the PGA gain.
S */
S    __IO uint32_t PGAGAIN;               
S         uint32_t RESERVE4[6];
S
S
S    /**
S     * TRIM
S     * ===================================================================================================
S     * Offset: 0x84  Oscillator Trim Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |OSCTRIM   |Oscillator Trim
S     * |        |          |Reads current oscillator trim setting. Read Only.
S     * |[8:15]  |COARSE    |COARSE
S     * |        |          |Current coarse range setting of the oscillator. Read Only
S     * |[16:23] |SUPERFINE |Superfine
S     * |        |          |The superfine trim setting is an 8bit signed integer.
S     * |        |          |It adjusts the master oscillator by dithering the FINE trim setting between the current setting and one setting above (values 1,127) or below (values -1, -128) the current trim setting.
S     * |        |          |Each step effectively moves the frequency 1/128th of the full FINE trim step size.
S */
S    __IO uint32_t TRIM;                  
S         uint32_t RESERVE5[1];
S
S
S    /**
S     * CAPSCTL
S     * ===================================================================================================
S     * Offset: 0x8C  Capacitive Touch Sensing Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |LOWTIME   |Output Low Time
S     * |        |          |Number of PCLK cycles to discharge external capacitor.
S     * |        |          |0=1cycle
S     * |        |          |1=2cycles
S     * |        |          |2=8cycles
S     * |        |          |3=16cycles
S     * |[2:4]   |CYCLECNT  |Number of Relaxation Cycles
S     * |        |          |Peripheral performs 2^(CYCLECNT) relaxation cycles before generating interrupt.
S     * |[5]     |CLKMODE   |Reference Clock Mode
S     * |        |          |0 = Capacitive Touch Sensing Mode.
S     * |        |          |1 = Circuit is in Reference clock generation mode.
S     * |[8:15]  |CLKDIV    |Reference Clock Divider
S     * |        |          |Circuit can be used to generate a reference clock output of SDCLK/2/(CLKDIV+1) instead of a Capacitive Touch Sensing reset signal.
S     * |[29]    |RSTCNT    |Reset Count
S     * |        |          |0: Release/Activate ANA_CAPSCNT
S     * |        |          |1: Set high to reset ANA_CAPSCNT.
S     * |[30]    |INTEN     |Interrupt Enable
S     * |        |          |0 = Disable/Reset CAPS_IRQ interrupt.
S     * |        |          |1 = Enable CAPS_IRQ interrupt.
S     * |[31]    |CAPSEN    |Enable
S     * |        |          |0 = Disable/Reset block.
S     * |        |          |1 = Enable Block.
S */
S    __IO uint32_t CAPSCTL;               
S
S    /**
S     * CAPSCNT
S     * ===================================================================================================
S     * Offset: 0x90  Capacitive Touch Sensing Count Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:23]  |CAPSCNT   |Counter Read Back Value Of Capacitive Touch Sensing Block
S */
S    __I  uint32_t CAPSCNT;               
S
S    /**
S     * FQMMCTL
S     * ===================================================================================================
S     * Offset: 0x94  Frequency Measurement Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |CLKSEL    |Reference Clock Source
S     * |        |          |00b: OSC16K,
S     * |        |          |01b: OSC32K (default),
S     * |        |          |1xb: I2S_WS - can be GPIOA[4,8,12] according to SYS_GPA_MFP register, configure I2S in SLAVE mode to enable.
S     * |[2]     |MMSTS     |Measurement Done
S     * |        |          |0 = Measurement Ongoing.
S     * |        |          |1 = Measurement Complete.
S     * |[16:23] |CYCLESEL  |Frequency Measurement Cycles
S     * |        |          |Number of reference clock periods plus one to measure target clock (PCLK).
S     * |        |          |For example if reference clock is OSC32K (T is 30.5175us), set CYCLESEL to 7, then measurement period would be 30.5175*(7+1), 244.1us.
S     * |[31]    |FQMMEN    |FQMMEN
S     * |        |          |0 = Disable/Reset block.
S     * |        |          |1 = Start Frequency Measurement.
S */
S    __IO uint32_t FQMMCTL;               
S
S    /**
S     * FQMMCNT
S     * ===================================================================================================
S     * Offset: 0x98  Frequency Measurement Count Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |FQMMCNT   |Frequency Measurement Count
S     * |        |          |When MMSTS = 1 and G0 = 1, this is number of PCLK periods counted for frequency measurement.
S     * |        |          |The frequency will be PCLK = FQMMCNT * Fref /(CYCLESEL+1) Hz
S     * |        |          |Maximum resolution of measurement is Fref /(CYCLESEL+1)*2 Hz
S */
S    __I  uint32_t FQMMCNT;               
S
S} ANA_T;
S
S/**
S    @addtogroup ANA_CONST ANA Bit Field Definition
S    Constant Definitions for ANA Controller
S@{ */
S
S#define ANA_VMID_PULLDOWN_Pos            (0)                                               /*!< ANA VMID: PULLDOWN Position            */
S#define ANA_VMID_PULLDOWN_Msk            (0x1ul << ANA_VMID_PULLDOWN_Pos)                  /*!< ANA VMID: PULLDOWN Mask                */
S
S#define ANA_VMID_PDLORES_Pos             (1)                                               /*!< ANA VMID: PDLORES Position             */
S#define ANA_VMID_PDLORES_Msk             (0x1ul << ANA_VMID_PDLORES_Pos)                   /*!< ANA VMID: PDLORES Mask                 */
S
S#define ANA_VMID_PDHIRES_Pos             (2)                                               /*!< ANA VMID: PDHIRES Position             */
S#define ANA_VMID_PDHIRES_Msk             (0x1ul << ANA_VMID_PDHIRES_Pos)                   /*!< ANA VMID: PDHIRES Mask                 */
S
S#define ANA_CURCTL0_CURSRCEN_Pos         (0)                                               /*!< ANA CURCTL0: CURSRCEN Position         */
S#define ANA_CURCTL0_CURSRCEN_Msk         (0xfful << ANA_CURCTL0_CURSRCEN_Pos)              /*!< ANA CURCTL0: CURSRCEN Mask             */
S
S#define ANA_CURCTL0_VALSEL_Pos           (8)                                               /*!< ANA CURCTL0: VALSEL Position           */
S#define ANA_CURCTL0_VALSEL_Msk           (0x3ul << ANA_CURCTL0_VALSEL_Pos)                 /*!< ANA CURCTL0: VALSEL Mask               */
S
S#define ANA_LDOSEL_LDOSEL_Pos            (0)                                               /*!< ANA LDOSEL: LDOSEL Position            */
S#define ANA_LDOSEL_LDOSEL_Msk            (0x3ul << ANA_LDOSEL_LDOSEL_Pos)                  /*!< ANA LDOSEL: LDOSEL Mask                */
S
S#define ANA_LDOPD_PD_Pos                 (0)                                               /*!< ANA LDOPD: PD Position                 */
S#define ANA_LDOPD_PD_Msk                 (0x1ul << ANA_LDOPD_PD_Pos)                       /*!< ANA LDOPD: PD Mask                     */
S
S#define ANA_LDOPD_DISCHAR_Pos            (1)                                               /*!< ANA LDOPD: DISCHAR Position            */
S#define ANA_LDOPD_DISCHAR_Msk            (0x1ul << ANA_LDOPD_DISCHAR_Pos)                  /*!< ANA LDOPD: DISCHAR Mask                */
S
S#define ANA_MICBSEL_VOLSEL_Pos           (0)                                               /*!< ANA MICBSEL: VOLSEL Position           */
S#define ANA_MICBSEL_VOLSEL_Msk           (0x3ul << ANA_MICBSEL_VOLSEL_Pos)                 /*!< ANA MICBSEL: VOLSEL Mask               */
S
S#define ANA_MICBSEL_REFSEL_Pos           (2)                                               /*!< ANA MICBSEL: REFSEL Position           */
S#define ANA_MICBSEL_REFSEL_Msk           (0x1ul << ANA_MICBSEL_REFSEL_Pos)                 /*!< ANA MICBSEL: REFSEL Mask               */
S
S#define ANA_MICBEN_MICBEN_Pos            (0)                                               /*!< ANA MICBEN: MICBEN Position            */
S#define ANA_MICBEN_MICBEN_Msk            (0x1ul << ANA_MICBEN_MICBEN_Pos)                  /*!< ANA MICBEN: MICBEN Mask                */
S
S#define ANA_MUXCTL_NEGINSEL_Pos          (0)                                               /*!< ANA MUXCTL: NEGINSEL Position          */
S#define ANA_MUXCTL_NEGINSEL_Msk          (0xfful << ANA_MUXCTL_NEGINSEL_Pos)               /*!< ANA MUXCTL: NEGINSEL Mask              */
S
S#define ANA_MUXCTL_POSINSEL_Pos          (8)                                               /*!< ANA MUXCTL: POSINSEL Position          */
S#define ANA_MUXCTL_POSINSEL_Msk          (0xful << ANA_MUXCTL_POSINSEL_Pos)                /*!< ANA MUXCTL: POSINSEL Mask              */
S
S#define ANA_MUXCTL_PTATCUR_Pos           (12)                                              /*!< ANA MUXCTL: PTATCUR Position           */
S#define ANA_MUXCTL_PTATCUR_Msk           (0x1ul << ANA_MUXCTL_PTATCUR_Pos)                 /*!< ANA MUXCTL: PTATCUR Mask               */
S
S#define ANA_MUXCTL_PGAINSEL_Pos          (13)                                              /*!< ANA MUXCTL: PGAINSEL Position          */
S#define ANA_MUXCTL_PGAINSEL_Msk          (0x1ul << ANA_MUXCTL_PGAINSEL_Pos)                /*!< ANA MUXCTL: PGAINSEL Mask              */
S
S#define ANA_MUXCTL_MUXEN_Pos             (14)                                              /*!< ANA MUXCTL: MUXEN Position             */
S#define ANA_MUXCTL_MUXEN_Msk             (0x1ul << ANA_MUXCTL_MUXEN_Pos)                   /*!< ANA MUXCTL: MUXEN Mask                 */
S
S#define ANA_PGACTL_REFSEL_Pos            (0)                                               /*!< ANA PGACTL: REFSEL Position            */
S#define ANA_PGACTL_REFSEL_Msk            (0x1ul << ANA_PGACTL_REFSEL_Pos)                  /*!< ANA PGACTL: REFSEL Mask                */
S
S#define ANA_PGACTL_PUPGA_Pos             (1)                                               /*!< ANA PGACTL: PUPGA Position             */
S#define ANA_PGACTL_PUPGA_Msk             (0x1ul << ANA_PGACTL_PUPGA_Pos)                   /*!< ANA PGACTL: PUPGA Mask                 */
S
S#define ANA_PGACTL_PUBOOST_Pos           (2)                                               /*!< ANA PGACTL: PUBOOST Position           */
S#define ANA_PGACTL_PUBOOST_Msk           (0x1ul << ANA_PGACTL_PUBOOST_Pos)                 /*!< ANA PGACTL: PUBOOST Mask               */
S
S#define ANA_PGACTL_BSTGAIN_Pos           (3)                                               /*!< ANA PGACTL: BSTGAIN Position           */
S#define ANA_PGACTL_BSTGAIN_Msk           (0x1ul << ANA_PGACTL_BSTGAIN_Pos)                 /*!< ANA PGACTL: BSTGAIN Mask               */
S
S#define ANA_SIGCTL_PUZCDCMP_Pos          (0)                                               /*!< ANA SIGCTL: PUZCDCMP Position          */
S#define ANA_SIGCTL_PUZCDCMP_Msk          (0x1ul << ANA_SIGCTL_PUZCDCMP_Pos)                /*!< ANA SIGCTL: PUZCDCMP Mask              */
S
S#define ANA_SIGCTL_PUBUFPGA_Pos          (1)                                               /*!< ANA SIGCTL: PUBUFPGA Position          */
S#define ANA_SIGCTL_PUBUFPGA_Msk          (0x1ul << ANA_SIGCTL_PUBUFPGA_Pos)                /*!< ANA SIGCTL: PUBUFPGA Mask              */
S
S#define ANA_SIGCTL_PUBUFADC_Pos          (2)                                               /*!< ANA SIGCTL: PUBUFADC Position          */
S#define ANA_SIGCTL_PUBUFADC_Msk          (0x1ul << ANA_SIGCTL_PUBUFADC_Pos)                /*!< ANA SIGCTL: PUBUFADC Mask              */
S
S#define ANA_SIGCTL_PUCURB_Pos            (3)                                               /*!< ANA SIGCTL: PUCURB Position            */
S#define ANA_SIGCTL_PUCURB_Msk            (0x1ul << ANA_SIGCTL_PUCURB_Pos)                  /*!< ANA SIGCTL: PUCURB Mask                */
S
S#define ANA_SIGCTL_PUADCOP_Pos           (4)                                               /*!< ANA SIGCTL: PUADCOP Position           */
S#define ANA_SIGCTL_PUADCOP_Msk           (0x1ul << ANA_SIGCTL_PUADCOP_Pos)                 /*!< ANA SIGCTL: PUADCOP Mask               */
S
S#define ANA_SIGCTL_MUTEPGA_Pos           (5)                                               /*!< ANA SIGCTL: MUTEPGA Position           */
S#define ANA_SIGCTL_MUTEPGA_Msk           (0x1ul << ANA_SIGCTL_MUTEPGA_Pos)                 /*!< ANA SIGCTL: MUTEPGA Mask               */
S
S#define ANA_SIGCTL_MUTEBST_Pos           (6)                                               /*!< ANA SIGCTL: MUTEBST Position           */
S#define ANA_SIGCTL_MUTEBST_Msk           (0x1ul << ANA_SIGCTL_MUTEBST_Pos)                 /*!< ANA SIGCTL: MUTEBST Mask               */
S
S#define ANA_PGAGAIN_GAINSET_Pos          (0)                                               /*!< ANA PGAGAIN: GAINSET Position          */
S#define ANA_PGAGAIN_GAINSET_Msk          (0x3ful << ANA_PGAGAIN_GAINSET_Pos)               /*!< ANA PGAGAIN: GAINSET Mask              */
S
S#define ANA_PGAGAIN_GAINREAD_Pos         (8)                                               /*!< ANA PGAGAIN: GAINREAD Position         */
S#define ANA_PGAGAIN_GAINREAD_Msk         (0x3ful << ANA_PGAGAIN_GAINREAD_Pos)              /*!< ANA PGAGAIN: GAINREAD Mask             */
S
S#define ANA_TRIM_OSCTRIM_Pos             (0)                                               /*!< ANA TRIM: OSCTRIM Position             */
S#define ANA_TRIM_OSCTRIM_Msk             (0xfful << ANA_TRIM_OSCTRIM_Pos)                  /*!< ANA TRIM: OSCTRIM Mask                 */
S
S#define ANA_TRIM_COARSE_Pos              (8)                                               /*!< ANA TRIM: COARSE Position              */
S#define ANA_TRIM_COARSE_Msk              (0xfful << ANA_TRIM_COARSE_Pos)                   /*!< ANA TRIM: COARSE Mask                  */
S
S#define ANA_TRIM_SUPERFINE_Pos           (16)                                              /*!< ANA TRIM: SUPERFINE Position           */
S#define ANA_TRIM_SUPERFINE_Msk           (0xfful << ANA_TRIM_SUPERFINE_Pos)                /*!< ANA TRIM: SUPERFINE Mask               */
S
S#define ANA_CAPSCTL_LOWTIME_Pos          (0)                                               /*!< ANA CAPSCTL: LOWTIME Position          */
S#define ANA_CAPSCTL_LOWTIME_Msk          (0x3ul << ANA_CAPSCTL_LOWTIME_Pos)                /*!< ANA CAPSCTL: LOWTIME Mask              */
S
S#define ANA_CAPSCTL_CYCLECNT_Pos         (2)                                               /*!< ANA CAPSCTL: CYCLECNT Position         */
S#define ANA_CAPSCTL_CYCLECNT_Msk         (0x7ul << ANA_CAPSCTL_CYCLECNT_Pos)               /*!< ANA CAPSCTL: CYCLECNT Mask             */
S
S#define ANA_CAPSCTL_CLKMODE_Pos          (5)                                               /*!< ANA CAPSCTL: CLKMODE Position          */
S#define ANA_CAPSCTL_CLKMODE_Msk          (0x1ul << ANA_CAPSCTL_CLKMODE_Pos)                /*!< ANA CAPSCTL: CLKMODE Mask              */
S
S#define ANA_CAPSCTL_CLKDIV_Pos           (8)                                               /*!< ANA CAPSCTL: CLKDIV Position           */
S#define ANA_CAPSCTL_CLKDIV_Msk           (0xfful << ANA_CAPSCTL_CLKDIV_Pos)                /*!< ANA CAPSCTL: CLKDIV Mask               */
S
S#define ANA_CAPSCTL_RSTCNT_Pos           (29)                                              /*!< ANA CAPSCTL: RSTCNT Position           */
S#define ANA_CAPSCTL_RSTCNT_Msk           (0x1ul << ANA_CAPSCTL_RSTCNT_Pos)                 /*!< ANA CAPSCTL: RSTCNT Mask               */
S
S#define ANA_CAPSCTL_INTEN_Pos            (30)                                              /*!< ANA CAPSCTL: INTEN Position            */
S#define ANA_CAPSCTL_INTEN_Msk            (0x1ul << ANA_CAPSCTL_INTEN_Pos)                  /*!< ANA CAPSCTL: INTEN Mask                */
S
S#define ANA_CAPSCTL_CAPSEN_Pos           (31)                                              /*!< ANA CAPSCTL: CAPSEN Position           */
S#define ANA_CAPSCTL_CAPSEN_Msk           (0x1ul << ANA_CAPSCTL_CAPSEN_Pos)                 /*!< ANA CAPSCTL: CAPSEN Mask               */
S
S#define ANA_CAPSCNT_CAPSCNT_Pos          (0)                                               /*!< ANA CAPSCNT: CAPSCNT Position          */
S#define ANA_CAPSCNT_CAPSCNT_Msk          (0xfffffful << ANA_CAPSCNT_CAPSCNT_Pos)           /*!< ANA CAPSCNT: CAPSCNT Mask              */
S
S#define ANA_FQMMCTL_CLKSEL_Pos           (0)                                               /*!< ANA FQMMCTL: CLKSEL Position           */
S#define ANA_FQMMCTL_CLKSEL_Msk           (0x3ul << ANA_FQMMCTL_CLKSEL_Pos)                 /*!< ANA FQMMCTL: CLKSEL Mask               */
S
S#define ANA_FQMMCTL_MMSTS_Pos            (2)                                               /*!< ANA FQMMCTL: MMSTS Position            */
S#define ANA_FQMMCTL_MMSTS_Msk            (0x1ul << ANA_FQMMCTL_MMSTS_Pos)                  /*!< ANA FQMMCTL: MMSTS Mask                */
S
S#define ANA_FQMMCTL_CYCLESEL_Pos         (16)                                              /*!< ANA FQMMCTL: CYCLESEL Position         */
S#define ANA_FQMMCTL_CYCLESEL_Msk         (0xfful << ANA_FQMMCTL_CYCLESEL_Pos)              /*!< ANA FQMMCTL: CYCLESEL Mask             */
S
S#define ANA_FQMMCTL_FQMMEN_Pos           (31)                                              /*!< ANA FQMMCTL: FQMMEN Position           */
S#define ANA_FQMMCTL_FQMMEN_Msk           (0x1ul << ANA_FQMMCTL_FQMMEN_Pos)                 /*!< ANA FQMMCTL: FQMMEN Mask               */
S
S#define ANA_FQMMCNT_FQMMCNT_Pos          (0)                                               /*!< ANA FQMMCNT: FQMMCNT Position          */
S#define ANA_FQMMCNT_FQMMCNT_Msk          (0xfffful << ANA_FQMMCNT_FQMMCNT_Pos)             /*!< ANA FQMMCNT: FQMMCNT Mask              */
S
S/**@}*/ /* ANA_CONST */
S/**@}*/ /* end of ANA register group */
S
S
S/*---------------------- Biquad Filter -------------------------*/
S/**
S    @addtogroup BIQ Biquad Filter(BIQ)
S    Memory Mapped Structure for BIQ Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * COEFF0
S     * ===================================================================================================
S     * Offset: 0x00  Coefficient b0 In H(z) Transfer Function
S(3.16 format) - 1st stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF0;                
S
S    /**
S     * COEFF1
S     * ===================================================================================================
S     * Offset: 0x04  Coefficient b1 In H(z) Transfer Function
S(3.16 format) - 1st stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF1;                
S
S    /**
S     * COEFF2
S     * ===================================================================================================
S     * Offset: 0x08  Coefficient b2 In H(z) Transfer Function
S(3.16 format) - 1st stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF2;                
S
S    /**
S     * COEFF3
S     * ===================================================================================================
S     * Offset: 0x0C  Coefficient a1 In H(z) Transfer Function
S(3.16 format) - 1st stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF3;                
S
S    /**
S     * COEFF4
S     * ===================================================================================================
S     * Offset: 0x10  Coefficient a2 In H(z) Transfer Function
S(3.16 format) - 1st stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF4;                
S
S    /**
S     * COEFF5
S     * ===================================================================================================
S     * Offset: 0x14  Coefficient b0 In H(z) Transfer Function
S(3.16 format) - 2nd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF5;                
S
S    /**
S     * COEFF6
S     * ===================================================================================================
S     * Offset: 0x18  Coefficient b1 In H(z) Transfer Function
S(3.16 format) - 2nd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF6;                
S
S    /**
S     * COEFF7
S     * ===================================================================================================
S     * Offset: 0x1C  Coefficient b2 In H(z) Transfer Function
S(3.16 format) - 2nd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF7;                
S
S    /**
S     * COEFF8
S     * ===================================================================================================
S     * Offset: 0x20  Coefficient a1 In H(z) Transfer Function
S(3.16 format) - 2nd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF8;                
S
S    /**
S     * COEFF9
S     * ===================================================================================================
S     * Offset: 0x24  Coefficient a2 In H(z) Transfer Function
S(3.16 format) - 2nd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF9;                
S
S    /**
S     * COEFF10
S     * ===================================================================================================
S     * Offset: 0x28  Coefficient b0 In H(z) Transfer Function
S(3.16 format) - 3rd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF10;               
S
S    /**
S     * COEFF11
S     * ===================================================================================================
S     * Offset: 0x2C  Coefficient b1 In H(z) Transfer Function
S(3.16 format) - 3rd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF11;               
S
S    /**
S     * COEFF12
S     * ===================================================================================================
S     * Offset: 0x30  Coefficient b2 In H(z) Transfer Function
S(3.16 format) - 3rd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF12;               
S
S    /**
S     * COEFF13
S     * ===================================================================================================
S     * Offset: 0x34  Coefficient a1 In H(z) Transfer Function
S(3.16 format) - 3rd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF13;               
S
S    /**
S     * COEFF14
S     * ===================================================================================================
S     * Offset: 0x38  Coefficient a2 In H(z) Transfer Function
S(3.16 format) - 3rd stage BIQ Coefficients
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |COEFFDAT  |Coefficient Data
S */
S    __IO uint32_t COEFF14;               
S         uint32_t RESERVE0[1];
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x40  BIQ Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BIQEN     |BIQ Filter Start To Run
S     * |        |          |0 = BIQ filter is not processing
S     * |        |          |1 = BIQ filter is on.
S     * |[1]     |PATHSEL   |AC Path Selection For BIQ
S     * |        |          |0 = used in ADC path
S     * |        |          |1 = used in DPWM path
S     * |[2]     |PRGCOEFF  |Programming Mode Coefficient Control Bit
S     * |        |          |0 = Coefficient RAM is in normal mode.
S     * |        |          |1 = coefficient RAM is under programming mode.
S     * |        |          |This bit must be turned off when BIQEN in on.
S     * |[3]     |DLCOEFF   |Move BIQ Out Of Reset State
S     * |        |          |0 = BIQ filter is in reset state.
S     * |        |          |1 = When this bit is on, the default coefficients will be downloaded to the coefficient ram automatically in 32 internal system clocks.
S     * |        |          |Processor must delay enough time before changing the coefficients or turn the BIQ on.
S     * |[4:6]   |DPWMPUSR  |DPWM Path Up Sample Rate (From SRDIV Result)
S     * |        |          |This register is only used when PATHSEL is set to 1.
S     * |        |          |The operating sample rate for the biquad filter will be.
S     * |        |          |(DPWMPUSR+1)*HCLK/(SRDIV+1).
S     * |        |          |Default value for this register is 3.
S     * |[16:28] |SRDIV     |Sample Rate Divider
S     * |        |          |This register is used to program the operating sampling rate of the biquad filter.
S     * |        |          |The sample rate is defined as.
S     * |        |          |HCLK/(SRDIV+1).
S     * |        |          |Default to 3071 so the sampling rate is 16K when HCLK is 49.152MHz.
S */
S    __IO uint32_t CTL;                   
S
S} BIQ_T;
S
S/**
S    @addtogroup BIQ_CONST BIQ Bit Field Definition
S    Constant Definitions for BIQ Controller
S@{ */
S
S#define BIQ_COEFF0_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF0: COEFFDAT Position          */
S#define BIQ_COEFF0_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF0_COEFFDAT_Pos)         /*!< BIQ COEFF0: COEFFDAT Mask              */
S
S#define BIQ_COEFF1_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF1: COEFFDAT Position          */
S#define BIQ_COEFF1_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF1_COEFFDAT_Pos)         /*!< BIQ COEFF1: COEFFDAT Mask              */
S
S#define BIQ_COEFF2_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF2: COEFFDAT Position          */
S#define BIQ_COEFF2_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF2_COEFFDAT_Pos)         /*!< BIQ COEFF2: COEFFDAT Mask              */
S
S#define BIQ_COEFF3_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF3: COEFFDAT Position          */
S#define BIQ_COEFF3_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF3_COEFFDAT_Pos)         /*!< BIQ COEFF3: COEFFDAT Mask              */
S
S#define BIQ_COEFF4_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF4: COEFFDAT Position          */
S#define BIQ_COEFF4_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF4_COEFFDAT_Pos)         /*!< BIQ COEFF4: COEFFDAT Mask              */
S
S#define BIQ_COEFF5_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF5: COEFFDAT Position          */
S#define BIQ_COEFF5_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF5_COEFFDAT_Pos)         /*!< BIQ COEFF5: COEFFDAT Mask              */
S
S#define BIQ_COEFF6_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF6: COEFFDAT Position          */
S#define BIQ_COEFF6_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF6_COEFFDAT_Pos)         /*!< BIQ COEFF6: COEFFDAT Mask              */
S
S#define BIQ_COEFF7_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF7: COEFFDAT Position          */
S#define BIQ_COEFF7_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF7_COEFFDAT_Pos)         /*!< BIQ COEFF7: COEFFDAT Mask              */
S
S#define BIQ_COEFF8_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF8: COEFFDAT Position          */
S#define BIQ_COEFF8_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF8_COEFFDAT_Pos)         /*!< BIQ COEFF8: COEFFDAT Mask              */
S
S#define BIQ_COEFF9_COEFFDAT_Pos          (0)                                               /*!< BIQ COEFF9: COEFFDAT Position          */
S#define BIQ_COEFF9_COEFFDAT_Msk          (0xfffffffful << BIQ_COEFF9_COEFFDAT_Pos)         /*!< BIQ COEFF9: COEFFDAT Mask              */
S
S#define BIQ_COEFF10_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF10: COEFFDAT Position         */
S#define BIQ_COEFF10_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF10_COEFFDAT_Pos)        /*!< BIQ COEFF10: COEFFDAT Mask             */
S
S#define BIQ_COEFF11_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF11: COEFFDAT Position         */
S#define BIQ_COEFF11_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF11_COEFFDAT_Pos)        /*!< BIQ COEFF11: COEFFDAT Mask             */
S
S#define BIQ_COEFF12_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF12: COEFFDAT Position         */
S#define BIQ_COEFF12_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF12_COEFFDAT_Pos)        /*!< BIQ COEFF12: COEFFDAT Mask             */
S
S#define BIQ_COEFF13_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF13: COEFFDAT Position         */
S#define BIQ_COEFF13_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF13_COEFFDAT_Pos)        /*!< BIQ COEFF13: COEFFDAT Mask             */
S
S#define BIQ_COEFF14_COEFFDAT_Pos         (0)                                               /*!< BIQ COEFF14: COEFFDAT Position         */
S#define BIQ_COEFF14_COEFFDAT_Msk         (0xfffffffful << BIQ_COEFF14_COEFFDAT_Pos)        /*!< BIQ COEFF14: COEFFDAT Mask             */
S
S#define BIQ_CTL_BIQEN_Pos                (0)                                               /*!< BIQ CTL: BIQEN Position                */
S#define BIQ_CTL_BIQEN_Msk                (0x1ul << BIQ_CTL_BIQEN_Pos)                      /*!< BIQ CTL: BIQEN Mask                    */
S
S#define BIQ_CTL_PATHSEL_Pos              (1)                                               /*!< BIQ CTL: PATHSEL Position              */
S#define BIQ_CTL_PATHSEL_Msk              (0x1ul << BIQ_CTL_PATHSEL_Pos)                    /*!< BIQ CTL: PATHSEL Mask                  */
S
S#define BIQ_CTL_PRGCOEFF_Pos             (2)                                               /*!< BIQ CTL: PRGCOEFF Position             */
S#define BIQ_CTL_PRGCOEFF_Msk             (0x1ul << BIQ_CTL_PRGCOEFF_Pos)                   /*!< BIQ CTL: PRGCOEFF Mask                 */
S
S#define BIQ_CTL_DLCOEFF_Pos              (3)                                               /*!< BIQ CTL: DLCOEFF Position              */
S#define BIQ_CTL_DLCOEFF_Msk              (0x1ul << BIQ_CTL_DLCOEFF_Pos)                    /*!< BIQ CTL: DLCOEFF Mask                  */
S
S#define BIQ_CTL_DPWMPUSR_Pos             (4)                                               /*!< BIQ CTL: DPWMPUSR Position             */
S#define BIQ_CTL_DPWMPUSR_Msk             (0x7ul << BIQ_CTL_DPWMPUSR_Pos)                   /*!< BIQ CTL: DPWMPUSR Mask                 */
S
S#define BIQ_CTL_SRDIV_Pos                (16)                                              /*!< BIQ CTL: SRDIV Position                */
S#define BIQ_CTL_SRDIV_Msk                (0x1ffful << BIQ_CTL_SRDIV_Pos)                   /*!< BIQ CTL: SRDIV Mask                    */
S
S/**@}*/ /* BIQ_CONST */
S/**@}*/ /* end of BIQ register group */
S
S
S/*---------------------- Brownout Detection and Temperature Alarm -------------------------*/
S/**
S    @addtogroup BODTALM Brownout Detection and Temperature Alarm(BODTALM)
S    Memory Mapped Structure for BODTALM Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * BODSEL
S     * ===================================================================================================
S     * Offset: 0x00  Brown Out Detector Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |BODVL     |BOD Voltage Level
S     * |        |          |111b = 4.6V
S     * |        |          |110b = 3.0V
S     * |        |          |101b = 2.8V
S     * |        |          |100b = 2.625V
S     * |        |          |011b = 2.5V
S     * |        |          |010b = 2.4V
S     * |        |          |001b = 2.2V
S     * |        |          |000b = 2.1V
S     * |[3]     |BODHYS    |BOD Hysteresis
S     * |        |          |0= Hysteresis Disabled.
S     * |        |          |1= Enable Hysteresis of BOD detection.
S */
S    __IO uint32_t BODSEL;                
S
S    /**
S     * BODCTL
S     * ===================================================================================================
S     * Offset: 0x04  Brown Out Detector Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |BODEN     |BOD Enable
S     * |        |          |1xb = Enable continuous BOD detection.
S     * |        |          |01b = Enable time multiplexed BOD detection. See BODTALM_BODDTMR register.
S     * |        |          |00b = Disable BOD Detection.
S     * |[2]     |BODINTEN  |BOD Interrupt Enable
S     * |        |          |0= Disable BOD Interrupt.
S     * |        |          |1= Enable BOD Interrupt.
S     * |[3]     |BODIF     |Current Status Of Interrupt
S     * |        |          |Latched whenever a BOD event occurs and BODINTEN = 1. Write '1' to clear.
S     * |[4]     |BODOUT    |Output of BOD Detection Block
S     * |        |          |This signal can be monitored to determine the current state of the BOD comparator.
S     * |        |          |Read '1' implies that VCC is less than BODVL.
S */
S    __IO uint32_t BODCTL;                
S
S    /**
S     * TALMSEL
S     * ===================================================================================================
S     * Offset: 0x08  Temperature Alarm Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |TALMVL    |Temperature Alarm Sense Level
S     * |        |          |0000:105C
S     * |        |          |0001:115C
S     * |        |          |0010:125C
S     * |        |          |0100:135C
S     * |        |          |1000:145C
S */
S    __IO uint32_t TALMSEL;               
S
S    /**
S     * TALMCTL
S     * ===================================================================================================
S     * Offset: 0x0C  Temperature Alarm Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TALMEN    |TALARM Enable
S     * |        |          |0 = Disable TALARM Detection
S     * |        |          |1 = Enable TALARM Detection
S     * |[1]     |TALMOUT   |Output of TALARM Block
S     * |        |          |Can be polled to determine whether TALARM active (be 1).
S     * |[2]     |TALMIEN   |TALARM Interrupt Enable
S     * |        |          |0 = Disable TALARM Interrupt
S     * |        |          |1 = Enable TALARM Interrupt
S     * |[3]     |TALMIF    |Current status of interrupt
S     * |        |          |Latched whenever a Temperature Sense event occurs and IE = 1. Write '1' to clear.
S */
S    __IO uint32_t TALMCTL;               
S
S    /**
S     * BODDTMR
S     * ===================================================================================================
S     * Offset: 0x10  Brown Out Detector Timer Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |DURTOFF   |Time BOD Detector Is Off
S     * |        |          |(DURTOFF+1)*100us . Minimum value is 7. (default is 99.6ms)
S     * |[16:19] |DURTON    |Time BOD Detector Is Active
S     * |        |          |(DURTON+1) * 100us. Minimum value is 1. (default is 400us)
S */
S    __IO uint32_t BODDTMR;               
S
S} BODTALM_T;
S
S/**
S    @addtogroup BODTALM_CONST BODTALM Bit Field Definition
S    Constant Definitions for BODTALM Controller
S@{ */
S
S#define BODTALM_BODSEL_BODVL_Pos         (0)                                               /*!< BODTALM BODSEL: BODVL Position         */
S#define BODTALM_BODSEL_BODVL_Msk         (0x7ul << BODTALM_BODSEL_BODVL_Pos)               /*!< BODTALM BODSEL: BODVL Mask             */
S
S#define BODTALM_BODSEL_BODHYS_Pos        (3)                                               /*!< BODTALM BODSEL: BODHYS Position        */
S#define BODTALM_BODSEL_BODHYS_Msk        (0x1ul << BODTALM_BODSEL_BODHYS_Pos)              /*!< BODTALM BODSEL: BODHYS Mask            */
S
S#define BODTALM_BODCTL_BODEN_Pos         (0)                                               /*!< BODTALM BODCTL: BODEN Position         */
S#define BODTALM_BODCTL_BODEN_Msk         (0x3ul << BODTALM_BODCTL_BODEN_Pos)               /*!< BODTALM BODCTL: BODEN Mask             */
S
S#define BODTALM_BODCTL_BODINTEN_Pos      (2)                                               /*!< BODTALM BODCTL: BODINTEN Position      */
S#define BODTALM_BODCTL_BODINTEN_Msk      (0x1ul << BODTALM_BODCTL_BODINTEN_Pos)            /*!< BODTALM BODCTL: BODINTEN Mask          */
S
S#define BODTALM_BODCTL_BODIF_Pos         (3)                                               /*!< BODTALM BODCTL: BODIF Position         */
S#define BODTALM_BODCTL_BODIF_Msk         (0x1ul << BODTALM_BODCTL_BODIF_Pos)               /*!< BODTALM BODCTL: BODIF Mask             */
S
S#define BODTALM_BODCTL_BODOUT_Pos        (4)                                               /*!< BODTALM BODCTL: BODOUT Position        */
S#define BODTALM_BODCTL_BODOUT_Msk        (0x1ul << BODTALM_BODCTL_BODOUT_Pos)              /*!< BODTALM BODCTL: BODOUT Mask            */
S
S#define BODTALM_TALMSEL_TALMVL_Pos       (0)                                               /*!< BODTALM TALMSEL: TALMVL Position       */
S#define BODTALM_TALMSEL_TALMVL_Msk       (0xful << BODTALM_TALMSEL_TALMVL_Pos)             /*!< BODTALM TALMSEL: TALMVL Mask           */
S
S#define BODTALM_TALMCTL_TALMEN_Pos       (0)                                               /*!< BODTALM TALMCTL: TALMEN Position       */
S#define BODTALM_TALMCTL_TALMEN_Msk       (0x1ul << BODTALM_TALMCTL_TALMEN_Pos)             /*!< BODTALM TALMCTL: TALMEN Mask           */
S
S#define BODTALM_TALMCTL_TALMOUT_Pos      (1)                                               /*!< BODTALM TALMCTL: TALMOUT Position      */
S#define BODTALM_TALMCTL_TALMOUT_Msk      (0x1ul << BODTALM_TALMCTL_TALMOUT_Pos)            /*!< BODTALM TALMCTL: TALMOUT Mask          */
S
S#define BODTALM_TALMCTL_TALMIEN_Pos      (2)                                               /*!< BODTALM TALMCTL: TALMIEN Position      */
S#define BODTALM_TALMCTL_TALMIEN_Msk      (0x1ul << BODTALM_TALMCTL_TALMIEN_Pos)            /*!< BODTALM TALMCTL: TALMIEN Mask          */
S
S#define BODTALM_TALMCTL_TALMIF_Pos       (3)                                               /*!< BODTALM TALMCTL: TALMIF Position       */
S#define BODTALM_TALMCTL_TALMIF_Msk       (0x1ul << BODTALM_TALMCTL_TALMIF_Pos)             /*!< BODTALM TALMCTL: TALMIF Mask           */
S
S#define BODTALM_BODDTMR_DURTOFF_Pos      (0)                                               /*!< BODTALM BODDTMR: DURTOFF Position      */
S#define BODTALM_BODDTMR_DURTOFF_Msk      (0xfffful << BODTALM_BODDTMR_DURTOFF_Pos)         /*!< BODTALM BODDTMR: DURTOFF Mask          */
S
S#define BODTALM_BODDTMR_DURTON_Pos       (16)                                              /*!< BODTALM BODDTMR: DURTON Position       */
S#define BODTALM_BODDTMR_DURTON_Msk       (0xful << BODTALM_BODDTMR_DURTON_Pos)             /*!< BODTALM BODDTMR: DURTON Mask           */
S
S/**@}*/ /* BODTALM_CONST */
S/**@}*/ /* end of BODTALM register group */
S
S
S/*---------------------- System Clock Controller -------------------------*/
S/**
S    @addtogroup CLK System Clock Controller(CLK)
S    Memory Mapped Structure for CLK Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * PWRCTL
S     * ===================================================================================================
S     * Offset: 0x00  System Power Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |LXTEN     |External 32.768 kHz Crystal Enable Bit
S     * |        |          |0 = disable (default)
S     * |        |          |1 = enable
S     * |[2]     |HIRCEN    |OSC49M Oscillator Enable Bit
S     * |        |          |0 = disable
S     * |        |          |1 = enable (default)
S     * |[3]     |LIRCEN    |OSC16K Oscillator Enable Bit
S     * |        |          |0 = disable
S     * |        |          |1 = enable (default)
S     * |[9]     |STOP      |Stop
S     * |        |          |Reserved - do not set to '1'
S     * |[10]    |SPDEN     |Standby Power Down (SPD) Bit
S     * |        |          |Set to '1' and issue WFI/WFE instruction to enter SPD mode.
S     * |[11]    |DPDEN     |Deep Power Down (DPD) Bit
S     * |        |          |Set to '1' and issue WFI/WFE instruction to enter DPD mode.
S     * |[16]    |WKPINEN   |Wakeup Pin Enabled Control
S     * |        |          |Determines whether WAKEUP pin is enabled in DPD mode.
S     * |        |          |0 = enabled
S     * |        |          |1 = disabled
S     * |[17]    |LIRCDPDEN |OSC16K Enabled Control
S     * |        |          |Determines whether OSC16K is enabled in DPD mode.
S     * |        |          |If OSC16K is disabled, device cannot wake from DPD with SELWKTMR delay.
S     * |        |          |0 = enabled
S     * |        |          |1 = disabled
S     * |[20:23] |SELWKTMR  |Select Wakeup Timer
S     * |        |          |SELWKTMR[0] = 1: WAKEUP after 128 OSC16K clocks (12.8 ms)
S     * |        |          |SELWKTMR[1] = 1: WAKEUP after 256 OSC16K clocks (25.6 ms)
S     * |        |          |SELWKTMR[2] = 1: WAKEUP after 512 OSC16K clocks (51.2 ms)
S     * |        |          |SELWKTMR[3] = 1: WAKEUP after 1024 OSC16K clocks (102.4ms)
S     * |[24]    |WKPINWKF  |Pin Wakeup Flag
S     * |        |          |Read Only.
S     * |        |          |This flag indicates that wakeup of device was requested with a high to low transition of the WAKEUP pin.
S     * |        |          |Flag is cleared when DPD mode is entered.
S     * |[25]    |TMRWKF    |Timer Wakeup Flag
S     * |        |          |Read Only.
S     * |        |          |This flag indicates that wakeup of device was requested with TIMER count of the 16Khz oscillator.
S     * |        |          |Flag is cleared when DPD mode is entered.
S     * |[26]    |PORWKF    |POI Wakeup Flag
S     * |        |          |Read Only.
S     * |        |          |This flag indicates that wakeup of device was requested with a power-on reset.
S     * |        |          |Flag is cleared when DPD mode is entered.
S     * |[28:31] |WKTMRSTS  |Current Wakeup Timer Setting
S     * |        |          |Read-Only.
S     * |        |          |Read back of the current WAKEUP timer setting.
S     * |        |          |This value is updated with SELWKTMR upon entering DPD mode.
S */
S    __IO uint32_t PWRCTL;                
S
S    /**
S     * AHBCLK
S     * ===================================================================================================
S     * Offset: 0x04  AHB Device Clock Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |HCLKEN    |CPU Clock Enable (HCLK)
S     * |        |          |Must be left as '1' for normal operation.
S     * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Control
S     * |        |          |0 = To disable the PDMA engine clock
S     * |        |          |1 = To enable the PDMA engine clock.
S     * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Control
S     * |        |          |0 = To disable the Flash ISP engine clock.
S     * |        |          |1 = To enable the Flash ISP engine clock.
S */
S    __IO uint32_t AHBCLK;                
S
S    /**
S     * APBCLK0
S     * ===================================================================================================
S     * Offset: 0x08  APB Device Clock Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |WDTCKEN   |Watchdog Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[5]     |RTCCKEN   |Real-Time-Clock APB Interface Clock Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[6]     |TMR0CKEN  |Timer0 Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[7]     |TMR1CKEN  |Timer1 Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[8]     |I2C0CKEN  |I2C0 Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[12]    |SPI0CKEN  |SPI0 Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[13]    |DPWMCKEN  |Differential PWM Speaker Driver Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[16]    |UARTCKEN  |UART0 Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[18]    |BFALCKEN  |Biquad Filter And Automatic Level Control Block Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[19]    |CRCCKEN   |Cyclic Redundancy Check Block Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[20]    |PWM0CH01CKEN|PWM0 CH0 and CH1 Block Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[22]    |ACMPCKEN  |Analog Comparator Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[26]    |SBRAMCKEN |Standby RAM Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[28]    |ADCCKEN   |Audio Analog-Digital-Converter (ADC) Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[29]    |I2S0CKEN  |I2S Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[30]    |ANACKEN   |Analog Block Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S */
S    __IO uint32_t APBCLK0;               
S
S    /**
S     * DPDSTATE
S     * ===================================================================================================
S     * Offset: 0x0C  Deep Power Down State Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |DPDSTSWR  |DPD State Write
S     * |        |          |To set the CLK_DPDSTATE register, write value to this register. Data is latched on next DPD event. 
S     * |[8:15]  |DPDSTSRD  |DPD State Read Back
S     * |        |          |Read back of CLK_DPDSTATE register. This register was preserved from last DPD event . 
S */
S    __IO uint32_t DPDSTATE;              
S
S    /**
S     * CLKSEL0
S     * ===================================================================================================
S     * Offset: 0x10  Clock Source Select Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |HCLKSEL   |HCLK Clock Source Select
S     * |        |          |Ensure that related clock sources (pre-select and new-select) are enabled before updating register.
S     * |        |          |These bits are protected, to write to bits first perform the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
S     * |        |          |000 = clock source from internal OSC48M oscillator.
S     * |        |          |001 = clock source from external 32kHz crystal clock
S     * |        |          |010 = clock source from internal 16 kHz oscillator clock
S     * |        |          |Others = reserved
S     * |[3:5]   |STCLKSEL  |MCU Cortex_M0 SysTick Clock Source Select
S     * |        |          |These bits are protected, to write to bits first perform the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
S     * |        |          |000 = clock source from 16 kHz internal clock
S     * |        |          |001 = clock source from external 32kHz crystal clock
S     * |        |          |010 = clock source from 16 kHz internal oscillator divided by 2
S     * |        |          |011 = clock source from OSC49M internal oscillator divided by 2
S     * |        |          |1xx = clock source from HCLK / 2 (Default)
S     * |        |          |Note that to use STCLKSEL as source of SysTic timer the CLKSRC bit of SYST_CSR must be set to 0.
S     * |[6]     |HIRCFSEL  |OSC48M Frequency Select
S     * |        |          |Determines which trim setting to use for OSC48M internal oscillator.
S     * |        |          |Oscillator is factory trimmed within 1% to:.
S     * |        |          |0= 49.152MHz (Default)
S     * |        |          |1= 32.768MHz
S */
S    __IO uint32_t CLKSEL0;               
S
S    /**
S     * CLKSEL1
S     * ===================================================================================================
S     * Offset: 0x14  Clock Source Select Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |WDTSEL    |WDT CLK Clock Source Select
S     * |        |          |00 = clock source from internal OSC48M oscillator clock
S     * |        |          |01 = clock source from external 32kHz crystal clock
S     * |        |          |10 = clock source from HCLK/2048 clock
S     * |        |          |11 = clock source from internal 16 kHz oscillator clock
S     * |[4]     |DPWMCKSEL |Differential Speaker Driver PWM Clock Source Select
S     * |        |          |0 = OSC48M clock
S     * |        |          |1 = 2x OSC48M clock
S     * |[8:10]  |TMR0SEL   |TIMER0 Clock Source Select
S     * |        |          |000 = clock source from internal 16 kHz oscillator
S     * |        |          |001 = clock source from external 32kHz crystal clock
S     * |        |          |010 = clock source from HCLK
S     * |        |          |011 = clock source from external pin (GPIOA[14])
S     * |        |          |1xx = clock source from internal OSC48M oscillator clock
S     * |[12:14] |TMR1SEL   |TIMER1 Clock Source Select
S     * |        |          |000 = clock source from internal 16 kHz oscillator
S     * |        |          |001 = clock source from external 32kHz crystal clock
S     * |        |          |010 = clock source from HCLK
S     * |        |          |011 = clock source from external pin (GPIOA[15])
S     * |        |          |1xx = clock source from internal OSC48M oscillator clock
S     * |[28:29] |PWM0CH01CKSEL|PWM0 CH0 and CH1 Clock Source Select
S     * |        |          |PWM0 and PWM1 uses the same clock source, and prescaler
S     * |        |          |00 = clock source from internal 16 kHz oscillator
S     * |        |          |01 = clock source from external 32kHz crystal clock
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal OSC48M oscillator clock
S */
S    __IO uint32_t CLKSEL1;               
S
S    /**
S     * CLKDIV0
S     * ===================================================================================================
S     * Offset: 0x18  Clock Divider Number Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
S     * |        |          |The HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1)
S     * |[8:11]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
S     * |        |          |The UART clock frequency = (UART clock source frequency ) / (UARTDIV + 1)
S     * |[16:23] |ADCDIV    |ADC Clock Divide Number From ADC Clock Source
S     * |        |          |The ADC clock frequency = (ADC clock source frequency ) / (ADCDIV + 1)
S */
S    __IO uint32_t CLKDIV0;               
S
S    /**
S     * CLKSEL2
S     * ===================================================================================================
S     * Offset: 0x1C  Clock Source Select Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |I2S0SEL   |I2S Clock Source Select
S     * |        |          |00 = clock source from internal 16 kHz oscillator
S     * |        |          |01 = clock source from external 32kHz crystal clock
S     * |        |          |10 = clock source from HCLK
S     * |        |          |11 = clock source from internal OSC48M oscillator clock
S */
S    __IO uint32_t CLKSEL2;               
S
S    /**
S     * SLEEPCTL
S     * ===================================================================================================
S     * Offset: 0x20  Sleep Clock Source Select  Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |HCLKEN    |CPU Clock Sleep Enable (HCLK)
S     * |        |          |Must be left as '1' for normal operation.
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[1]     |PDMACKEN  |PDMA Controller Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[2]     |ISPCKEN   |Flash ISP Controller Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[4]     |WDTCKEN   |Watchdog Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[5]     |RTCCKEN   |Real-Time- Sleep Clock APB Interface Clock Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[6]     |TMR0CKEN  |Timer0 Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[7]     |TMR1CKEN  |Timer1 Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[8]     |I2C0CKEN  |I2C0 Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[12]    |SPI0CKEN  |SPI0 Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[13]    |DPWMCKEN  |Differential PWM Speaker Driver Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[16]    |UARTCKEN  |UART0 Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[18]    |BFALCKEN  |Biquad filter/ALC block Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[19]    |CRCCKEN   |Cyclic Redundancy Check Sleep Block Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[20]    |PWM0CH01CKEN|PWM0 CH0 and CH1 Block Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[22]    |ACMPCKEN  |Analog Comparator Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[26]    |SBRAMCKEN |Standby RAM Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[28]    |ADCCKEN   |Audio Analog-Digital-Converter (ADC) Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[29]    |I2S0CKEN  |I2S Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[30]    |ANACKEN   |Analog Block Sleep Clock Enable Control
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S */
S    __IO uint32_t SLEEPCTL;              
S
S    /**
S     * PWRSTSF
S     * ===================================================================================================
S     * Offset: 0x24  Power State Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DSF       |Deep Sleep Flag
S     * |        |          |This flag is set if core logic was placed in Deep Sleep mode. Write '1' to clear flag.
S     * |[1]     |STOPF     |Stop Flag
S     * |        |          |This flag is set if core logic was stopped but not powered down. Write '1' to clear flag.
S     * |[2]     |SPDF      |Powered Down Flag
S     * |        |          |This flag is set if core logic was powered down to Standby (SPD). Write '1' to clear flag.
S */
S    __IO uint32_t PWRSTSF;               
S
S    /**
S     * DBGPD
S     * ===================================================================================================
S     * Offset: 0x28  Debug Port Power Down Disable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DISPDREQ  |Disable Power Down
S     * |        |          |0 = Enable power down requests.
S     * |        |          |1 = Disable power down requests.
S     * |[6]     |ICECLKST  |ICE_CLK Pin State
S     * |        |          |Read Only. Current state of ICE_CLK pin.
S     * |[7]     |ICEDATST  |ICE_DAT Pin State
S     * |        |          |Read Only. Current state of ICE_DAT pin.
S */
S    __IO uint32_t DBGPD;                 
S
S} CLK_T;
S
S/**
S    @addtogroup CLK_CONST CLK Bit Field Definition
S    Constant Definitions for CLK Controller
S@{ */
S
S#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK PWRCTL: LXTEN Position             */
S#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK PWRCTL: LXTEN Mask                 */
S
S#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK PWRCTL: HIRCEN Position            */
S#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK PWRCTL: HIRCEN Mask                */
S
S#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK PWRCTL: LIRCEN Position            */
S#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK PWRCTL: LIRCEN Mask                */
S
S#define CLK_PWRCTL_STOP_Pos              (9)                                               /*!< CLK PWRCTL: STOP Position              */
S#define CLK_PWRCTL_STOP_Msk              (0x1ul << CLK_PWRCTL_STOP_Pos)                    /*!< CLK PWRCTL: STOP Mask                  */
S
S#define CLK_PWRCTL_SPDEN_Pos             (10)                                              /*!< CLK PWRCTL: SPDEN Position             */
S#define CLK_PWRCTL_SPDEN_Msk             (0x1ul << CLK_PWRCTL_SPDEN_Pos)                   /*!< CLK PWRCTL: SPDEN Mask                 */
S
S#define CLK_PWRCTL_DPDEN_Pos             (11)                                              /*!< CLK PWRCTL: DPDEN Position             */
S#define CLK_PWRCTL_DPDEN_Msk             (0x1ul << CLK_PWRCTL_DPDEN_Pos)                   /*!< CLK PWRCTL: DPDEN Mask                 */
S
S#define CLK_PWRCTL_WKPINEN_Pos           (16)                                              /*!< CLK PWRCTL: WKPINEN Position           */
S#define CLK_PWRCTL_WKPINEN_Msk           (0x1ul << CLK_PWRCTL_WKPINEN_Pos)                 /*!< CLK PWRCTL: WKPINEN Mask               */
S
S#define CLK_PWRCTL_LIRCDPDEN_Pos         (17)                                              /*!< CLK PWRCTL: LIRCDPDEN Position         */
S#define CLK_PWRCTL_LIRCDPDEN_Msk         (0x1ul << CLK_PWRCTL_LIRCDPDEN_Pos)               /*!< CLK PWRCTL: LIRCDPDEN Mask             */
S
S#define CLK_PWRCTL_SELWKTMR_Pos          (20)                                              /*!< CLK PWRCTL: SELWKTMR Position          */
S#define CLK_PWRCTL_SELWKTMR_Msk          (0xful << CLK_PWRCTL_SELWKTMR_Pos)                /*!< CLK PWRCTL: SELWKTMR Mask              */
S
S#define CLK_PWRCTL_WKPINWKF_Pos          (24)                                              /*!< CLK PWRCTL: WKPINWKF Position          */
S#define CLK_PWRCTL_WKPINWKF_Msk          (0x1ul << CLK_PWRCTL_WKPINWKF_Pos)                /*!< CLK PWRCTL: WKPINWKF Mask              */
S
S#define CLK_PWRCTL_TMRWKF_Pos            (25)                                              /*!< CLK PWRCTL: TMRWKF Position            */
S#define CLK_PWRCTL_TMRWKF_Msk            (0x1ul << CLK_PWRCTL_TMRWKF_Pos)                  /*!< CLK PWRCTL: TMRWKF Mask                */
S
S#define CLK_PWRCTL_PORWKF_Pos            (26)                                              /*!< CLK PWRCTL: PORWKF Position            */
S#define CLK_PWRCTL_PORWKF_Msk            (0x1ul << CLK_PWRCTL_PORWKF_Pos)                  /*!< CLK PWRCTL: PORWKF Mask                */
S
S#define CLK_PWRCTL_WKTMRSTS_Pos          (28)                                              /*!< CLK PWRCTL: WKTMRSTS Position          */
S#define CLK_PWRCTL_WKTMRSTS_Msk          (0xful << CLK_PWRCTL_WKTMRSTS_Pos)                /*!< CLK PWRCTL: WKTMRSTS Mask              */
S
S#define CLK_AHBCLK_HCLKEN_Pos            (0)                                               /*!< CLK AHBCLK: HCLKEN Position            */
S#define CLK_AHBCLK_HCLKEN_Msk            (0x1ul << CLK_AHBCLK_HCLKEN_Pos)                  /*!< CLK AHBCLK: HCLKEN Mask                */
S
S#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK AHBCLK: PDMACKEN Position          */
S#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK AHBCLK: PDMACKEN Mask              */
S
S#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK AHBCLK: ISPCKEN Position           */
S#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK AHBCLK: ISPCKEN Mask               */
S
S#define CLK_APBCLK0_WDTCKEN_Pos          (4)                                               /*!< CLK APBCLK0: WDTCKEN Position          */
S#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK APBCLK0: WDTCKEN Mask              */
S
S#define CLK_APBCLK0_RTCCKEN_Pos          (5)                                               /*!< CLK APBCLK0: RTCCKEN Position          */
S#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK APBCLK0: RTCCKEN Mask              */
S
S#define CLK_APBCLK0_TMR0CKEN_Pos         (6)                                               /*!< CLK APBCLK0: TMR0CKEN Position         */
S#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK APBCLK0: TMR0CKEN Mask             */
S
S#define CLK_APBCLK0_TMR1CKEN_Pos         (7)                                               /*!< CLK APBCLK0: TMR1CKEN Position         */
S#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK APBCLK0: TMR1CKEN Mask             */
S
S#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK APBCLK0: I2C0CKEN Position         */
S#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK APBCLK0: I2C0CKEN Mask             */
S
S#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK APBCLK0: SPI0CKEN Position         */
S#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK APBCLK0: SPI0CKEN Mask             */
S
S#define CLK_APBCLK0_DPWMCKEN_Pos         (13)                                              /*!< CLK APBCLK0: DPWMCKEN Position         */
S#define CLK_APBCLK0_DPWMCKEN_Msk         (0x1ul << CLK_APBCLK0_DPWMCKEN_Pos)               /*!< CLK APBCLK0: DPWMCKEN Mask             */
S
S#define CLK_APBCLK0_UARTCKEN_Pos         (16)                                              /*!< CLK APBCLK0: UARTCKEN Position         */
S#define CLK_APBCLK0_UARTCKEN_Msk         (0x1ul << CLK_APBCLK0_UARTCKEN_Pos)               /*!< CLK APBCLK0: UARTCKEN Mask             */
S
S#define CLK_APBCLK0_BFALCKEN_Pos         (18)                                              /*!< CLK APBCLK0: BFALCKEN Position         */
S#define CLK_APBCLK0_BFALCKEN_Msk         (0x1ul << CLK_APBCLK0_BFALCKEN_Pos)               /*!< CLK APBCLK0: BFALCKEN Mask             */
S
S#define CLK_APBCLK0_CRCCKEN_Pos          (19)                                              /*!< CLK APBCLK0: CRCCKEN Position          */
S#define CLK_APBCLK0_CRCCKEN_Msk          (0x1ul << CLK_APBCLK0_CRCCKEN_Pos)                /*!< CLK APBCLK0: CRCCKEN Mask              */
S
S#define CLK_APBCLK0_PWM0CH01CKEN_Pos     (20)                                              /*!< CLK APBCLK0: PWM0CH01CKEN Position     */
S#define CLK_APBCLK0_PWM0CH01CKEN_Msk     (0x1ul << CLK_APBCLK0_PWM0CH01CKEN_Pos)           /*!< CLK APBCLK0: PWM0CH01CKEN Mask         */
S
S#define CLK_APBCLK0_ACMPCKEN_Pos         (22)                                              /*!< CLK APBCLK0: ACMPCKEN Position         */
S#define CLK_APBCLK0_ACMPCKEN_Msk         (0x1ul << CLK_APBCLK0_ACMPCKEN_Pos)               /*!< CLK APBCLK0: ACMPCKEN Mask             */
S
S#define CLK_APBCLK0_SBRAMCKEN_Pos        (26)                                              /*!< CLK APBCLK0: SBRAMCKEN Position        */
S#define CLK_APBCLK0_SBRAMCKEN_Msk        (0x1ul << CLK_APBCLK0_SBRAMCKEN_Pos)              /*!< CLK APBCLK0: SBRAMCKEN Mask            */
S
S#define CLK_APBCLK0_ADCCKEN_Pos          (28)                                              /*!< CLK APBCLK0: ADCCKEN Position          */
S#define CLK_APBCLK0_ADCCKEN_Msk          (0x1ul << CLK_APBCLK0_ADCCKEN_Pos)                /*!< CLK APBCLK0: ADCCKEN Mask              */
S
S#define CLK_APBCLK0_I2S0CKEN_Pos         (29)                                              /*!< CLK APBCLK0: I2S0CKEN Position         */
S#define CLK_APBCLK0_I2S0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2S0CKEN_Pos)               /*!< CLK APBCLK0: I2S0CKEN Mask             */
S
S#define CLK_APBCLK0_ANACKEN_Pos          (30)                                              /*!< CLK APBCLK0: ANACKEN Position          */
S#define CLK_APBCLK0_ANACKEN_Msk          (0x1ul << CLK_APBCLK0_ANACKEN_Pos)                /*!< CLK APBCLK0: ANACKEN Mask              */
S
S#define CLK_DPDSTATE_DPDSTSWR_Pos        (0)                                               /*!< CLK DPDSTATE: DPDSTSWR Position        */
S#define CLK_DPDSTATE_DPDSTSWR_Msk        (0xfful << CLK_DPDSTATE_DPDSTSWR_Pos)             /*!< CLK DPDSTATE: DPDSTSWR Mask            */
S
S#define CLK_DPDSTATE_DPDSTSRD_Pos        (8)                                               /*!< CLK DPDSTATE: DPDSTSRD Position        */
S#define CLK_DPDSTATE_DPDSTSRD_Msk        (0xfful << CLK_DPDSTATE_DPDSTSRD_Pos)             /*!< CLK DPDSTATE: DPDSTSRD Mask            */
S
S#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK CLKSEL0: HCLKSEL Position          */
S#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK CLKSEL0: HCLKSEL Mask              */
S
S#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK CLKSEL0: STCLKSEL Position         */
S#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK CLKSEL0: STCLKSEL Mask             */
S
S#define CLK_CLKSEL0_HIRCFSEL_Pos         (6)                                               /*!< CLK CLKSEL0: HIRCFSEL Position         */
S#define CLK_CLKSEL0_HIRCFSEL_Msk         (0x1ul << CLK_CLKSEL0_HIRCFSEL_Pos)               /*!< CLK CLKSEL0: HIRCFSEL Mask             */
S
S#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK CLKSEL1: WDTSEL Position           */
S#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK CLKSEL1: WDTSEL Mask               */
S
S#define CLK_CLKSEL1_DPWMCKSEL_Pos        (4)                                               /*!< CLK CLKSEL1: DPWMCKSEL Position        */
S#define CLK_CLKSEL1_DPWMCKSEL_Msk        (0x1ul << CLK_CLKSEL1_DPWMCKSEL_Pos)              /*!< CLK CLKSEL1: DPWMCKSEL Mask            */
S
S#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK CLKSEL1: TMR0SEL Position          */
S#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK CLKSEL1: TMR0SEL Mask              */
S
S#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK CLKSEL1: TMR1SEL Position          */
S#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK CLKSEL1: TMR1SEL Mask              */
S
S#define CLK_CLKSEL1_PWM0CH01CKSEL_Pos    (28)                                              /*!< CLK CLKSEL1: PWM0CH01CKSEL Position    */
S#define CLK_CLKSEL1_PWM0CH01CKSEL_Msk    (0x3ul << CLK_CLKSEL1_PWM0CH01CKSEL_Pos)          /*!< CLK CLKSEL1: PWM0CH01CKSEL Mask        */
S
S#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK CLKDIV0: HCLKDIV Position          */
S#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK CLKDIV0: HCLKDIV Mask              */
S
S#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK CLKDIV0: UARTDIV Position          */
S#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK CLKDIV0: UARTDIV Mask              */
S
S#define CLK_CLKDIV0_ADCDIV_Pos           (16)                                              /*!< CLK CLKDIV0: ADCDIV Position           */
S#define CLK_CLKDIV0_ADCDIV_Msk           (0xfful << CLK_CLKDIV0_ADCDIV_Pos)                /*!< CLK CLKDIV0: ADCDIV Mask               */
S
S#define CLK_CLKSEL2_I2S0SEL_Pos          (0)                                               /*!< CLK CLKSEL2: I2S0SEL Position          */
S#define CLK_CLKSEL2_I2S0SEL_Msk          (0x3ul << CLK_CLKSEL2_I2S0SEL_Pos)                /*!< CLK CLKSEL2: I2S0SEL Mask              */
S
S#define CLK_SLEEPCTL_HCLKEN_Pos          (0)                                               /*!< CLK SLEEPCTL: HCLKEN Position          */
S#define CLK_SLEEPCTL_HCLKEN_Msk          (0x1ul << CLK_SLEEPCTL_HCLKEN_Pos)                /*!< CLK SLEEPCTL: HCLKEN Mask              */
S
S#define CLK_SLEEPCTL_PDMACKEN_Pos        (1)                                               /*!< CLK SLEEPCTL: PDMACKEN Position        */
S#define CLK_SLEEPCTL_PDMACKEN_Msk        (0x1ul << CLK_SLEEPCTL_PDMACKEN_Pos)              /*!< CLK SLEEPCTL: PDMACKEN Mask            */
S
S#define CLK_SLEEPCTL_ISPCKEN_Pos         (2)                                               /*!< CLK SLEEPCTL: ISPCKEN Position         */
S#define CLK_SLEEPCTL_ISPCKEN_Msk         (0x1ul << CLK_SLEEPCTL_ISPCKEN_Pos)               /*!< CLK SLEEPCTL: ISPCKEN Mask             */
S
S#define CLK_SLEEPCTL_WDTCKEN_Pos         (4)                                               /*!< CLK SLEEPCTL: WDTCKEN Position         */
S#define CLK_SLEEPCTL_WDTCKEN_Msk         (0x1ul << CLK_SLEEPCTL_WDTCKEN_Pos)               /*!< CLK SLEEPCTL: WDTCKEN Mask             */
S
S#define CLK_SLEEPCTL_RTCCKEN_Pos         (5)                                               /*!< CLK SLEEPCTL: RTCCKEN Position         */
S#define CLK_SLEEPCTL_RTCCKEN_Msk         (0x1ul << CLK_SLEEPCTL_RTCCKEN_Pos)               /*!< CLK SLEEPCTL: RTCCKEN Mask             */
S
S#define CLK_SLEEPCTL_TMR0CKEN_Pos        (6)                                               /*!< CLK SLEEPCTL: TMR0CKEN Position        */
S#define CLK_SLEEPCTL_TMR0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_TMR0CKEN_Pos)              /*!< CLK SLEEPCTL: TMR0CKEN Mask            */
S
S#define CLK_SLEEPCTL_TMR1CKEN_Pos        (7)                                               /*!< CLK SLEEPCTL: TMR1CKEN Position        */
S#define CLK_SLEEPCTL_TMR1CKEN_Msk        (0x1ul << CLK_SLEEPCTL_TMR1CKEN_Pos)              /*!< CLK SLEEPCTL: TMR1CKEN Mask            */
S
S#define CLK_SLEEPCTL_I2C0CKEN_Pos        (8)                                               /*!< CLK SLEEPCTL: I2C0CKEN Position        */
S#define CLK_SLEEPCTL_I2C0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_I2C0CKEN_Pos)              /*!< CLK SLEEPCTL: I2C0CKEN Mask            */
S
S#define CLK_SLEEPCTL_SPI0CKEN_Pos        (12)                                              /*!< CLK SLEEPCTL: SPI0CKEN Position        */
S#define CLK_SLEEPCTL_SPI0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_SPI0CKEN_Pos)              /*!< CLK SLEEPCTL: SPI0CKEN Mask            */
S
S#define CLK_SLEEPCTL_DPWMCKEN_Pos        (13)                                              /*!< CLK SLEEPCTL: DPWMCKEN Position        */
S#define CLK_SLEEPCTL_DPWMCKEN_Msk        (0x1ul << CLK_SLEEPCTL_DPWMCKEN_Pos)              /*!< CLK SLEEPCTL: DPWMCKEN Mask            */
S
S#define CLK_SLEEPCTL_UARTCKEN_Pos        (16)                                              /*!< CLK SLEEPCTL: UARTCKEN Position        */
S#define CLK_SLEEPCTL_UARTCKEN_Msk        (0x1ul << CLK_SLEEPCTL_UARTCKEN_Pos)              /*!< CLK SLEEPCTL: UARTCKEN Mask            */
S
S#define CLK_SLEEPCTL_BFALCKEN_Pos        (18)                                              /*!< CLK SLEEPCTL: BFALCKEN Position        */
S#define CLK_SLEEPCTL_BFALCKEN_Msk        (0x1ul << CLK_SLEEPCTL_BFALCKEN_Pos)              /*!< CLK SLEEPCTL: BFALCKEN Mask            */
S
S#define CLK_SLEEPCTL_CRCCKEN_Pos         (19)                                              /*!< CLK SLEEPCTL: CRCCKEN Position         */
S#define CLK_SLEEPCTL_CRCCKEN_Msk         (0x1ul << CLK_SLEEPCTL_CRCCKEN_Pos)               /*!< CLK SLEEPCTL: CRCCKEN Mask             */
S
S#define CLK_SLEEPCTL_PWM0CH01CKEN_Pos    (20)                                              /*!< CLK SLEEPCTL: PWM0CH01CKEN Position    */
S#define CLK_SLEEPCTL_PWM0CH01CKEN_Msk    (0x1ul << CLK_SLEEPCTL_PWM0CH01CKEN_Pos)          /*!< CLK SLEEPCTL: PWM0CH01CKEN Mask        */
S
S#define CLK_SLEEPCTL_ACMPCKEN_Pos        (22)                                              /*!< CLK SLEEPCTL: ACMPCKEN Position        */
S#define CLK_SLEEPCTL_ACMPCKEN_Msk        (0x1ul << CLK_SLEEPCTL_ACMPCKEN_Pos)              /*!< CLK SLEEPCTL: ACMPCKEN Mask            */
S
S#define CLK_SLEEPCTL_SBRAMCKEN_Pos       (26)                                              /*!< CLK SLEEPCTL: SBRAMCKEN Position       */
S#define CLK_SLEEPCTL_SBRAMCKEN_Msk       (0x1ul << CLK_SLEEPCTL_SBRAMCKEN_Pos)             /*!< CLK SLEEPCTL: SBRAMCKEN Mask           */
S
S#define CLK_SLEEPCTL_ADCCKEN_Pos         (28)                                              /*!< CLK SLEEPCTL: ADCCKEN Position         */
S#define CLK_SLEEPCTL_ADCCKEN_Msk         (0x1ul << CLK_SLEEPCTL_ADCCKEN_Pos)               /*!< CLK SLEEPCTL: ADCCKEN Mask             */
S
S#define CLK_SLEEPCTL_I2S0CKEN_Pos        (29)                                              /*!< CLK SLEEPCTL: I2S0CKEN Position        */
S#define CLK_SLEEPCTL_I2S0CKEN_Msk        (0x1ul << CLK_SLEEPCTL_I2S0CKEN_Pos)              /*!< CLK SLEEPCTL: I2S0CKEN Mask            */
S
S#define CLK_SLEEPCTL_ANACKEN_Pos         (30)                                              /*!< CLK SLEEPCTL: ANACKEN Position         */
S#define CLK_SLEEPCTL_ANACKEN_Msk         (0x1ul << CLK_SLEEPCTL_ANACKEN_Pos)               /*!< CLK SLEEPCTL: ANACKEN Mask             */
S
S#define CLK_PWRSTSF_DSF_Pos              (0)                                               /*!< CLK PWRSTSF: DSF Position              */
S#define CLK_PWRSTSF_DSF_Msk              (0x1ul << CLK_PWRSTSF_DSF_Pos)                    /*!< CLK PWRSTSF: DSF Mask                  */
S
S#define CLK_PWRSTSF_STOPF_Pos            (1)                                               /*!< CLK PWRSTSF: STOPF Position            */
S#define CLK_PWRSTSF_STOPF_Msk            (0x1ul << CLK_PWRSTSF_STOPF_Pos)                  /*!< CLK PWRSTSF: STOPF Mask                */
S
S#define CLK_PWRSTSF_SPDF_Pos             (2)                                               /*!< CLK PWRSTSF: SPDF Position             */
S#define CLK_PWRSTSF_SPDF_Msk             (0x1ul << CLK_PWRSTSF_SPDF_Pos)                   /*!< CLK PWRSTSF: SPDF Mask                 */
S
S#define CLK_DBGPD_DISPDREQ_Pos           (0)                                               /*!< CLK DBGPD: DISPDREQ Position           */
S#define CLK_DBGPD_DISPDREQ_Msk           (0x1ul << CLK_DBGPD_DISPDREQ_Pos)                 /*!< CLK DBGPD: DISPDREQ Mask               */
S
S#define CLK_DBGPD_ICECLKST_Pos           (6)                                               /*!< CLK DBGPD: ICECLKST Position           */
S#define CLK_DBGPD_ICECLKST_Msk           (0x1ul << CLK_DBGPD_ICECLKST_Pos)                 /*!< CLK DBGPD: ICECLKST Mask               */
S
S#define CLK_DBGPD_ICEDATST_Pos           (7)                                               /*!< CLK DBGPD: ICEDATST Position           */
S#define CLK_DBGPD_ICEDATST_Msk           (0x1ul << CLK_DBGPD_ICEDATST_Pos)                 /*!< CLK DBGPD: ICEDATST Mask               */
S
S/**@}*/ /* CLK_CONST */
S/**@}*/ /* end of CLK register group */
S
S
S/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
S/**
S    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
S    Memory Mapped Structure for CRC Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  CRC Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:8]   |PKTLEN    |CRC Packet Length
S     * |        |          |Indicates number of bytes of CRC input to process.
S     * |        |          |CRC calculation will stop once input number of bytes = PKTLEN+1.
S     * |        |          |Maximum packet size is 512 bytes, for PKTLEN = 511.
S     * |        |          |Writing any value to this register will flush all previous calculations and restart a new CRC calculation.
S     * |[16]    |MODE      |CRC LSB mode
S     * |        |          |Determines whether CRC Generator processes input words (32bit/4Bytes) LSB (least significant byte) first or MSB (most significant byte) first.
S     * |        |          |0 = CRC input is MSB first (default).
S     * |        |          |1 = CRC input is LSB first.
S     * |        |          |For example if MODE = 1, and 0x01020304 is written to CRC_DAT, bytes will be processed in order 0x04, 0x03, 0x02, 0x01.
S     * |        |          |If MODE = 0, then order would be 0x01, 0x02, 0x3, 0x04.
S     * |        |          |Writing any value to this register will flush all previous calculations and restart a new CRC calculation.
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * DAT
S     * ===================================================================================================
S     * Offset: 0x04  CRC Input Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |DATA      |CRC Input
S     * |        |          |The string of bytes to perform CRC calculation on.
S     * |        |          |When MODE = 0, CRC performs calculation byte by byte in the order DATA[31:24], DATA[23:16], DATA[15:8], DATA[7:0].
S     * |        |          |When MODE = 1, CRC performs calculation byte by byte in the order DATA[7:0], DATA[15:8], DATA[23:16], DATA[31:24].
S     * |        |          |If number of input bytes exceeds CRC Packet Length (CRC_CTL[8:0]+1), any additional input bytes will be ignored.
S     * |        |          |The CRC generator takes four clock cycles to process the CRC input.
S     * |        |          |Software must ensure that at least four clock cycles occur between writes of CRC_DAT.
S     * |        |          |Compiled assembly language can be examined to ensure this requirement is met.
S */
S    __IO uint32_t DAT;                   
S
S    /**
S     * CHECKSUM
S     * ===================================================================================================
S     * Offset: 0x08  CRC Output Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |CHECKSUM  |CRC Output
S     * |        |          |The result of CRC computation.
S     * |        |          |The result is valid four clock cycles after last CRC_DAT input data is written to CRC generator.
S */
S    __I  uint32_t CHECKSUM;              
S
S} CRC_T;
S
S/**
S    @addtogroup CRC_CONST CRC Bit Field Definition
S    Constant Definitions for CRC Controller
S@{ */
S
S#define CRC_CTL_PKTLEN_Pos               (0)                                               /*!< CRC CTL: PKTLEN Position               */
S#define CRC_CTL_PKTLEN_Msk               (0x1fful << CRC_CTL_PKTLEN_Pos)                   /*!< CRC CTL: PKTLEN Mask                   */
S
S#define CRC_CTL_MODE_Pos                 (16)                                              /*!< CRC CTL: MODE Position                 */
S#define CRC_CTL_MODE_Msk                 (0x1ul << CRC_CTL_MODE_Pos)                       /*!< CRC CTL: MODE Mask                     */
S
S#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC DAT: DATA Position                 */
S#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC DAT: DATA Mask                     */
S
S#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC CHECKSUM: CHECKSUM Position        */
S#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffful << CRC_CHECKSUM_CHECKSUM_Pos)           /*!< CRC CHECKSUM: CHECKSUM Mask            */
S
S/**@}*/ /* CRC_CONST */
S/**@}*/ /* end of CRC register group */
S
S
S/*---------------------- Audio Class D Speaker Driver -------------------------*/
S/**
S    @addtogroup DPWM Audio Class D Speaker Driver(DPWM)
S    Memory Mapped Structure for DPWM Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  DPWM Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |MODUFRQ   |DPWM Modulation Frequency
S     * |        |          |This parameter controls the carrier modulation frequency of the PWM signal as a proportion of DPWM_CLK.
S     * |        |          |MODUFRQ : DPWM_CLK Division : Frequency for DPWM_CLK = 98.304MHZ
S     * |        |          |0 : 228 : 431158
S     * |        |          |1 : 156 : 630154
S     * |        |          |2 : 76 : 1293474
S     * |        |          |3 : 52 : 1890462
S     * |        |          |4 : 780 : 126031
S     * |        |          |5 : 524 : 187603
S     * |        |          |6 : 396 : 248242
S     * |        |          |7 : 268 : 366806
S     * |[3]     |DEADTIME  |DPWM Driver Deadtime Control
S     * |        |          |Enabling this bit will insert an additional clock cycle deadtime into the switching of PMOS and NMOS driver transistors.
S     * |[4:5]   |DITHEREN  |DPWM Signal Dither Control
S     * |        |          |To prevent structured noise on PWM output due to DC offsets in the input signal it is possible to add random dither to the PWM signal.
S     * |        |          |These bits control the dither:.
S     * |        |          |0 = No dither.
S     * |        |          |1 = +/- 1 bit dither
S     * |        |          |3 = +/- 2 bit dither
S     * |[6]     |DPWMEN    |DPWM Enable
S     * |        |          |0= Disable DPWM, SPK pins are tri-state, CIC filter is reset, FIFO pointers are reset (FIFO data is not reset).
S     * |        |          |1= Enable DPWM, SPK pins are enabled and driven, data is taken from FIFO.
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * STS
S     * ===================================================================================================
S     * Offset: 0x04  DPWM FIFO Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FULL      |FIFO Full
S     * |        |          |0 = FIFO is not full.
S     * |        |          |1 = FIFO is full.
S     * |[1]     |EMPTY     |FIFO Empty
S     * |        |          |0= FIFO is not empty
S     * |        |          |1= FIFO is empty
S */
S    __I  uint32_t STS;                   
S
S    /**
S     * DMACTL
S     * ===================================================================================================
S     * Offset: 0x08  DPWM PDMA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DMAEN     |Enable DPWM DMA Interface
S     * |        |          |0= Disable PDMA. No requests will be made to PDMA controller.
S     * |        |          |1= Enable PDMA. Block will request data from PDMA controller whenever FIFO is not empty.
S */
S    __IO uint32_t DMACTL;                
S
S    /**
S     * DATA
S     * ===================================================================================================
S     * Offset: 0x0C  DPWM FIFO Input
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |INDATA    |DPWM FIFO Audio Data Input
S     * |        |          |A write to this register pushes data onto the DPWM FIFO and increments the write pointer.
S     * |        |          |This is the address that PDMA writes audio data to.
S */
S    __O  uint32_t DATA;                  
S
S    /**
S     * ZOHDIV
S     * ===================================================================================================
S     * Offset: 0x10  DPWM Zero Order Hold Division Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |ZOHDIV    |DPWM Zero Order Hold, Down-Sampling Divisor
S     * |        |          |The input sample rate of the DPWM is set by HCLK frequency and the divisor set in this register by the following formula:
S     * |        |          |Fs = HCLK/ZOHDIV/64
S     * |        |          |Valid range is 1 to 255.
S     * |        |          |Default is 48, which gives a sample rate of 16kHz for a 49.152MHz (default) HCLK.
S */
S    __IO uint32_t ZOHDIV;                
S
S} DPWM_T;
S
S/**
S    @addtogroup DPWM_CONST DPWM Bit Field Definition
S    Constant Definitions for DPWM Controller
S@{ */
S
S#define DPWM_CTL_MODUFRQ_Pos             (0)                                               /*!< DPWM CTL: MODUFRQ Position             */
S#define DPWM_CTL_MODUFRQ_Msk             (0x7ul << DPWM_CTL_MODUFRQ_Pos)                   /*!< DPWM CTL: MODUFRQ Mask                 */
S
S#define DPWM_CTL_DEADTIME_Pos            (3)                                               /*!< DPWM CTL: DEADTIME Position            */
S#define DPWM_CTL_DEADTIME_Msk            (0x1ul << DPWM_CTL_DEADTIME_Pos)                  /*!< DPWM CTL: DEADTIME Mask                */
S
S#define DPWM_CTL_DITHEREN_Pos            (4)                                               /*!< DPWM CTL: DITHEREN Position            */
S#define DPWM_CTL_DITHEREN_Msk            (0x3ul << DPWM_CTL_DITHEREN_Pos)                  /*!< DPWM CTL: DITHEREN Mask                */
S
S#define DPWM_CTL_DPWMEN_Pos              (6)                                               /*!< DPWM CTL: DPWMEN Position              */
S#define DPWM_CTL_DPWMEN_Msk              (0x1ul << DPWM_CTL_DPWMEN_Pos)                    /*!< DPWM CTL: DPWMEN Mask                  */
S
S#define DPWM_STS_FULL_Pos                (0)                                               /*!< DPWM STS: FULL Position                */
S#define DPWM_STS_FULL_Msk                (0x1ul << DPWM_STS_FULL_Pos)                      /*!< DPWM STS: FULL Mask                    */
S
S#define DPWM_STS_EMPTY_Pos               (1)                                               /*!< DPWM STS: EMPTY Position               */
S#define DPWM_STS_EMPTY_Msk               (0x1ul << DPWM_STS_EMPTY_Pos)                     /*!< DPWM STS: EMPTY Mask                   */
S
S#define DPWM_DMACTL_DMAEN_Pos            (0)                                               /*!< DPWM DMACTL: DMAEN Position            */
S#define DPWM_DMACTL_DMAEN_Msk            (0x1ul << DPWM_DMACTL_DMAEN_Pos)                  /*!< DPWM DMACTL: DMAEN Mask                */
S
S#define DPWM_DATA_INDATA_Pos             (0)                                               /*!< DPWM DATA: INDATA Position             */
S#define DPWM_DATA_INDATA_Msk             (0xfffful << DPWM_DATA_INDATA_Pos)                /*!< DPWM DATA: INDATA Mask                 */
S
S#define DPWM_ZOHDIV_ZOHDIV_Pos           (0)                                               /*!< DPWM ZOHDIV: ZOHDIV Position           */
S#define DPWM_ZOHDIV_ZOHDIV_Msk           (0xfful << DPWM_ZOHDIV_ZOHDIV_Pos)                /*!< DPWM ZOHDIV: ZOHDIV Mask               */
S
S/**@}*/ /* DPWM_CONST */
S/**@}*/ /* end of DPWM register group */
S
S
S/*---------------------- Flash Memory Controller -------------------------*/
S/**
S    @addtogroup FMC Flash Memory Controller(FMC)
S    Memory Mapped Structure for FMC Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * ISPCTL
S     * ===================================================================================================
S     * Offset: 0x00  ISP Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPEN     |ISP Enable
S     * |        |          |0 = Disable ISP function
S     * |        |          |1 = Enable ISP function
S     * |[1]     |BS        |Boot Select
S     * |        |          |0 = APROM
S     * |        |          |1 = LDROM
S     * |        |          |Modify this bit to select which ROM next boot is to occur.
S     * |        |          |This bit also functions as MCU boot status flag, which can be used to check where MCU booted from.
S     * |        |          |This bit is initialized after power-on reset with the inverse of CBS in Config0; It is not reset for any other reset event.
S     * |[4]     |CFGUEN    |CONFIG Update Enable
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |        |          |When enabled, ISP functions can access the CONFIG address space and modify device configuration area. 
S     * |[5]     |LDUEN     |LDROM Update Enable
S     * |        |          |LDROM update enable bit.
S     * |        |          |0 = LDROM cannot be updated
S     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
S     * |[6]     |ISPFF     |ISP Fail Flag
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself.
S     * |        |          |(2) LDROM writes to itself.
S     * |        |          |(3) Destination address is illegal, such as over an available range.
S     * |        |          |Write 1 to clear.
S     * |[7]     |SWRST     |Software Reset
S     * |        |          |Writing 1 to this bit will initiate a software reset. It is cleared by hardware after reset.
S */
S    __IO uint32_t ISPCTL;                
S
S    /**
S     * ISPADDR
S     * ===================================================================================================
S     * Offset: 0x04  ISP Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |ISPADDR   |ISP Address Register
S     * |        |          |This is the memory address register that a subsequent ISP command will access.
S     * |        |          |ISP operation are carried out on 32bit words only, consequently ISPARD[1:0] must be 00b for correct ISP operation.
S */
S    __IO uint32_t ISPADDR;               
S
S    /**
S     * ISPDAT
S     * ===================================================================================================
S     * Offset: 0x08  ISP Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |ISPDAT    |ISP Data Register
S     * |        |          |Write data to this register before an ISP program operation.
S     * |        |          |Read data from this register after an ISP read operation
S */
S    __IO uint32_t ISPDAT;                
S
S    /**
S     * ISPCMD
S     * ===================================================================================================
S     * Offset: 0x0C  ISP Command Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:5]   |CMD       |ISP Command
S     * |        |          |Operation Mode : CMD
S     * |        |          |Standby : 0x3X
S     * |        |          |Read : 0x00
S     * |        |          |Program : 0x21
S     * |        |          |Page Erase : 0x22
S     * |        |          |Read CID : 0x0B
S     * |        |          |Read DID : 0x0C
S */
S    __IO uint32_t ISPCMD;                
S
S    /**
S     * ISPTRG
S     * ===================================================================================================
S     * Offset: 0x10  ISP Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPGO     |ISP Start Trigger
S     * |        |          |Write 1 to start ISP operation.
S     * |        |          |This will be cleared to 0 by hardware automatically when ISP operation is finished.
S     * |        |          |0 = ISP operation is finished
S     * |        |          |1 = ISP is on going
S     * |        |          |After triggering an ISP function M0 instruction pipeline should be flushed with a ISB instruction to guarantee data integrity.
S     * |        |          |This is a protected register, user must first follow the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL)) to gain access.
S */
S    __IO uint32_t ISPTRG;                
S
S    /**
S     * DFBA
S     * ===================================================================================================
S     * Offset: 0x14  Data Flash Base Address
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |DFBA      |Data Flash Base Address
S     * |        |          |This register reports the data flash starting address. It is a read only register.
S     * |        |          |Data flash size is defined by user's configuration; register content is loaded from Config1 when chip is reset.
S */
S    __I  uint32_t DFBA;                  
S
S} FMC_T;
S
S/**
S    @addtogroup FMC_CONST FMC Bit Field Definition
S    Constant Definitions for FMC Controller
S@{ */
S
S#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC ISPCTL: ISPEN Position             */
S#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC ISPCTL: ISPEN Mask                 */
S
S#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC ISPCTL: BS Position                */
S#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC ISPCTL: BS Mask                    */
S
S#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC ISPCTL: CFGUEN Position            */
S#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC ISPCTL: CFGUEN Mask                */
S
S#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC ISPCTL: LDUEN Position             */
S#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC ISPCTL: LDUEN Mask                 */
S
S#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC ISPCTL: ISPFF Position             */
S#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC ISPCTL: ISPFF Mask                 */
S
S#define FMC_ISPCTL_SWRST_Pos             (7)                                               /*!< FMC ISPCTL: SWRST Position             */
S#define FMC_ISPCTL_SWRST_Msk             (0x1ul << FMC_ISPCTL_SWRST_Pos)                   /*!< FMC ISPCTL: SWRST Mask                 */
S
S#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC ISPADDR: ISPADDR Position          */
S#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC ISPADDR: ISPADDR Mask              */
S
S#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC ISPDAT: ISPDAT Position            */
S#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC ISPDAT: ISPDAT Mask                */
S
S#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC ISPCMD: CMD Position               */
S#define FMC_ISPCMD_CMD_Msk               (0x3ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC ISPCMD: CMD Mask                   */
S
S#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC ISPTRG: ISPGO Position             */
S#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC ISPTRG: ISPGO Mask                 */
S
S#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC DFBA: DFBA Position                */
S#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC DFBA: DFBA Mask                    */
S
S/**@}*/ /* FMC_CONST */
S/**@}*/ /* end of FMC register group */
S
S
S/*---------------------- General Purpose Input/Output Controller -------------------------*/
S/**
S    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
S    Memory Mapped Structure for GPIO Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * MODE
S     * ===================================================================================================
S     * Offset: 0x00  GPIO Pin I/O Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |MODE0     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[2:3]   |MODE1     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[4:5]   |MODE2     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[6:7]   |MODE3     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[8:9]   |MODE4     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[10:11] |MODE5     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[12:13] |MODE6     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[14:15] |MODE7     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[16:17] |MODE8     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[18:19] |MODE9     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[20:21] |MODE10    |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[22:23] |MODE11    |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[24:25] |MODE12    |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[26:27] |MODE13    |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[28:29] |MODE14    |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |[30:31] |MODE15    |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O type of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in INPUT mode.
S     * |        |          |01 = GPIO port [n] pin is in OUTPUT mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-Drain mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S */
S    __IO uint32_t MODE;               
S
S    /**
S     * DINOFF
S     * ===================================================================================================
S     * Offset: 0x04  GPIO Pin Digital Input Disable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[16]    |DINOFF16  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[17]    |DINOFF17  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[18]    |DINOFF18  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[19]    |DINOFF19  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[20]    |DINOFF20  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[21]    |DINOFF21  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[22]    |DINOFF22  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[23]    |DINOFF23  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[24]    |DINOFF24  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[25]    |DINOFF25  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[26]    |DINOFF26  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[27]    |DINOFF27  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[28]    |DINOFF28  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[29]    |DINOFF29  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[30]    |DINOFF30  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S     * |[31]    |DINOFF31  |GPIOx Pin[n] OFF Digital Input Path Enable
S     * |        |          |0 = Enable IO digital input path (Default)
S     * |        |          |1 = Disable IO digital input path (low leakage mode)
S */
S    __IO uint32_t DINOFF;             
S
S    /**
S     * DOUT
S     * ===================================================================================================
S     * Offset: 0x08  GPIO Data Output Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DOUT0     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[1]     |DOUT1     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[2]     |DOUT2     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[3]     |DOUT3     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[4]     |DOUT4     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[5]     |DOUT5     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[6]     |DOUT6     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[7]     |DOUT7     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[8]     |DOUT8     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[9]     |DOUT9     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[10]    |DOUT10    |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[11]    |DOUT11    |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[12]    |DOUT12    |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[13]    |DOUT13    |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[14]    |DOUT14    |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S     * |[15]    |DOUT15    |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set.
S     * |        |          |1 = GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set.
S */
S    __IO uint32_t DOUT;               
S
S    /**
S     * DATMSK
S     * ===================================================================================================
S     * Offset: 0x0C  GPIO Data Output Write Mask
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DATMSK0   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[1]     |DATMSK1   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[2]     |DATMSK2   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[3]     |DATMSK3   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[4]     |DATMSK4   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[5]     |DATMSK5   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[6]     |DATMSK6   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[7]     |DATMSK7   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[8]     |DATMSK8   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[9]     |DATMSK9   |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[10]    |DATMSK10  |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[11]    |DATMSK11  |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[12]    |DATMSK12  |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[13]    |DATMSK13  |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[14]    |DATMSK14  |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S     * |[15]    |DATMSK15  |Port [A/B] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of Px_DOUT bit[n].
S     * |        |          |When set the DATMSK bit[n] to "1", the corresponding DOUTn bit is write-protected.
S     * |        |          |0 = The corresponding Px_DOUT[n] bit can be updated
S     * |        |          |1 = The corresponding Px_DOUT[n] bit is read only
S */
S    __IO uint32_t DATMSK;             
S
S    /**
S     * PIN
S     * ===================================================================================================
S     * Offset: 0x10  GPIO Pin Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PIN0      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[1]     |PIN1      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[2]     |PIN2      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[3]     |PIN3      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[4]     |PIN4      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[5]     |PIN5      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[6]     |PIN6      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[7]     |PIN7      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[8]     |PIN8      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[9]     |PIN9      |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[10]    |PIN10     |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[11]    |PIN11     |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[12]    |PIN12     |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[13]    |PIN13     |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[14]    |PIN14     |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S     * |[15]    |PIN15     |Port [A/B] Pin Values
S     * |        |          |The value read from each of these bit reflects the actual status of the respective GPIO pin
S */
S    __I  uint32_t PIN;                
S
S    /**
S     * DBEN
S     * ===================================================================================================
S     * Offset: 0x14  GPIO De-bounce Enable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DBEN0     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[1]     |DBEN1     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[2]     |DBEN2     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[3]     |DBEN3     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[4]     |DBEN4     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[5]     |DBEN5     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[6]     |DBEN6     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[7]     |DBEN7     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[8]     |DBEN8     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[9]     |DBEN9     |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[10]    |DBEN10    |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[11]    |DBEN11    |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[12]    |DBEN12    |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[13]    |DBEN13    |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[14]    |DBEN14    |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S     * |[15]    |DBEN15    |Port [A/B] Input Signal De-bounce Enable
S     * |        |          |DBEN[n]used to enable the de-bounce function for each corresponding bit.
S     * |        |          |For an edge triggered interrupt to be generated, input signal must be valid for two consecutive de-bounce periods.
S     * |        |          |The de-bounce time is controlled by the GPIO_DBCTL register.
S     * |        |          |The DBEN[n] is used for "edge-trigger" interrupt only; it is ignored for "level trigger" interrupt
S     * |        |          |0 = The bit[n] de-bounce function is disabled
S     * |        |          |1 = The bit[n] de-bounce function is enabled 
S */
S    __IO uint32_t DBEN;               
S
S    /**
S     * INTTYPE
S     * ===================================================================================================
S     * Offset: 0x18  GPIO Interrupt Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TYPE0     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[1]     |TYPE1     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[2]     |TYPE2     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[3]     |TYPE3     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[4]     |TYPE4     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[5]     |TYPE5     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[6]     |TYPE6     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[7]     |TYPE7     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[8]     |TYPE8     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[9]     |TYPE9     |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[10]    |TYPE10    |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[11]    |TYPE11    |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[12]    |TYPE12    |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[13]    |TYPE13    |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[14]    |TYPE14    |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S     * |[15]    |TYPE15    |Port [A/B] Edge Or Level Detection Interrupt Control
S     * |        |          |TYPE[n] used to control whether the interrupt mode is level triggered or edge triggered.
S     * |        |          |If the interrupt mode is edge triggered, edge de-bounce is controlled by the DBEN register.
S     * |        |          |If the interrupt mode is level triggered, the input source is sampled each clock to generate an interrupt.
S     * |        |          |0 = Edge triggered interrupt
S     * |        |          |1 = Level triggered interrupt
S     * |        |          |If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register.
S     * |        |          |If both levels are set no interrupt will occur.
S */
S    __IO uint32_t INTTYPE;            
S
S    /**
S     * INTEN
S     * ===================================================================================================
S     * Offset: 0x1C  GPIO Interrupt Enable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FLIEN0    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[1]     |FLIEN1    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[2]     |FLIEN2    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[3]     |FLIEN3    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[4]     |FLIEN4    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[5]     |FLIEN5    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[6]     |FLIEN6    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[7]     |FLIEN7    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[8]     |FLIEN8    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[9]     |FLIEN9    |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[10]    |FLIEN10   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[11]    |FLIEN11   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[12]    |FLIEN12   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[13]    |FLIEN13   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[14]    |FLIEN14   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[15]    |FLIEN15   |Port [A/B] Interrupt Enable by Input Falling Edge or Input Level Low
S     * |        |          |FLIEN[n] is used to enable the falling/low interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "low" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "high-to-low" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for low-level or high-to-low interrupt
S     * |        |          |1 = Enable GPIOx[n] for low-level or high-to-low interrupt 
S     * |[16]    |RHIEN0    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[17]    |RHIEN1    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[18]    |RHIEN2    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[19]    |RHIEN3    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[20]    |RHIEN4    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[21]    |RHIEN5    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[22]    |RHIEN6    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[23]    |RHIEN7    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[24]    |RHIEN8    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[25]    |RHIEN9    |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[26]    |RHIEN10   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[27]    |RHIEN11   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[28]    |RHIEN12   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[29]    |RHIEN13   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[30]    |RHIEN14   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S     * |[31]    |RHIEN15   |Port [A/B] Interrupt Enable by Input Rising Edge or Input Level High
S     * |        |          |RHIEN[n] is used to enable the rising/high interrupt for each of the corresponding GPIO pins.
S     * |        |          |It also enables the pin wakeup function.
S     * |        |          |If the interrupt is configured in level trigger mode, a level "high" will generate an interrupt.
S     * |        |          |If the interrupt is configured in edge trigger mode, a state change from "low-to-high" will generate an interrupt.
S     * |        |          |GPB.0 and GPB.1 trigger individual IRQ vectors (IRQ2/IRQ3) while remaining GPIO trigger a single interrupt vector IRQ4.
S     * |        |          |0 = Disable GPIOx[n] for level-high or low-to-high interrupt.
S     * |        |          |1 = Enable GPIOx[n] for level-high or low-to-high interrupt 
S */
S    __IO uint32_t INTEN;              
S
S    /**
S     * INTSRC
S     * ===================================================================================================
S     * Offset: 0x20  GPIO Interrupt Trigger Source Indicator
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INTSRC0   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[1]     |INTSRC1   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[2]     |INTSRC2   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[3]     |INTSRC3   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[4]     |INTSRC4   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[5]     |INTSRC5   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[6]     |INTSRC6   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[7]     |INTSRC7   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[8]     |INTSRC8   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[9]     |INTSRC9   |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[10]    |INTSRC10  |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[11]    |INTSRC11  |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[12]    |INTSRC12  |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[13]    |INTSRC13  |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[14]    |INTSRC14  |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S     * |[15]    |INTSRC15  |Port [A/B] Interrupt Trigger Source Indicator
S     * |        |          |Read :
S     * |        |          |1 = Indicates GPIOx[n] generated an interrupt
S     * |        |          |0 = No interrupt from GPIOx[n]
S     * |        |          |Write :
S     * |        |          |1 = Clear the corresponding pending interrupt.
S     * |        |          |0 = No action
S */
S    __IO uint32_t INTSRC;                     
S
S} GPIO_T;
S
S
Stypedef struct { 
S    /**
S     * GPIO_DBCTL
S     * ===================================================================================================
S     * Offset: 0x000  Interrupt De-bounce Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |DBCLKSEL  |De-bounce Sampling Cycle Selection.
S     * |        |          |For edge level interrupt GPIO state is sampled every 2^(DBCLKSEL) de-bounce clocks.
S     * |        |          |For example if DBCLKSRC = 6, then interrupt is sampled every 2^6 = 64 de-bounce clocks.
S     * |        |          |If DBCLKSRC is 16KHz oscillator this would be a 64ms de-bounce.
S     * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Select
S     * |        |          |0 = De-bounce counter clock source is HCLK
S     * |        |          |1 = De-bounce counter clock source is the internal 16 kHz clock
S     * |[5]     |ICLKON    |Interrupt Clock On Mode
S     * |        |          |Set this bit "0" will gate the clock to the interrupt generation circuit if the GPIOx[n] interrupt is disabled.
S     * |        |          |0 = disable the clock if the GPIOx[n] interrupt is disabled
S     * |        |          |1 = Interrupt generation clock always active.
S */
S    __IO uint32_t DBCTL;  
S} GPIO_DB_T; 
S
S/**
S    @addtogroup GPIO_CONST GPIO Bit Field Definition
S    Constant Definitions for GPIO Controller
S@{ */
S
S#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO MODE: MODE0 Position              */
S#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO MODE: MODE0 Mask                  */
S
S#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO MODE: MODE1 Position              */
S#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO MODE: MODE1 Mask                  */
S
S#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO MODE: MODE2 Position              */
S#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO MODE: MODE2 Mask                  */
S
S#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO MODE: MODE3 Position              */
S#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO MODE: MODE3 Mask                  */
S
S#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO MODE: MODE4 Position              */
S#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO MODE: MODE4 Mask                  */
S
S#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO MODE: MODE5 Position              */
S#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO MODE: MODE5 Mask                  */
S
S#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO MODE: MODE6 Position              */
S#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO MODE: MODE6 Mask                  */
S
S#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO MODE: MODE7 Position              */
S#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO MODE: MODE7 Mask                  */
S
S#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO MODE: MODE8 Position              */
S#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO MODE: MODE8 Mask                  */
S
S#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO MODE: MODE9 Position              */
S#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO MODE: MODE9 Mask                  */
S
S#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO MODE: MODE10 Position             */
S#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO MODE: MODE10 Mask                 */
S
S#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO MODE: MODE11 Position             */
S#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO MODE: MODE11 Mask                 */
S
S#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO MODE: MODE12 Position             */
S#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO MODE: MODE12 Mask                 */
S
S#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO MODE: MODE13 Position             */
S#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO MODE: MODE13 Mask                 */
S
S#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO MODE: MODE14 Position             */
S#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO MODE: MODE14 Mask                 */
S
S#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO MODE: MODE15 Position             */
S#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO MODE: MODE15 Mask                 */
S
S#define GPIO_DINOFF_DINOFF16_Pos         (16)                                              /*!< GPIO DINOFF: DINOFF16 Position         */
S#define GPIO_DINOFF_DINOFF16_Msk         (0x1ul << GPIO_DINOFF_DINOFF16_Pos)               /*!< GPIO DINOFF: DINOFF16 Mask             */
S
S#define GPIO_DINOFF_DINOFF17_Pos         (17)                                              /*!< GPIO DINOFF: DINOFF17 Position         */
S#define GPIO_DINOFF_DINOFF17_Msk         (0x1ul << GPIO_DINOFF_DINOFF17_Pos)               /*!< GPIO DINOFF: DINOFF17 Mask             */
S
S#define GPIO_DINOFF_DINOFF18_Pos         (18)                                              /*!< GPIO DINOFF: DINOFF18 Position         */
S#define GPIO_DINOFF_DINOFF18_Msk         (0x1ul << GPIO_DINOFF_DINOFF18_Pos)               /*!< GPIO DINOFF: DINOFF18 Mask             */
S
S#define GPIO_DINOFF_DINOFF19_Pos         (19)                                              /*!< GPIO DINOFF: DINOFF19 Position         */
S#define GPIO_DINOFF_DINOFF19_Msk         (0x1ul << GPIO_DINOFF_DINOFF19_Pos)               /*!< GPIO DINOFF: DINOFF19 Mask             */
S
S#define GPIO_DINOFF_DINOFF20_Pos         (20)                                              /*!< GPIO DINOFF: DINOFF20 Position         */
S#define GPIO_DINOFF_DINOFF20_Msk         (0x1ul << GPIO_DINOFF_DINOFF20_Pos)               /*!< GPIO DINOFF: DINOFF20 Mask             */
S
S#define GPIO_DINOFF_DINOFF21_Pos         (21)                                              /*!< GPIO DINOFF: DINOFF21 Position         */
S#define GPIO_DINOFF_DINOFF21_Msk         (0x1ul << GPIO_DINOFF_DINOFF21_Pos)               /*!< GPIO DINOFF: DINOFF21 Mask             */
S
S#define GPIO_DINOFF_DINOFF22_Pos         (22)                                              /*!< GPIO DINOFF: DINOFF22 Position         */
S#define GPIO_DINOFF_DINOFF22_Msk         (0x1ul << GPIO_DINOFF_DINOFF22_Pos)               /*!< GPIO DINOFF: DINOFF22 Mask             */
S
S#define GPIO_DINOFF_DINOFF23_Pos         (23)                                              /*!< GPIO DINOFF: DINOFF23 Position         */
S#define GPIO_DINOFF_DINOFF23_Msk         (0x1ul << GPIO_DINOFF_DINOFF23_Pos)               /*!< GPIO DINOFF: DINOFF23 Mask             */
S
S#define GPIO_DINOFF_DINOFF24_Pos         (24)                                              /*!< GPIO DINOFF: DINOFF24 Position         */
S#define GPIO_DINOFF_DINOFF24_Msk         (0x1ul << GPIO_DINOFF_DINOFF24_Pos)               /*!< GPIO DINOFF: DINOFF24 Mask             */
S
S#define GPIO_DINOFF_DINOFF25_Pos         (25)                                              /*!< GPIO DINOFF: DINOFF25 Position         */
S#define GPIO_DINOFF_DINOFF25_Msk         (0x1ul << GPIO_DINOFF_DINOFF25_Pos)               /*!< GPIO DINOFF: DINOFF25 Mask             */
S
S#define GPIO_DINOFF_DINOFF26_Pos         (26)                                              /*!< GPIO DINOFF: DINOFF26 Position         */
S#define GPIO_DINOFF_DINOFF26_Msk         (0x1ul << GPIO_DINOFF_DINOFF26_Pos)               /*!< GPIO DINOFF: DINOFF26 Mask             */
S
S#define GPIO_DINOFF_DINOFF27_Pos         (27)                                              /*!< GPIO DINOFF: DINOFF27 Position         */
S#define GPIO_DINOFF_DINOFF27_Msk         (0x1ul << GPIO_DINOFF_DINOFF27_Pos)               /*!< GPIO DINOFF: DINOFF27 Mask             */
S
S#define GPIO_DINOFF_DINOFF28_Pos         (28)                                              /*!< GPIO DINOFF: DINOFF28 Position         */
S#define GPIO_DINOFF_DINOFF28_Msk         (0x1ul << GPIO_DINOFF_DINOFF28_Pos)               /*!< GPIO DINOFF: DINOFF28 Mask             */
S
S#define GPIO_DINOFF_DINOFF29_Pos         (29)                                              /*!< GPIO DINOFF: DINOFF29 Position         */
S#define GPIO_DINOFF_DINOFF29_Msk         (0x1ul << GPIO_DINOFF_DINOFF29_Pos)               /*!< GPIO DINOFF: DINOFF29 Mask             */
S
S#define GPIO_DINOFF_DINOFF30_Pos         (30)                                              /*!< GPIO DINOFF: DINOFF30 Position         */
S#define GPIO_DINOFF_DINOFF30_Msk         (0x1ul << GPIO_DINOFF_DINOFF30_Pos)               /*!< GPIO DINOFF: DINOFF30 Mask             */
S
S#define GPIO_DINOFF_DINOFF31_Pos         (31)                                              /*!< GPIO DINOFF: DINOFF31 Position         */
S#define GPIO_DINOFF_DINOFF31_Msk         (0x1ul << GPIO_DINOFF_DINOFF31_Pos)               /*!< GPIO DINOFF: DINOFF31 Mask             */
S
S#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO DOUT: DOUT0 Position              */
S#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO DOUT: DOUT0 Mask                  */
S
S#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO DOUT: DOUT1 Position              */
S#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO DOUT: DOUT1 Mask                  */
S
S#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO DOUT: DOUT2 Position              */
S#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO DOUT: DOUT2 Mask                  */
S
S#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO DOUT: DOUT3 Position              */
S#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO DOUT: DOUT3 Mask                  */
S
S#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO DOUT: DOUT4 Position              */
S#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO DOUT: DOUT4 Mask                  */
S
S#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO DOUT: DOUT5 Position              */
S#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO DOUT: DOUT5 Mask                  */
S
S#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO DOUT: DOUT6 Position              */
S#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO DOUT: DOUT6 Mask                  */
S
S#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO DOUT: DOUT7 Position              */
S#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO DOUT: DOUT7 Mask                  */
S
S#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO DOUT: DOUT8 Position              */
S#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO DOUT: DOUT8 Mask                  */
S
S#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO DOUT: DOUT9 Position              */
S#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO DOUT: DOUT9 Mask                  */
S
S#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO DOUT: DOUT10 Position             */
S#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO DOUT: DOUT10 Mask                 */
S
S#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO DOUT: DOUT11 Position             */
S#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO DOUT: DOUT11 Mask                 */
S
S#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO DOUT: DOUT12 Position             */
S#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO DOUT: DOUT12 Mask                 */
S
S#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO DOUT: DOUT13 Position             */
S#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO DOUT: DOUT13 Mask                 */
S
S#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO DOUT: DOUT14 Position             */
S#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO DOUT: DOUT14 Mask                 */
S
S#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO DOUT: DOUT15 Position             */
S#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO DOUT: DOUT15 Mask                 */
S
S#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO DATMSK: DATMSK0 Position          */
S#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO DATMSK: DATMSK0 Mask              */
S
S#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO DATMSK: DATMSK1 Position          */
S#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO DATMSK: DATMSK1 Mask              */
S
S#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO DATMSK: DATMSK2 Position          */
S#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO DATMSK: DATMSK2 Mask              */
S
S#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO DATMSK: DATMSK3 Position          */
S#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO DATMSK: DATMSK3 Mask              */
S
S#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO DATMSK: DATMSK4 Position          */
S#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO DATMSK: DATMSK4 Mask              */
S
S#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO DATMSK: DATMSK5 Position          */
S#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO DATMSK: DATMSK5 Mask              */
S
S#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO DATMSK: DATMSK6 Position          */
S#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO DATMSK: DATMSK6 Mask              */
S
S#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO DATMSK: DATMSK7 Position          */
S#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO DATMSK: DATMSK7 Mask              */
S
S#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO DATMSK: DATMSK8 Position          */
S#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO DATMSK: DATMSK8 Mask              */
S
S#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO DATMSK: DATMSK9 Position          */
S#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO DATMSK: DATMSK9 Mask              */
S
S#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO DATMSK: DATMSK10 Position         */
S#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO DATMSK: DATMSK10 Mask             */
S
S#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO DATMSK: DATMSK11 Position         */
S#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO DATMSK: DATMSK11 Mask             */
S
S#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO DATMSK: DATMSK12 Position         */
S#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO DATMSK: DATMSK12 Mask             */
S
S#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO DATMSK: DATMSK13 Position         */
S#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO DATMSK: DATMSK13 Mask             */
S
S#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO DATMSK: DATMSK14 Position         */
S#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO DATMSK: DATMSK14 Mask             */
S
S#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO DATMSK: DATMSK15 Position         */
S#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO DATMSK: DATMSK15 Mask             */
S
S#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO PIN: PIN0 Position                */
S#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO PIN: PIN0 Mask                    */
S
S#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO PIN: PIN1 Position                */
S#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO PIN: PIN1 Mask                    */
S
S#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO PIN: PIN2 Position                */
S#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO PIN: PIN2 Mask                    */
S
S#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO PIN: PIN3 Position                */
S#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO PIN: PIN3 Mask                    */
S
S#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO PIN: PIN4 Position                */
S#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO PIN: PIN4 Mask                    */
S
S#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO PIN: PIN5 Position                */
S#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO PIN: PIN5 Mask                    */
S
S#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO PIN: PIN6 Position                */
S#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO PIN: PIN6 Mask                    */
S
S#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO PIN: PIN7 Position                */
S#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO PIN: PIN7 Mask                    */
S
S#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO PIN: PIN8 Position                */
S#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO PIN: PIN8 Mask                    */
S
S#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO PIN: PIN9 Position                */
S#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO PIN: PIN9 Mask                    */
S
S#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO PIN: PIN10 Position               */
S#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO PIN: PIN10 Mask                   */
S
S#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO PIN: PIN11 Position               */
S#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO PIN: PIN11 Mask                   */
S
S#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO PIN: PIN12 Position               */
S#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO PIN: PIN12 Mask                   */
S
S#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO PIN: PIN13 Position               */
S#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO PIN: PIN13 Mask                   */
S
S#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO PIN: PIN14 Position               */
S#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO PIN: PIN14 Mask                   */
S
S#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO PIN: PIN15 Position               */
S#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO PIN: PIN15 Mask                   */
S
S#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO DBEN: DBEN0 Position              */
S#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO DBEN: DBEN0 Mask                  */
S
S#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO DBEN: DBEN1 Position              */
S#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO DBEN: DBEN1 Mask                  */
S
S#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO DBEN: DBEN2 Position              */
S#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO DBEN: DBEN2 Mask                  */
S
S#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO DBEN: DBEN3 Position              */
S#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO DBEN: DBEN3 Mask                  */
S
S#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO DBEN: DBEN4 Position              */
S#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO DBEN: DBEN4 Mask                  */
S
S#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO DBEN: DBEN5 Position              */
S#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO DBEN: DBEN5 Mask                  */
S
S#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO DBEN: DBEN6 Position              */
S#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO DBEN: DBEN6 Mask                  */
S
S#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO DBEN: DBEN7 Position              */
S#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO DBEN: DBEN7 Mask                  */
S
S#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO DBEN: DBEN8 Position              */
S#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO DBEN: DBEN8 Mask                  */
S
S#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO DBEN: DBEN9 Position              */
S#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO DBEN: DBEN9 Mask                  */
S
S#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO DBEN: DBEN10 Position             */
S#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO DBEN: DBEN10 Mask                 */
S
S#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO DBEN: DBEN11 Position             */
S#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO DBEN: DBEN11 Mask                 */
S
S#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO DBEN: DBEN12 Position             */
S#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO DBEN: DBEN12 Mask                 */
S
S#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO DBEN: DBEN13 Position             */
S#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO DBEN: DBEN13 Mask                 */
S
S#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO DBEN: DBEN14 Position             */
S#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO DBEN: DBEN14 Mask                 */
S
S#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO DBEN: DBEN15 Position             */
S#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO DBEN: DBEN15 Mask                 */
S
S#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO INTTYPE: TYPE0 Position           */
S#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO INTTYPE: TYPE0 Mask               */
S
S#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO INTTYPE: TYPE1 Position           */
S#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO INTTYPE: TYPE1 Mask               */
S
S#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO INTTYPE: TYPE2 Position           */
S#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO INTTYPE: TYPE2 Mask               */
S
S#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO INTTYPE: TYPE3 Position           */
S#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO INTTYPE: TYPE3 Mask               */
S
S#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO INTTYPE: TYPE4 Position           */
S#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO INTTYPE: TYPE4 Mask               */
S
S#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO INTTYPE: TYPE5 Position           */
S#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO INTTYPE: TYPE5 Mask               */
S
S#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO INTTYPE: TYPE6 Position           */
S#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO INTTYPE: TYPE6 Mask               */
S
S#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO INTTYPE: TYPE7 Position           */
S#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO INTTYPE: TYPE7 Mask               */
S
S#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO INTTYPE: TYPE8 Position           */
S#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO INTTYPE: TYPE8 Mask               */
S
S#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO INTTYPE: TYPE9 Position           */
S#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO INTTYPE: TYPE9 Mask               */
S
S#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO INTTYPE: TYPE10 Position          */
S#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO INTTYPE: TYPE10 Mask              */
S
S#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO INTTYPE: TYPE11 Position          */
S#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO INTTYPE: TYPE11 Mask              */
S
S#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO INTTYPE: TYPE12 Position          */
S#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO INTTYPE: TYPE12 Mask              */
S
S#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO INTTYPE: TYPE13 Position          */
S#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO INTTYPE: TYPE13 Mask              */
S
S#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO INTTYPE: TYPE14 Position          */
S#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO INTTYPE: TYPE14 Mask              */
S
S#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO INTTYPE: TYPE15 Position          */
S#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO INTTYPE: TYPE15 Mask              */
S
S#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO INTEN: FLIEN0 Position            */
S#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO INTEN: FLIEN0 Mask                */
S
S#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO INTEN: FLIEN1 Position            */
S#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO INTEN: FLIEN1 Mask                */
S
S#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO INTEN: FLIEN2 Position            */
S#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO INTEN: FLIEN2 Mask                */
S
S#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO INTEN: FLIEN3 Position            */
S#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO INTEN: FLIEN3 Mask                */
S
S#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO INTEN: FLIEN4 Position            */
S#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO INTEN: FLIEN4 Mask                */
S
S#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO INTEN: FLIEN5 Position            */
S#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO INTEN: FLIEN5 Mask                */
S
S#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO INTEN: FLIEN6 Position            */
S#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO INTEN: FLIEN6 Mask                */
S
S#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO INTEN: FLIEN7 Position            */
S#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO INTEN: FLIEN7 Mask                */
S
S#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO INTEN: FLIEN8 Position            */
S#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO INTEN: FLIEN8 Mask                */
S
S#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO INTEN: FLIEN9 Position            */
S#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO INTEN: FLIEN9 Mask                */
S
S#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO INTEN: FLIEN10 Position           */
S#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO INTEN: FLIEN10 Mask               */
S
S#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO INTEN: FLIEN11 Position           */
S#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO INTEN: FLIEN11 Mask               */
S
S#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO INTEN: FLIEN12 Position           */
S#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO INTEN: FLIEN12 Mask               */
S
S#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO INTEN: FLIEN13 Position           */
S#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO INTEN: FLIEN13 Mask               */
S
S#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO INTEN: FLIEN14 Position           */
S#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO INTEN: FLIEN14 Mask               */
S
S#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO INTEN: FLIEN15 Position           */
S#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO INTEN: FLIEN15 Mask               */
S
S#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO INTEN: RHIEN0 Position            */
S#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO INTEN: RHIEN0 Mask                */
S
S#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO INTEN: RHIEN1 Position            */
S#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO INTEN: RHIEN1 Mask                */
S
S#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO INTEN: RHIEN2 Position            */
S#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO INTEN: RHIEN2 Mask                */
S
S#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO INTEN: RHIEN3 Position            */
S#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO INTEN: RHIEN3 Mask                */
S
S#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO INTEN: RHIEN4 Position            */
S#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO INTEN: RHIEN4 Mask                */
S
S#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO INTEN: RHIEN5 Position            */
S#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO INTEN: RHIEN5 Mask                */
S
S#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO INTEN: RHIEN6 Position            */
S#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO INTEN: RHIEN6 Mask                */
S
S#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO INTEN: RHIEN7 Position            */
S#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO INTEN: RHIEN7 Mask                */
S
S#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO INTEN: RHIEN8 Position            */
S#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO INTEN: RHIEN8 Mask                */
S
S#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO INTEN: RHIEN9 Position            */
S#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO INTEN: RHIEN9 Mask                */
S
S#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO INTEN: RHIEN10 Position           */
S#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO INTEN: RHIEN10 Mask               */
S
S#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO INTEN: RHIEN11 Position           */
S#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO INTEN: RHIEN11 Mask               */
S
S#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO INTEN: RHIEN12 Position           */
S#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO INTEN: RHIEN12 Mask               */
S
S#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO INTEN: RHIEN13 Position           */
S#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO INTEN: RHIEN13 Mask               */
S
S#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO INTEN: RHIEN14 Position           */
S#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO INTEN: RHIEN14 Mask               */
S
S#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO INTEN: RHIEN15 Position           */
S#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO INTEN: RHIEN15 Mask               */
S
S#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO INTSRC: INTSRC0 Position          */
S#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO INTSRC: INTSRC0 Mask              */
S
S#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO INTSRC: INTSRC1 Position          */
S#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO INTSRC: INTSRC1 Mask              */
S
S#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO INTSRC: INTSRC2 Position          */
S#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO INTSRC: INTSRC2 Mask              */
S
S#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO INTSRC: INTSRC3 Position          */
S#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO INTSRC: INTSRC3 Mask              */
S
S#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO INTSRC: INTSRC4 Position          */
S#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO INTSRC: INTSRC4 Mask              */
S
S#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO INTSRC: INTSRC5 Position          */
S#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO INTSRC: INTSRC5 Mask              */
S
S#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO INTSRC: INTSRC6 Position          */
S#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO INTSRC: INTSRC6 Mask              */
S
S#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO INTSRC: INTSRC7 Position          */
S#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO INTSRC: INTSRC7 Mask              */
S
S#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO INTSRC: INTSRC8 Position          */
S#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO INTSRC: INTSRC8 Mask              */
S
S#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO INTSRC: INTSRC9 Position          */
S#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO INTSRC: INTSRC9 Mask              */
S
S#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO INTSRC: INTSRC10 Position         */
S#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO INTSRC: INTSRC10 Mask             */
S
S#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO INTSRC: INTSRC11 Position         */
S#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO INTSRC: INTSRC11 Mask             */
S
S#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO INTSRC: INTSRC12 Position         */
S#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO INTSRC: INTSRC12 Mask             */
S
S#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO INTSRC: INTSRC13 Position         */
S#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO INTSRC: INTSRC13 Mask             */
S
S#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO INTSRC: INTSRC14 Position         */
S#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO INTSRC: INTSRC14 Mask             */
S
S#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO INTSRC: INTSRC15 Position         */
S#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO INTSRC: INTSRC15 Mask             */
S
S#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO MODE: MODE0 Position              */
S#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO MODE: MODE0 Mask                  */
S
S#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO MODE: MODE1 Position              */
S#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO MODE: MODE1 Mask                  */
S
S#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO MODE: MODE2 Position              */
S#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO MODE: MODE2 Mask                  */
S
S#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO MODE: MODE3 Position              */
S#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO MODE: MODE3 Mask                  */
S
S#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO MODE: MODE4 Position              */
S#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO MODE: MODE4 Mask                  */
S
S#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO MODE: MODE5 Position              */
S#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO MODE: MODE5 Mask                  */
S
S#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO MODE: MODE6 Position              */
S#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO MODE: MODE6 Mask                  */
S
S#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO MODE: MODE7 Position              */
S#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO MODE: MODE7 Mask                  */
S
S#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO MODE: MODE8 Position              */
S#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO MODE: MODE8 Mask                  */
S
S#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO MODE: MODE9 Position              */
S#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO MODE: MODE9 Mask                  */
S
S#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO MODE: MODE10 Position             */
S#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO MODE: MODE10 Mask                 */
S
S#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO MODE: MODE11 Position             */
S#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO MODE: MODE11 Mask                 */
S
S#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO MODE: MODE12 Position             */
S#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO MODE: MODE12 Mask                 */
S
S#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO MODE: MODE13 Position             */
S#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO MODE: MODE13 Mask                 */
S
S#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO MODE: MODE14 Position             */
S#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO MODE: MODE14 Mask                 */
S
S#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO MODE: MODE15 Position             */
S#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO MODE: MODE15 Mask                 */
S
S#define GPIO_DINOFF_DINOFF16_Pos         (16)                                              /*!< GPIO DINOFF: DINOFF16 Position         */
S#define GPIO_DINOFF_DINOFF16_Msk         (0x1ul << GPIO_DINOFF_DINOFF16_Pos)               /*!< GPIO DINOFF: DINOFF16 Mask             */
S
S#define GPIO_DINOFF_DINOFF17_Pos         (17)                                              /*!< GPIO DINOFF: DINOFF17 Position         */
S#define GPIO_DINOFF_DINOFF17_Msk         (0x1ul << GPIO_DINOFF_DINOFF17_Pos)               /*!< GPIO DINOFF: DINOFF17 Mask             */
S
S#define GPIO_DINOFF_DINOFF18_Pos         (18)                                              /*!< GPIO DINOFF: DINOFF18 Position         */
S#define GPIO_DINOFF_DINOFF18_Msk         (0x1ul << GPIO_DINOFF_DINOFF18_Pos)               /*!< GPIO DINOFF: DINOFF18 Mask             */
S
S#define GPIO_DINOFF_DINOFF19_Pos         (19)                                              /*!< GPIO DINOFF: DINOFF19 Position         */
S#define GPIO_DINOFF_DINOFF19_Msk         (0x1ul << GPIO_DINOFF_DINOFF19_Pos)               /*!< GPIO DINOFF: DINOFF19 Mask             */
S
S#define GPIO_DINOFF_DINOFF20_Pos         (20)                                              /*!< GPIO DINOFF: DINOFF20 Position         */
S#define GPIO_DINOFF_DINOFF20_Msk         (0x1ul << GPIO_DINOFF_DINOFF20_Pos)               /*!< GPIO DINOFF: DINOFF20 Mask             */
S
S#define GPIO_DINOFF_DINOFF21_Pos         (21)                                              /*!< GPIO DINOFF: DINOFF21 Position         */
S#define GPIO_DINOFF_DINOFF21_Msk         (0x1ul << GPIO_DINOFF_DINOFF21_Pos)               /*!< GPIO DINOFF: DINOFF21 Mask             */
S
S#define GPIO_DINOFF_DINOFF22_Pos         (22)                                              /*!< GPIO DINOFF: DINOFF22 Position         */
S#define GPIO_DINOFF_DINOFF22_Msk         (0x1ul << GPIO_DINOFF_DINOFF22_Pos)               /*!< GPIO DINOFF: DINOFF22 Mask             */
S
S#define GPIO_DINOFF_DINOFF23_Pos         (23)                                              /*!< GPIO DINOFF: DINOFF23 Position         */
S#define GPIO_DINOFF_DINOFF23_Msk         (0x1ul << GPIO_DINOFF_DINOFF23_Pos)               /*!< GPIO DINOFF: DINOFF23 Mask             */
S
S#define GPIO_DINOFF_DINOFF24_Pos         (24)                                              /*!< GPIO DINOFF: DINOFF24 Position         */
S#define GPIO_DINOFF_DINOFF24_Msk         (0x1ul << GPIO_DINOFF_DINOFF24_Pos)               /*!< GPIO DINOFF: DINOFF24 Mask             */
S
S#define GPIO_DINOFF_DINOFF25_Pos         (25)                                              /*!< GPIO DINOFF: DINOFF25 Position         */
S#define GPIO_DINOFF_DINOFF25_Msk         (0x1ul << GPIO_DINOFF_DINOFF25_Pos)               /*!< GPIO DINOFF: DINOFF25 Mask             */
S
S#define GPIO_DINOFF_DINOFF26_Pos         (26)                                              /*!< GPIO DINOFF: DINOFF26 Position         */
S#define GPIO_DINOFF_DINOFF26_Msk         (0x1ul << GPIO_DINOFF_DINOFF26_Pos)               /*!< GPIO DINOFF: DINOFF26 Mask             */
S
S#define GPIO_DINOFF_DINOFF27_Pos         (27)                                              /*!< GPIO DINOFF: DINOFF27 Position         */
S#define GPIO_DINOFF_DINOFF27_Msk         (0x1ul << GPIO_DINOFF_DINOFF27_Pos)               /*!< GPIO DINOFF: DINOFF27 Mask             */
S
S#define GPIO_DINOFF_DINOFF28_Pos         (28)                                              /*!< GPIO DINOFF: DINOFF28 Position         */
S#define GPIO_DINOFF_DINOFF28_Msk         (0x1ul << GPIO_DINOFF_DINOFF28_Pos)               /*!< GPIO DINOFF: DINOFF28 Mask             */
S
S#define GPIO_DINOFF_DINOFF29_Pos         (29)                                              /*!< GPIO DINOFF: DINOFF29 Position         */
S#define GPIO_DINOFF_DINOFF29_Msk         (0x1ul << GPIO_DINOFF_DINOFF29_Pos)               /*!< GPIO DINOFF: DINOFF29 Mask             */
S
S#define GPIO_DINOFF_DINOFF30_Pos         (30)                                              /*!< GPIO DINOFF: DINOFF30 Position         */
S#define GPIO_DINOFF_DINOFF30_Msk         (0x1ul << GPIO_DINOFF_DINOFF30_Pos)               /*!< GPIO DINOFF: DINOFF30 Mask             */
S
S#define GPIO_DINOFF_DINOFF31_Pos         (31)                                              /*!< GPIO DINOFF: DINOFF31 Position         */
S#define GPIO_DINOFF_DINOFF31_Msk         (0x1ul << GPIO_DINOFF_DINOFF31_Pos)               /*!< GPIO DINOFF: DINOFF31 Mask             */
S
S#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO DOUT: DOUT0 Position              */
S#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO DOUT: DOUT0 Mask                  */
S
S#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO DOUT: DOUT1 Position              */
S#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO DOUT: DOUT1 Mask                  */
S
S#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO DOUT: DOUT2 Position              */
S#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO DOUT: DOUT2 Mask                  */
S
S#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO DOUT: DOUT3 Position              */
S#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO DOUT: DOUT3 Mask                  */
S
S#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO DOUT: DOUT4 Position              */
S#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO DOUT: DOUT4 Mask                  */
S
S#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO DOUT: DOUT5 Position              */
S#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO DOUT: DOUT5 Mask                  */
S
S#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO DOUT: DOUT6 Position              */
S#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO DOUT: DOUT6 Mask                  */
S
S#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO DOUT: DOUT7 Position              */
S#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO DOUT: DOUT7 Mask                  */
S
S#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO DOUT: DOUT8 Position              */
S#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO DOUT: DOUT8 Mask                  */
S
S#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO DOUT: DOUT9 Position              */
S#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO DOUT: DOUT9 Mask                  */
S
S#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO DOUT: DOUT10 Position             */
S#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO DOUT: DOUT10 Mask                 */
S
S#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO DOUT: DOUT11 Position             */
S#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO DOUT: DOUT11 Mask                 */
S
S#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO DOUT: DOUT12 Position             */
S#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO DOUT: DOUT12 Mask                 */
S
S#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO DOUT: DOUT13 Position             */
S#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO DOUT: DOUT13 Mask                 */
S
S#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO DOUT: DOUT14 Position             */
S#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO DOUT: DOUT14 Mask                 */
S
S#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO DOUT: DOUT15 Position             */
S#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO DOUT: DOUT15 Mask                 */
S
S#define GPIO_DATMSK_DATMSK0_Pos          (0)                                               /*!< GPIO DATMSK: DATMSK0 Position          */
S#define GPIO_DATMSK_DATMSK0_Msk          (0x1ul << GPIO_DATMSK_DATMSK0_Pos)                /*!< GPIO DATMSK: DATMSK0 Mask              */
S
S#define GPIO_DATMSK_DATMSK1_Pos          (1)                                               /*!< GPIO DATMSK: DATMSK1 Position          */
S#define GPIO_DATMSK_DATMSK1_Msk          (0x1ul << GPIO_DATMSK_DATMSK1_Pos)                /*!< GPIO DATMSK: DATMSK1 Mask              */
S
S#define GPIO_DATMSK_DATMSK2_Pos          (2)                                               /*!< GPIO DATMSK: DATMSK2 Position          */
S#define GPIO_DATMSK_DATMSK2_Msk          (0x1ul << GPIO_DATMSK_DATMSK2_Pos)                /*!< GPIO DATMSK: DATMSK2 Mask              */
S
S#define GPIO_DATMSK_DATMSK3_Pos          (3)                                               /*!< GPIO DATMSK: DATMSK3 Position          */
S#define GPIO_DATMSK_DATMSK3_Msk          (0x1ul << GPIO_DATMSK_DATMSK3_Pos)                /*!< GPIO DATMSK: DATMSK3 Mask              */
S
S#define GPIO_DATMSK_DATMSK4_Pos          (4)                                               /*!< GPIO DATMSK: DATMSK4 Position          */
S#define GPIO_DATMSK_DATMSK4_Msk          (0x1ul << GPIO_DATMSK_DATMSK4_Pos)                /*!< GPIO DATMSK: DATMSK4 Mask              */
S
S#define GPIO_DATMSK_DATMSK5_Pos          (5)                                               /*!< GPIO DATMSK: DATMSK5 Position          */
S#define GPIO_DATMSK_DATMSK5_Msk          (0x1ul << GPIO_DATMSK_DATMSK5_Pos)                /*!< GPIO DATMSK: DATMSK5 Mask              */
S
S#define GPIO_DATMSK_DATMSK6_Pos          (6)                                               /*!< GPIO DATMSK: DATMSK6 Position          */
S#define GPIO_DATMSK_DATMSK6_Msk          (0x1ul << GPIO_DATMSK_DATMSK6_Pos)                /*!< GPIO DATMSK: DATMSK6 Mask              */
S
S#define GPIO_DATMSK_DATMSK7_Pos          (7)                                               /*!< GPIO DATMSK: DATMSK7 Position          */
S#define GPIO_DATMSK_DATMSK7_Msk          (0x1ul << GPIO_DATMSK_DATMSK7_Pos)                /*!< GPIO DATMSK: DATMSK7 Mask              */
S
S#define GPIO_DATMSK_DATMSK8_Pos          (8)                                               /*!< GPIO DATMSK: DATMSK8 Position          */
S#define GPIO_DATMSK_DATMSK8_Msk          (0x1ul << GPIO_DATMSK_DATMSK8_Pos)                /*!< GPIO DATMSK: DATMSK8 Mask              */
S
S#define GPIO_DATMSK_DATMSK9_Pos          (9)                                               /*!< GPIO DATMSK: DATMSK9 Position          */
S#define GPIO_DATMSK_DATMSK9_Msk          (0x1ul << GPIO_DATMSK_DATMSK9_Pos)                /*!< GPIO DATMSK: DATMSK9 Mask              */
S
S#define GPIO_DATMSK_DATMSK10_Pos         (10)                                              /*!< GPIO DATMSK: DATMSK10 Position         */
S#define GPIO_DATMSK_DATMSK10_Msk         (0x1ul << GPIO_DATMSK_DATMSK10_Pos)               /*!< GPIO DATMSK: DATMSK10 Mask             */
S
S#define GPIO_DATMSK_DATMSK11_Pos         (11)                                              /*!< GPIO DATMSK: DATMSK11 Position         */
S#define GPIO_DATMSK_DATMSK11_Msk         (0x1ul << GPIO_DATMSK_DATMSK11_Pos)               /*!< GPIO DATMSK: DATMSK11 Mask             */
S
S#define GPIO_DATMSK_DATMSK12_Pos         (12)                                              /*!< GPIO DATMSK: DATMSK12 Position         */
S#define GPIO_DATMSK_DATMSK12_Msk         (0x1ul << GPIO_DATMSK_DATMSK12_Pos)               /*!< GPIO DATMSK: DATMSK12 Mask             */
S
S#define GPIO_DATMSK_DATMSK13_Pos         (13)                                              /*!< GPIO DATMSK: DATMSK13 Position         */
S#define GPIO_DATMSK_DATMSK13_Msk         (0x1ul << GPIO_DATMSK_DATMSK13_Pos)               /*!< GPIO DATMSK: DATMSK13 Mask             */
S
S#define GPIO_DATMSK_DATMSK14_Pos         (14)                                              /*!< GPIO DATMSK: DATMSK14 Position         */
S#define GPIO_DATMSK_DATMSK14_Msk         (0x1ul << GPIO_DATMSK_DATMSK14_Pos)               /*!< GPIO DATMSK: DATMSK14 Mask             */
S
S#define GPIO_DATMSK_DATMSK15_Pos         (15)                                              /*!< GPIO DATMSK: DATMSK15 Position         */
S#define GPIO_DATMSK_DATMSK15_Msk         (0x1ul << GPIO_DATMSK_DATMSK15_Pos)               /*!< GPIO DATMSK: DATMSK15 Mask             */
S
S#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO PIN: PIN0 Position                */
S#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO PIN: PIN0 Mask                    */
S
S#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO PIN: PIN1 Position                */
S#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO PIN: PIN1 Mask                    */
S
S#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO PIN: PIN2 Position                */
S#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO PIN: PIN2 Mask                    */
S
S#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO PIN: PIN3 Position                */
S#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO PIN: PIN3 Mask                    */
S
S#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO PIN: PIN4 Position                */
S#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO PIN: PIN4 Mask                    */
S
S#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO PIN: PIN5 Position                */
S#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO PIN: PIN5 Mask                    */
S
S#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO PIN: PIN6 Position                */
S#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO PIN: PIN6 Mask                    */
S
S#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO PIN: PIN7 Position                */
S#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO PIN: PIN7 Mask                    */
S
S#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO PIN: PIN8 Position                */
S#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO PIN: PIN8 Mask                    */
S
S#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO PIN: PIN9 Position                */
S#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO PIN: PIN9 Mask                    */
S
S#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO PIN: PIN10 Position               */
S#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO PIN: PIN10 Mask                   */
S
S#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO PIN: PIN11 Position               */
S#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO PIN: PIN11 Mask                   */
S
S#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO PIN: PIN12 Position               */
S#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO PIN: PIN12 Mask                   */
S
S#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO PIN: PIN13 Position               */
S#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO PIN: PIN13 Mask                   */
S
S#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO PIN: PIN14 Position               */
S#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO PIN: PIN14 Mask                   */
S
S#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO PIN: PIN15 Position               */
S#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO PIN: PIN15 Mask                   */
S
S#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO DBEN: DBEN0 Position              */
S#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO DBEN: DBEN0 Mask                  */
S
S#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO DBEN: DBEN1 Position              */
S#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO DBEN: DBEN1 Mask                  */
S
S#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO DBEN: DBEN2 Position              */
S#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO DBEN: DBEN2 Mask                  */
S
S#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO DBEN: DBEN3 Position              */
S#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO DBEN: DBEN3 Mask                  */
S
S#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO DBEN: DBEN4 Position              */
S#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO DBEN: DBEN4 Mask                  */
S
S#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO DBEN: DBEN5 Position              */
S#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO DBEN: DBEN5 Mask                  */
S
S#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO DBEN: DBEN6 Position              */
S#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO DBEN: DBEN6 Mask                  */
S
S#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO DBEN: DBEN7 Position              */
S#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO DBEN: DBEN7 Mask                  */
S
S#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO DBEN: DBEN8 Position              */
S#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO DBEN: DBEN8 Mask                  */
S
S#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO DBEN: DBEN9 Position              */
S#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO DBEN: DBEN9 Mask                  */
S
S#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO DBEN: DBEN10 Position             */
S#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO DBEN: DBEN10 Mask                 */
S
S#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO DBEN: DBEN11 Position             */
S#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO DBEN: DBEN11 Mask                 */
S
S#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO DBEN: DBEN12 Position             */
S#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO DBEN: DBEN12 Mask                 */
S
S#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO DBEN: DBEN13 Position             */
S#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO DBEN: DBEN13 Mask                 */
S
S#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO DBEN: DBEN14 Position             */
S#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO DBEN: DBEN14 Mask                 */
S
S#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO DBEN: DBEN15 Position             */
S#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO DBEN: DBEN15 Mask                 */
S
S#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO INTTYPE: TYPE0 Position           */
S#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO INTTYPE: TYPE0 Mask               */
S
S#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO INTTYPE: TYPE1 Position           */
S#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO INTTYPE: TYPE1 Mask               */
S
S#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO INTTYPE: TYPE2 Position           */
S#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO INTTYPE: TYPE2 Mask               */
S
S#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO INTTYPE: TYPE3 Position           */
S#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO INTTYPE: TYPE3 Mask               */
S
S#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO INTTYPE: TYPE4 Position           */
S#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO INTTYPE: TYPE4 Mask               */
S
S#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO INTTYPE: TYPE5 Position           */
S#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO INTTYPE: TYPE5 Mask               */
S
S#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO INTTYPE: TYPE6 Position           */
S#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO INTTYPE: TYPE6 Mask               */
S
S#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO INTTYPE: TYPE7 Position           */
S#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO INTTYPE: TYPE7 Mask               */
S
S#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO INTTYPE: TYPE8 Position           */
S#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO INTTYPE: TYPE8 Mask               */
S
S#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO INTTYPE: TYPE9 Position           */
S#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO INTTYPE: TYPE9 Mask               */
S
S#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO INTTYPE: TYPE10 Position          */
S#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO INTTYPE: TYPE10 Mask              */
S
S#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO INTTYPE: TYPE11 Position          */
S#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO INTTYPE: TYPE11 Mask              */
S
S#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO INTTYPE: TYPE12 Position          */
S#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO INTTYPE: TYPE12 Mask              */
S
S#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO INTTYPE: TYPE13 Position          */
S#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO INTTYPE: TYPE13 Mask              */
S
S#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO INTTYPE: TYPE14 Position          */
S#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO INTTYPE: TYPE14 Mask              */
S
S#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO INTTYPE: TYPE15 Position          */
S#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO INTTYPE: TYPE15 Mask              */
S
S#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO INTEN: FLIEN0 Position            */
S#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO INTEN: FLIEN0 Mask                */
S
S#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO INTEN: FLIEN1 Position            */
S#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO INTEN: FLIEN1 Mask                */
S
S#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO INTEN: FLIEN2 Position            */
S#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO INTEN: FLIEN2 Mask                */
S
S#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO INTEN: FLIEN3 Position            */
S#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO INTEN: FLIEN3 Mask                */
S
S#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO INTEN: FLIEN4 Position            */
S#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO INTEN: FLIEN4 Mask                */
S
S#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO INTEN: FLIEN5 Position            */
S#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO INTEN: FLIEN5 Mask                */
S
S#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO INTEN: FLIEN6 Position            */
S#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO INTEN: FLIEN6 Mask                */
S
S#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO INTEN: FLIEN7 Position            */
S#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO INTEN: FLIEN7 Mask                */
S
S#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO INTEN: FLIEN8 Position            */
S#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO INTEN: FLIEN8 Mask                */
S
S#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO INTEN: FLIEN9 Position            */
S#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO INTEN: FLIEN9 Mask                */
S
S#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO INTEN: FLIEN10 Position           */
S#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO INTEN: FLIEN10 Mask               */
S
S#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO INTEN: FLIEN11 Position           */
S#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO INTEN: FLIEN11 Mask               */
S
S#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO INTEN: FLIEN12 Position           */
S#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO INTEN: FLIEN12 Mask               */
S
S#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO INTEN: FLIEN13 Position           */
S#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO INTEN: FLIEN13 Mask               */
S
S#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO INTEN: FLIEN14 Position           */
S#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO INTEN: FLIEN14 Mask               */
S
S#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO INTEN: FLIEN15 Position           */
S#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO INTEN: FLIEN15 Mask               */
S
S#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO INTEN: RHIEN0 Position            */
S#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO INTEN: RHIEN0 Mask                */
S
S#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO INTEN: RHIEN1 Position            */
S#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO INTEN: RHIEN1 Mask                */
S
S#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO INTEN: RHIEN2 Position            */
S#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO INTEN: RHIEN2 Mask                */
S
S#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO INTEN: RHIEN3 Position            */
S#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO INTEN: RHIEN3 Mask                */
S
S#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO INTEN: RHIEN4 Position            */
S#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO INTEN: RHIEN4 Mask                */
S
S#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO INTEN: RHIEN5 Position            */
S#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO INTEN: RHIEN5 Mask                */
S
S#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO INTEN: RHIEN6 Position            */
S#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO INTEN: RHIEN6 Mask                */
S
S#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO INTEN: RHIEN7 Position            */
S#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO INTEN: RHIEN7 Mask                */
S
S#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO INTEN: RHIEN8 Position            */
S#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO INTEN: RHIEN8 Mask                */
S
S#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO INTEN: RHIEN9 Position            */
S#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO INTEN: RHIEN9 Mask                */
S
S#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO INTEN: RHIEN10 Position           */
S#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO INTEN: RHIEN10 Mask               */
S
S#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO INTEN: RHIEN11 Position           */
S#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO INTEN: RHIEN11 Mask               */
S
S#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO INTEN: RHIEN12 Position           */
S#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO INTEN: RHIEN12 Mask               */
S
S#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO INTEN: RHIEN13 Position           */
S#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO INTEN: RHIEN13 Mask               */
S
S#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO INTEN: RHIEN14 Position           */
S#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO INTEN: RHIEN14 Mask               */
S
S#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO INTEN: RHIEN15 Position           */
S#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO INTEN: RHIEN15 Mask               */
S
S#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO INTSRC: INTSRC0 Position          */
S#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO INTSRC: INTSRC0 Mask              */
S
S#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO INTSRC: INTSRC1 Position          */
S#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO INTSRC: INTSRC1 Mask              */
S
S#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO INTSRC: INTSRC2 Position          */
S#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO INTSRC: INTSRC2 Mask              */
S
S#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO INTSRC: INTSRC3 Position          */
S#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO INTSRC: INTSRC3 Mask              */
S
S#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO INTSRC: INTSRC4 Position          */
S#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO INTSRC: INTSRC4 Mask              */
S
S#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO INTSRC: INTSRC5 Position          */
S#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO INTSRC: INTSRC5 Mask              */
S
S#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO INTSRC: INTSRC6 Position          */
S#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO INTSRC: INTSRC6 Mask              */
S
S#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO INTSRC: INTSRC7 Position          */
S#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO INTSRC: INTSRC7 Mask              */
S
S#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO INTSRC: INTSRC8 Position          */
S#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO INTSRC: INTSRC8 Mask              */
S
S#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO INTSRC: INTSRC9 Position          */
S#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO INTSRC: INTSRC9 Mask              */
S
S#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO INTSRC: INTSRC10 Position         */
S#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO INTSRC: INTSRC10 Mask             */
S
S#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO INTSRC: INTSRC11 Position         */
S#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO INTSRC: INTSRC11 Mask             */
S
S#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO INTSRC: INTSRC12 Position         */
S#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO INTSRC: INTSRC12 Mask             */
S
S#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO INTSRC: INTSRC13 Position         */
S#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO INTSRC: INTSRC13 Mask             */
S
S#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO INTSRC: INTSRC14 Position         */
S#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO INTSRC: INTSRC14 Mask             */
S
S#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO INTSRC: INTSRC15 Position         */
S#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO INTSRC: INTSRC15 Mask             */
S
S#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO DBCTL: DBCLKSEL Position          */
S#define GPIO_DBCTL_DBCLKSEL_Msk          (0xful << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO DBCTL: DBCLKSEL Mask              */
S
S#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO DBCTL: DBCLKSRC Position          */
S#define GPIO_DBCTL_DBCLKSRC_Msk          (0x1ul << GPIO_DBCTL_DBCLKSRC_Pos)                /*!< GPIO DBCTL: DBCLKSRC Mask              */
S
S#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO DBCTL: ICLKON Position            */
S#define GPIO_DBCTL_ICLKON_Msk            (0x1ul << GPIO_DBCTL_ICLKON_Pos)                  /*!< GPIO DBCTL: ICLKON Mask                */
S
S/**@}*/ /* GPIO_CONST */
S/**@}*/ /* end of GPIO register group */
S
S
S/*---------------------- Inter-IC Bus Controller -------------------------*/
S/**
S    @addtogroup I2C Inter-IC Bus Controller(I2C)
S    Memory Mapped Structure for I2C Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  I2C Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |AA        |Assert Acknowledge Control Bit
S     * |        |          |When AA=1 prior to address or data received, an acknowledge (ACK - low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when:
S     * |        |          |1. A slave is acknowledging the address sent from master,
S     * |        |          |2. The receiver devices are acknowledging the data sent by transmitter.
S     * |        |          |When AA = 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line
S     * |[3]     |SI        |I2C Interrupt Flag
S     * |        |          |When a new SIO state is present in the I2C_STATUS register, the SI flag is set by hardware, and if bit EI ( I2C_CTL[7]) is set, the I2C interrupt is requested.
S     * |        |          |SI must be cleared by software.
S     * |        |          |Clear SI is by writing one to this bit.
S     * |[4]     |STO       |I2C STOP Control Bit
S     * |        |          |In master mode, set STO to transmit a STOP condition to bus.
S     * |        |          |I2C hardware will check the bus condition, when a STOP condition is detected this bit will be cleared by hardware automatically.
S     * |        |          |In slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
S     * |        |          |This means it is NO LONGER in the slave receiver mode able receive data from the master transmit device.
S     * |[5]     |STA       |I2C START Control Bit
S     * |        |          |Setting STA to logic 1 will enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
S     * |[6]     |I2CEN     |I2C Controller Enable Bit
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |        |          |Set to enable I2C serial function block. 
S     * |[7]     |INTEN     |Enable Interrupt
S     * |        |          |0 = Disable interrupt.
S     * |        |          |1 = Enable interrupt CPU.
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * ADDR0
S     * ===================================================================================================
S     * Offset: 0x04  I2C Slave address Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[1:7]   |ADDR      |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
S     * |        |          |The I2C hardware will react if any of the addresses are matched.
S */
S    __IO uint32_t ADDR0;                 
S
S    /**
S     * DAT
S     * ===================================================================================================
S     * Offset: 0x08  I2C DATA Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |DAT       |I2C Data Register
S     * |        |          |During master or slave transmit mode, data to be transmitted is written to this register.
S     * |        |          |During master or slave receive mode, data that has been received may be read from this register.
S */
S    __IO uint32_t DAT;                   
S
S    /**
S     * STATUS
S     * ===================================================================================================
S     * Offset: 0x0C  I2C Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |STATUS    |I2C Status Register
S     * |        |          |The status register of I2C:
S     * |        |          |The three least significant bits are always 0.
S     * |        |          |The five most significant bits contain the status code.
S     * |        |          |There are 26 possible status codes.
S     * |        |          |When STATUS contains F8H, no serial interrupt is requested.
S     * |        |          |All other STATUS values correspond to defined I2C states.
S     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
S     * |        |          |A valid status code is present in STATUS one PCLK cycle after SI is set by hardware and is still present one PCLK cycle after SI has been reset by software.
S     * |        |          |In addition, states 00H stands for a Bus Error.
S     * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the frame.
S     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
S */
S    __I  uint32_t STATUS;                
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x10  I2C clock divided Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |DIVIDER   |I2C Clock Divided Register
S     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x( CLK+1)).
S */
S    __IO uint32_t CLKDIV;                
S
S    /**
S     * TOCTL
S     * ===================================================================================================
S     * Offset: 0x14  I2C Time out control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TOIF      |Time-Out Flag
S     * |        |          |0 = No time-out.
S     * |        |          |1 = Time-out flag is set by H/W. It can interrupt CPU. Write 1 to clear.
S     * |[1]     |TOCDIV4   |Time-Out Counter Input Clock Divide By 4
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |        |          |When enabled, the time-out clock is PCLK/4.
S     * |[2]     |TOCEN     |Time-out Counter Control Bit
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |        |          |When enabled, the 14 bit time-out counter will start counting when SI is clear.
S     * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
S */
S    __IO uint32_t TOCTL;                 
S
S    /**
S     * ADDR1
S     * ===================================================================================================
S     * Offset: 0x18  I2C Slave address Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[1:7]   |ADDR      |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
S     * |        |          |The I2C hardware will react if any of the addresses are matched.
S */
S    __IO uint32_t ADDR1;                 
S
S    /**
S     * ADDR2
S     * ===================================================================================================
S     * Offset: 0x1C  I2C Slave address Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[1:7]   |ADDR      |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
S     * |        |          |The I2C hardware will react if any of the addresses are matched.
S */
S    __IO uint32_t ADDR2;                 
S
S    /**
S     * ADDR3
S     * ===================================================================================================
S     * Offset: 0x20  I2C Slave address Register3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[1:7]   |ADDR      |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the MCU's own address.
S     * |        |          |The I2C hardware will react if any of the addresses are matched.
S */
S    __IO uint32_t ADDR3;                 
S
S    /**
S     * ADDRMSK0
S     * ===================================================================================================
S     * Offset: 0x24  I2C Slave address Mask Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |ADDRMSK1  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[2]     |ADDRMSK2  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[3]     |ADDRMSK3  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[4]     |ADDRMSK4  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[5]     |ADDRMSK5  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[6]     |ADDRMSK6  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[7]     |ADDRMSK7  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S */
S    __IO uint32_t ADDRMSK0;              
S
S    /**
S     * ADDRMSK1
S     * ===================================================================================================
S     * Offset: 0x28  I2C Slave address Mask Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |ADDRMSK1  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[2]     |ADDRMSK2  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[3]     |ADDRMSK3  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[4]     |ADDRMSK4  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[5]     |ADDRMSK5  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[6]     |ADDRMSK6  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[7]     |ADDRMSK7  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S */
S    __IO uint32_t ADDRMSK1;              
S
S    /**
S     * ADDRMSK2
S     * ===================================================================================================
S     * Offset: 0x2C  I2C Slave address Mask Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |ADDRMSK1  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[2]     |ADDRMSK2  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[3]     |ADDRMSK3  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[4]     |ADDRMSK4  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[5]     |ADDRMSK5  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[6]     |ADDRMSK6  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[7]     |ADDRMSK7  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S */
S    __IO uint32_t ADDRMSK2;              
S
S    /**
S     * ADDRMSK3
S     * ===================================================================================================
S     * Offset: 0x30  I2C Slave address Mask Register3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |ADDRMSK1  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[2]     |ADDRMSK2  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[3]     |ADDRMSK3  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[4]     |ADDRMSK4  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[5]     |ADDRMSK5  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[6]     |ADDRMSK6  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S     * |[7]     |ADDRMSK7  |I2C Address Mask register
S     * |        |          |0 = Mask disable.
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |I2C bus controllers support multiple-address recognition with four address mask registers.
S     * |        |          |Bits in this field mask the I2C_ADDRx registers.
S     * |        |          |masking bits from the address comparison.
S */
S    __IO uint32_t ADDRMSK3;              
S
S} I2C_T;
S
S/**
S    @addtogroup I2C_CONST I2C Bit Field Definition
S    Constant Definitions for I2C Controller
S@{ */
S
S#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C CTL: AA Position                   */
S#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C CTL: AA Mask                       */
S
S#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C CTL: SI Position                   */
S#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C CTL: SI Mask                       */
S
S#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C CTL: STO Position                  */
S#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C CTL: STO Mask                      */
S
S#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C CTL: STA Position                  */
S#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C CTL: STA Mask                      */
S
S#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C CTL: I2CEN Position                */
S#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C CTL: I2CEN Mask                    */
S
S#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C CTL: INTEN Position                */
S#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C CTL: INTEN Mask                    */
S
S#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C ADDR0: GC Position                 */
S#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C ADDR0: GC Mask                     */
S
S#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C ADDR0: ADDR Position               */
S#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C ADDR0: ADDR Mask                   */
S
S#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C DAT: DAT Position                  */
S#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C DAT: DAT Mask                      */
S
S#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C STATUS: STATUS Position            */
S#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C STATUS: STATUS Mask                */
S
S#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C CLKDIV: DIVIDER Position           */
S#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C CLKDIV: DIVIDER Mask               */
S
S#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C TOCTL: TOIF Position               */
S#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C TOCTL: TOIF Mask                   */
S
S#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C TOCTL: TOCDIV4 Position            */
S#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C TOCTL: TOCDIV4 Mask                */
S
S#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C TOCTL: TOCEN Position              */
S#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C TOCTL: TOCEN Mask                  */
S
S#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C ADDR1: GC Position                 */
S#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C ADDR1: GC Mask                     */
S
S#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C ADDR1: ADDR Position               */
S#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C ADDR1: ADDR Mask                   */
S
S#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C ADDR2: GC Position                 */
S#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C ADDR2: GC Mask                     */
S
S#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C ADDR2: ADDR Position               */
S#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C ADDR2: ADDR Mask                   */
S
S#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C ADDR3: GC Position                 */
S#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C ADDR3: GC Mask                     */
S
S#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C ADDR3: ADDR Position               */
S#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C ADDR3: ADDR Mask                   */
S
S#define I2C_ADDRMSK0_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK0: ADDRMSK1 Position        */
S#define I2C_ADDRMSK0_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK1_Pos)              /*!< I2C ADDRMSK0: ADDRMSK1 Mask            */
S
S#define I2C_ADDRMSK0_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK0: ADDRMSK2 Position        */
S#define I2C_ADDRMSK0_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK2_Pos)              /*!< I2C ADDRMSK0: ADDRMSK2 Mask            */
S
S#define I2C_ADDRMSK0_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK0: ADDRMSK3 Position        */
S#define I2C_ADDRMSK0_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK3_Pos)              /*!< I2C ADDRMSK0: ADDRMSK3 Mask            */
S
S#define I2C_ADDRMSK0_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK0: ADDRMSK4 Position        */
S#define I2C_ADDRMSK0_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK4_Pos)              /*!< I2C ADDRMSK0: ADDRMSK4 Mask            */
S
S#define I2C_ADDRMSK0_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK0: ADDRMSK5 Position        */
S#define I2C_ADDRMSK0_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK5_Pos)              /*!< I2C ADDRMSK0: ADDRMSK5 Mask            */
S
S#define I2C_ADDRMSK0_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK0: ADDRMSK6 Position        */
S#define I2C_ADDRMSK0_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK6_Pos)              /*!< I2C ADDRMSK0: ADDRMSK6 Mask            */
S
S#define I2C_ADDRMSK0_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK0: ADDRMSK7 Position        */
S#define I2C_ADDRMSK0_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK0_ADDRMSK7_Pos)              /*!< I2C ADDRMSK0: ADDRMSK7 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK1: ADDRMSK1 Position        */
S#define I2C_ADDRMSK1_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK1_Pos)              /*!< I2C ADDRMSK1: ADDRMSK1 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK1: ADDRMSK2 Position        */
S#define I2C_ADDRMSK1_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK2_Pos)              /*!< I2C ADDRMSK1: ADDRMSK2 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK1: ADDRMSK3 Position        */
S#define I2C_ADDRMSK1_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK3_Pos)              /*!< I2C ADDRMSK1: ADDRMSK3 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK1: ADDRMSK4 Position        */
S#define I2C_ADDRMSK1_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK4_Pos)              /*!< I2C ADDRMSK1: ADDRMSK4 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK1: ADDRMSK5 Position        */
S#define I2C_ADDRMSK1_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK5_Pos)              /*!< I2C ADDRMSK1: ADDRMSK5 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK1: ADDRMSK6 Position        */
S#define I2C_ADDRMSK1_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK6_Pos)              /*!< I2C ADDRMSK1: ADDRMSK6 Mask            */
S
S#define I2C_ADDRMSK1_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK1: ADDRMSK7 Position        */
S#define I2C_ADDRMSK1_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK1_ADDRMSK7_Pos)              /*!< I2C ADDRMSK1: ADDRMSK7 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK2: ADDRMSK1 Position        */
S#define I2C_ADDRMSK2_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK1_Pos)              /*!< I2C ADDRMSK2: ADDRMSK1 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK2: ADDRMSK2 Position        */
S#define I2C_ADDRMSK2_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK2_Pos)              /*!< I2C ADDRMSK2: ADDRMSK2 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK2: ADDRMSK3 Position        */
S#define I2C_ADDRMSK2_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK3_Pos)              /*!< I2C ADDRMSK2: ADDRMSK3 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK2: ADDRMSK4 Position        */
S#define I2C_ADDRMSK2_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK4_Pos)              /*!< I2C ADDRMSK2: ADDRMSK4 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK2: ADDRMSK5 Position        */
S#define I2C_ADDRMSK2_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK5_Pos)              /*!< I2C ADDRMSK2: ADDRMSK5 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK2: ADDRMSK6 Position        */
S#define I2C_ADDRMSK2_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK6_Pos)              /*!< I2C ADDRMSK2: ADDRMSK6 Mask            */
S
S#define I2C_ADDRMSK2_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK2: ADDRMSK7 Position        */
S#define I2C_ADDRMSK2_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK2_ADDRMSK7_Pos)              /*!< I2C ADDRMSK2: ADDRMSK7 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK1_Pos        (1)                                               /*!< I2C ADDRMSK3: ADDRMSK1 Position        */
S#define I2C_ADDRMSK3_ADDRMSK1_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK1_Pos)              /*!< I2C ADDRMSK3: ADDRMSK1 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK2_Pos        (2)                                               /*!< I2C ADDRMSK3: ADDRMSK2 Position        */
S#define I2C_ADDRMSK3_ADDRMSK2_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK2_Pos)              /*!< I2C ADDRMSK3: ADDRMSK2 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK3_Pos        (3)                                               /*!< I2C ADDRMSK3: ADDRMSK3 Position        */
S#define I2C_ADDRMSK3_ADDRMSK3_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK3_Pos)              /*!< I2C ADDRMSK3: ADDRMSK3 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK4_Pos        (4)                                               /*!< I2C ADDRMSK3: ADDRMSK4 Position        */
S#define I2C_ADDRMSK3_ADDRMSK4_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK4_Pos)              /*!< I2C ADDRMSK3: ADDRMSK4 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK5_Pos        (5)                                               /*!< I2C ADDRMSK3: ADDRMSK5 Position        */
S#define I2C_ADDRMSK3_ADDRMSK5_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK5_Pos)              /*!< I2C ADDRMSK3: ADDRMSK5 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK6_Pos        (6)                                               /*!< I2C ADDRMSK3: ADDRMSK6 Position        */
S#define I2C_ADDRMSK3_ADDRMSK6_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK6_Pos)              /*!< I2C ADDRMSK3: ADDRMSK6 Mask            */
S
S#define I2C_ADDRMSK3_ADDRMSK7_Pos        (7)                                               /*!< I2C ADDRMSK3: ADDRMSK7 Position        */
S#define I2C_ADDRMSK3_ADDRMSK7_Msk        (0x1ul << I2C_ADDRMSK3_ADDRMSK7_Pos)              /*!< I2C ADDRMSK3: ADDRMSK7 Mask            */
S
S/**@}*/ /* I2C_CONST */
S/**@}*/ /* end of I2C register group */
S
S
S/*---------------------- I2S Interface Controller -------------------------*/
S/**
S    @addtogroup I2S I2S Interface Controller(I2S)
S    Memory Mapped Structure for I2S Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  I2S Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |I2SEN     |Enable I2S Controller
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |[1]     |TXEN      |Transmit Enable
S     * |        |          |0 = Disable data transmit
S     * |        |          |1 = Enable data transmit 
S     * |[2]     |RXEN      |Receive Enable
S     * |        |          |0 = Disable data receive
S     * |        |          |1 = Enable data receive 
S     * |[3]     |MUTE      |Transmit Mute Enable
S     * |        |          |0 = Transmit data is shifted from FIFO
S     * |        |          |1= Transmit channel zero
S     * |[4:5]   |WDWIDTH   |Word Width
S     * |        |          |This parameter sets the word width of audio data.
S     * |        |          |See Figure 5-63 for details of how data is formatted in transmit and receive FIFO.
S     * |        |          |00 = data is 8 bit
S     * |        |          |01 = data is 16 bit
S     * |        |          |10 = data is 24 bit
S     * |        |          |11 = data is 32 bit
S     * |[6]     |MONO      |Monaural data
S     * |        |          |This parameter sets whether mono or stereo data is processed.
S     * |        |          |See Figure 5-63 for details of how data is formatted in transmit and receive FIFO.
S     * |        |          |0 = Data is stereo format
S     * |        |          |1 = Data is monaural format
S     * |[7]     |FORMAT    |Data format
S     * |        |          |0 = I2S data format
S     * |        |          |1 = MSB justified data format
S     * |        |          |See Figure 5-61 and Figure 5-62 for timing differences.
S     * |[8]     |SLAVE     |Slave Mode
S     * |        |          |I2S can operate as a master or slave.
S     * |        |          |For master mode, I2S_BCLK and I2S_FS pins are outputs and send bit clock and frame sync from ISD9100.
S     * |        |          |In slave mode, I2S_BCLK and I2S_FS pins are inputs and bit clock and frame sync are received from external audio device.
S     * |        |          |0 = Master mode
S     * |        |          |1 = Slave mode 
S     * |[9:11]  |TXTH      |Transmit FIFO Threshold Level
S     * |        |          |If remaining data words in transmit FIFO less than or equal to the threshold level then TXTHI flag is set.
S     * |        |          |Threshold = TXTH words remaining in transmit FIFO
S     * |[12:14] |RXTH      |Receive FIFO Threshold Level
S     * |        |          |When received data word(s) in buffer is equal or higher than threshold level then RXTHI flag is set.
S     * |        |          |Threshold = RXTH+1 words of data in receive FIFO.
S     * |[15]    |MCLKEN    |Master Clock Enable
S     * |        |          |The ISD9100 can generate a master clock signal to an external audio CODEC to synchronize the audio devices.
S     * |        |          |If audio devices are not synchronous, then data will be periodically corrupted.
S     * |        |          |Software needs to implement a way to drop/repeat or interpolate samples in a jitter buffer if devices are not synchronized.
S     * |        |          |The master clock frequency is determined by the I2S_CLKDIV.MCLKDIV.
S     * |        |          |register.
S     * |        |          |0 = Disable master clock
S     * |        |          |1 = Enable master clock
S     * |[16]    |RZCEN     |Right Channel Zero Cross Detect Enable
S     * |        |          |If this bit is set to 1, when right channel data sign bit changes, or data bits are all zero, the RZCIF flag in I2S_STATUS register will be set to 1.
S     * |        |          |0 = Disable right channel zero cross detect
S     * |        |          |1 = Enable right channel zero cross detect
S     * |[17]    |LZCEN     |Left Channel Zero Cross Detect Enable
S     * |        |          |If this bit is set to 1, when left channel data sign bit changes, or data bits are all zero, the LZCIF flag in I2S_STATUS register will be set to 1.
S     * |        |          |0 = Disable left channel zero cross detect
S     * |        |          |1 = Enable left channel zero cross detect
S     * |[18]    |TXCLR     |Clear Transmit FIFO
S     * |        |          |Write 1 to clear transmitting FIFO, internal pointer is reset to FIFO start point, and TXTH returns to zero and transmit FIFO becomes empty.
S     * |        |          |Data in transmit FIFO is not changed.
S     * |        |          |This bit is cleared by hardware automatically when clear operation complete.
S     * |[19]    |RXCLR     |Clear Receive FIFO
S     * |        |          |Write 1 to clear receiving FIFO, internal pointer is reset to FIFO start point, and RXTH returns to zero and receive FIFO becomes empty.
S     * |        |          |This bit is cleared by hardware automatically when clear operation complete.
S     * |[20]    |TXPDMAEN  |Enable Transmit DMA
S     * |        |          |When TX DMA is enables, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.
S     * |        |          |0 = Disable TX DMA
S     * |        |          |1 = Enable TX DMA
S     * |[21]    |RXPDMAEN  |Enable Receive DMA
S     * |        |          |When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.
S     * |        |          |0 = Disable RX DMA
S     * |        |          |1 = Enable RX DMA
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x04  I2S Clock Divider Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |MCLKDIV   |Master Clock Divider
S     * |        |          |ISD9160 can generate a master clock to synchronously drive an external audio device.
S     * |        |          |If MCLKDIV is set to 0, MCLK is the same as I2S_CLK clock input, otherwise MCLK frequency is given by:.
S     * |        |          |F(MCLK) = F(I2S_CLK) / (2xMCLKDIV)
S     * |        |          |Or,
S     * |        |          |MCLKDIV = F(I2S_CLK) / (2 x F(MCLK))
S     * |        |          |If the desired MCLK frequency is 254Fs and Fs = 16kHz then MCLKDIV = 6
S     * |[8:15]  |BCLKDIV   |Bit Clock Divider
S     * |        |          |If I2S operates in master mode, bit clock is provided by ISD9100.
S     * |        |          |Software can program these bits to generate bit clock frequency for the desired sample rate.
S     * |        |          |For sample rate Fs, the desired bit clock frequency is:
S     * |        |          |F(BCLK) = Fs x Word_width_in_bytes x 16
S     * |        |          |For example if Fs = 16kHz, and word width is 2-bytes (16bit) then desired bit clock frequency is 512kHz.
S     * |        |          |The bit clock frequency is given by:
S     * |        |          |F(BCLK) = F(I2S_CLK) / 2x(BCLKDIV+1)
S     * |        |          |Or,
S     * |        |          |BCLKDIV = F(I2S_CLK) / (2 x F(BCLK)) -1
S     * |        |          |So if F(I2S_CLK) = HCLK = 49.152MHz, desired F(BCLK) = 512kHzthen BCLKDIV = 47
S */
S    __IO uint32_t CLKDIV;                
S
S    /**
S     * IEN
S     * ===================================================================================================
S     * Offset: 0x08  I2S Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXUDIEN   |Receive FIFO Underflow Interrupt Enable
S     * |        |          |If software read receive FIFO when it is empty then RXUDIF flag in I2SSTATUS register is set to 1.
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[1]     |RXOVIEN   |Receive FIFO Overflow Interrupt Enable
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[2]     |RXTHIEN   |Receive FIFO Threshold Level Interrupt
S     * |        |          |Interrupt occurs if this bit is set to 1 and data words in receive FIFO is greater than or equal to RXTH[2:0].
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[8]     |TXUDIEN   |Transmit FIFO Underflow Interrupt Enable
S     * |        |          |Interrupt occur if this bit is set to 1 and transmit FIFO underflow flag is set to 1.
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[9]     |TXOVIEN   |Transmit FIFO Overflow Interrupt Enable
S     * |        |          |Interrupt occurs if this bit is set to 1 and transmit FIFO overflow flag is set to 1
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[10]    |TXTHIEN   |Transmit FIFO Threshold Level Interrupt Enable
S     * |        |          |Interrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH[2:0].
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[11]    |RZCIEN    |Right Channel Zero Cross Interrupt Enable
S     * |        |          |Interrupt will occur if this bit is set to 1 and right channel has zero cross event
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S     * |[12]    |LZCIEN    |Left Channel Zero Cross Interrupt Enable
S     * |        |          |Interrupt will occur if this bit is set to 1 and left channel has zero cross event
S     * |        |          |0 = Disable interrupt
S     * |        |          |1 = Enable interrupt
S */
S    __IO uint32_t IEN;                   
S
S    /**
S     * STATUS
S     * ===================================================================================================
S     * Offset: 0x0C  I2S Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |I2SIF     |I2S Interrupt (Read Only)
S     * |        |          |This bit is set if any enabled I2S interrupt is active.
S     * |        |          |0 = No I2S interrupt
S     * |        |          |1 = I2S interrupt active
S     * |[1]     |RXIF      |I2S Receive Interrupt (Read Only)
S     * |        |          |This indicates that there is an active receive interrupt source.
S     * |        |          |This could be RXOVIF, RXUDIF or RXTHIF if corresponding interrupt enable bits are active.
S     * |        |          |To clear interrupt the corresponding source(s) must be cleared.
S     * |        |          |0 = No receive interrupt
S     * |        |          |1 = Receive interrupt occurred
S     * |[2]     |TXIF      |I2S Transmit Interrupt (Read Only)
S     * |        |          |This indicates that there is an active transmit interrupt source.
S     * |        |          |This could be TXOVIF, TXUDIF, TXTHIF, LZCIF or RZCIF if corresponding interrupt enable bits are active.
S     * |        |          |To clear interrupt the corresponding source(s) must be cleared.
S     * |        |          |0 = No transmit interrupt
S     * |        |          |1 = Transmit interrupt occurred.
S     * |[3]     |RIGHT     |Right Channel Active (Read Only)
S     * |        |          |This bit indicates current data being transmitted/received belongs to right channel
S     * |        |          |0 = Left channel
S     * |        |          |1 = Right channel
S     * |[8]     |RXUDIF    |Receive FIFO Underflow Flag (Write '1' to clear)
S     * |        |          |This flag is set if attempt is made to read receive FIFO while it is empty.
S     * |        |          |0 = No underflow
S     * |        |          |1 = Underflow
S     * |[9]     |RXOVIF    |Receive FIFO Overflow Flag (Write '1' to clear)
S     * |        |          |This flag is set if I2S controller writes to receive FIFO when it is full. Audio data is lost.
S     * |        |          |0 = No overflow
S     * |        |          |1 = Overflow
S     * |[10]    |RXTHIF    |Receive FIFO Threshold Flag (Read Only)
S     * |        |          |When data word(s) in receive FIFO is greater than or equal to threshold value set in RXTH[2:0] the RXTHIF bit becomes to 1.
S     * |        |          |It remains set until receive FIFO level is less than RXTH[2:0].
S     * |        |          |It is cleared by reading I2S_RX until threshold satisfied.
S     * |        |          |0 = Data word(s) in FIFO is less than threshold level
S     * |        |          |1 = Data word(s) in FIFO is greater than or equal to threshold level
S     * |[11]    |RXFULL    |Receive FIFO full (Read Only)
S     * |        |          |This bit is set when receive FIFO is full.
S     * |        |          |0 = Not full.
S     * |        |          |1 = Full.
S     * |[12]    |RXEMPTY   |Receive FIFO empty (Read Only)
S     * |        |          |This is set when receive FIFO is empty.
S     * |        |          |0 = Not empty
S     * |        |          |1 = Empty
S     * |[16]    |TXUDIF    |Transmit FIFO underflow flag (Write '1' to clear)
S     * |        |          |This flag is set if I2S controller requests data when transmit FIFO is empty.
S     * |        |          |0 = No underflow
S     * |        |          |1 = Underflow
S     * |[17]    |TXOVIF    |Transmit FIFO Overflow Flag (Write '1' to clear)
S     * |        |          |This flag is set if data is written to transmit FIFO when it is full.
S     * |        |          |0 = No overflow
S     * |        |          |1 = Overflow
S     * |[18]    |TXTHIF    |Transmit FIFO Threshold Flag (Read Only)
S     * |        |          |When data word(s) in transmit FIFO is less than or equal to the threshold value set in TXTH[2:0] the TXTHIF bit becomes to 1.
S     * |        |          |It remains set until transmit FIFO level is greater than TXTH[2:0].
S     * |        |          |Cleared by writing to I2S_TX register until threshold exceeded.
S     * |        |          |0 = Data word(s) in FIFO is greater than threshold level
S     * |        |          |1 = Data word(s) in FIFO is less than or equal to threshold level
S     * |[19]    |TXFULL    |Transmit FIFO Full (Read Only)
S     * |        |          |This bit is set when transmit FIFO is full.
S     * |        |          |0 = Not full.
S     * |        |          |1 = Full.
S     * |[20]    |TXEMPTY   |Transmit FIFO Empty (Read Only)
S     * |        |          |This is set when transmit FIFO is empty.
S     * |        |          |0 = Not empty
S     * |        |          |1 = Empty
S     * |[21]    |TXBUSY    |Transmit Busy (Read Only)
S     * |        |          |This bit is cleared when all data in transmit FIFO and Tx shift register is shifted out.
S     * |        |          |It is set when first data is loaded to Tx shift register.
S     * |        |          |0 = Transmit shift register is empty
S     * |        |          |1 = Transmit shift register is busy
S     * |[22]    |RZCIF     |Right channel zero cross flag (write '1' to clear, or clear RZCEN)
S     * |        |          |0 = No zero cross
S     * |        |          |1 = Right channel zero cross is detected
S     * |[23]    |LZCIF     |Left channel zero cross flag (write '1' to clear, or clear LZCEN)
S     * |        |          |0 = No zero cross detected.
S     * |        |          |1 = Left channel zero cross is detected
S     * |[24:27] |RXCNT     |Receive FIFO level (Read Only)
S     * |        |          |RXCNT = number of words in receive FIFO.
S     * |[28:31] |TXCNT     |Transmit FIFO level (Read Only)
S     * |        |          |TXCNT = number of words in transmit FIFO.
S */
S    __I  uint32_t STATUS;                
S
S    /**
S     * TX
S     * ===================================================================================================
S     * Offset: 0x10  I2S Transmit FIFO Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |TX        |Transmit FIFO Register (Write Only)
S     * |        |          |A write to this register pushes data onto the transmit FIFO.
S     * |        |          |The transmit FIFO is eight words deep.
S     * |        |          |The number of words currently in the FIFO can be determined by reading I2S_STATUS.TXCNT.
S */
S    __O  uint32_t TX;                    
S
S    /**
S     * RX
S     * ===================================================================================================
S     * Offset: 0x14  I2S Receive FIFO Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |RX        |Receive FIFO Register (Read Only)
S     * |        |          |A read of this register will pop data from the receive FIFO.
S     * |        |          |The receive FIFO is eight words deep.
S     * |        |          |The number of words currently in the FIFO can be determined by reading I2S_STATUS.RXCNT.
S */
S    __I  uint32_t RX;                    
S
S} I2S_T;
S
S/**
S    @addtogroup I2S_CONST I2S Bit Field Definition
S    Constant Definitions for I2S Controller
S@{ */
S
S#define I2S_CTL_I2SEN_Pos                (0)                                               /*!< I2S CTL: I2SEN Position                */
S#define I2S_CTL_I2SEN_Msk                (0x1ul << I2S_CTL_I2SEN_Pos)                      /*!< I2S CTL: I2SEN Mask                    */
S
S#define I2S_CTL_TXEN_Pos                 (1)                                               /*!< I2S CTL: TXEN Position                 */
S#define I2S_CTL_TXEN_Msk                 (0x1ul << I2S_CTL_TXEN_Pos)                       /*!< I2S CTL: TXEN Mask                     */
S
S#define I2S_CTL_RXEN_Pos                 (2)                                               /*!< I2S CTL: RXEN Position                 */
S#define I2S_CTL_RXEN_Msk                 (0x1ul << I2S_CTL_RXEN_Pos)                       /*!< I2S CTL: RXEN Mask                     */
S
S#define I2S_CTL_MUTE_Pos                 (3)                                               /*!< I2S CTL: MUTE Position                 */
S#define I2S_CTL_MUTE_Msk                 (0x1ul << I2S_CTL_MUTE_Pos)                       /*!< I2S CTL: MUTE Mask                     */
S
S#define I2S_CTL_WDWIDTH_Pos              (4)                                               /*!< I2S CTL: WDWIDTH Position              */
S#define I2S_CTL_WDWIDTH_Msk              (0x3ul << I2S_CTL_WDWIDTH_Pos)                    /*!< I2S CTL: WDWIDTH Mask                  */
S
S#define I2S_CTL_MONO_Pos                 (6)                                               /*!< I2S CTL: MONO Position                 */
S#define I2S_CTL_MONO_Msk                 (0x1ul << I2S_CTL_MONO_Pos)                       /*!< I2S CTL: MONO Mask                     */
S
S#define I2S_CTL_FORMAT_Pos               (7)                                               /*!< I2S CTL: FORMAT Position               */
S#define I2S_CTL_FORMAT_Msk               (0x1ul << I2S_CTL_FORMAT_Pos)                     /*!< I2S CTL: FORMAT Mask                   */
S
S#define I2S_CTL_SLAVE_Pos                (8)                                               /*!< I2S CTL: SLAVE Position                */
S#define I2S_CTL_SLAVE_Msk                (0x1ul << I2S_CTL_SLAVE_Pos)                      /*!< I2S CTL: SLAVE Mask                    */
S
S#define I2S_CTL_TXTH_Pos                 (9)                                               /*!< I2S CTL: TXTH Position                 */
S#define I2S_CTL_TXTH_Msk                 (0x7ul << I2S_CTL_TXTH_Pos)                       /*!< I2S CTL: TXTH Mask                     */
S
S#define I2S_CTL_RXTH_Pos                 (12)                                              /*!< I2S CTL: RXTH Position                 */
S#define I2S_CTL_RXTH_Msk                 (0x7ul << I2S_CTL_RXTH_Pos)                       /*!< I2S CTL: RXTH Mask                     */
S
S#define I2S_CTL_MCLKEN_Pos               (15)                                              /*!< I2S CTL: MCLKEN Position               */
S#define I2S_CTL_MCLKEN_Msk               (0x1ul << I2S_CTL_MCLKEN_Pos)                     /*!< I2S CTL: MCLKEN Mask                   */
S
S#define I2S_CTL_RZCEN_Pos                (16)                                              /*!< I2S CTL: RZCEN Position                */
S#define I2S_CTL_RZCEN_Msk                (0x1ul << I2S_CTL_RZCEN_Pos)                      /*!< I2S CTL: RZCEN Mask                    */
S
S#define I2S_CTL_LZCEN_Pos                (17)                                              /*!< I2S CTL: LZCEN Position                */
S#define I2S_CTL_LZCEN_Msk                (0x1ul << I2S_CTL_LZCEN_Pos)                      /*!< I2S CTL: LZCEN Mask                    */
S
S#define I2S_CTL_TXCLR_Pos                (18)                                              /*!< I2S CTL: TXCLR Position                */
S#define I2S_CTL_TXCLR_Msk                (0x1ul << I2S_CTL_TXCLR_Pos)                      /*!< I2S CTL: TXCLR Mask                    */
S
S#define I2S_CTL_RXCLR_Pos                (19)                                              /*!< I2S CTL: RXCLR Position                */
S#define I2S_CTL_RXCLR_Msk                (0x1ul << I2S_CTL_RXCLR_Pos)                      /*!< I2S CTL: RXCLR Mask                    */
S
S#define I2S_CTL_TXPDMAEN_Pos             (20)                                              /*!< I2S CTL: TXPDMAEN Position             */
S#define I2S_CTL_TXPDMAEN_Msk             (0x1ul << I2S_CTL_TXPDMAEN_Pos)                   /*!< I2S CTL: TXPDMAEN Mask                 */
S
S#define I2S_CTL_RXPDMAEN_Pos             (21)                                              /*!< I2S CTL: RXPDMAEN Position             */
S#define I2S_CTL_RXPDMAEN_Msk             (0x1ul << I2S_CTL_RXPDMAEN_Pos)                   /*!< I2S CTL: RXPDMAEN Mask                 */
S
S#define I2S_CLKDIV_MCLKDIV_Pos           (0)                                               /*!< I2S CLKDIV: MCLKDIV Position           */
S#define I2S_CLKDIV_MCLKDIV_Msk           (0x7ul << I2S_CLKDIV_MCLKDIV_Pos)                 /*!< I2S CLKDIV: MCLKDIV Mask               */
S
S#define I2S_CLKDIV_BCLKDIV_Pos           (8)                                               /*!< I2S CLKDIV: BCLKDIV Position           */
S#define I2S_CLKDIV_BCLKDIV_Msk           (0xfful << I2S_CLKDIV_BCLKDIV_Pos)                /*!< I2S CLKDIV: BCLKDIV Mask               */
S
S#define I2S_IEN_RXUDIEN_Pos              (0)                                               /*!< I2S IEN: RXUDIEN Position              */
S#define I2S_IEN_RXUDIEN_Msk              (0x1ul << I2S_IEN_RXUDIEN_Pos)                    /*!< I2S IEN: RXUDIEN Mask                  */
S
S#define I2S_IEN_RXOVIEN_Pos              (1)                                               /*!< I2S IEN: RXOVIEN Position              */
S#define I2S_IEN_RXOVIEN_Msk              (0x1ul << I2S_IEN_RXOVIEN_Pos)                    /*!< I2S IEN: RXOVIEN Mask                  */
S
S#define I2S_IEN_RXTHIEN_Pos              (2)                                               /*!< I2S IEN: RXTHIEN Position              */
S#define I2S_IEN_RXTHIEN_Msk              (0x1ul << I2S_IEN_RXTHIEN_Pos)                    /*!< I2S IEN: RXTHIEN Mask                  */
S
S#define I2S_IEN_TXUDIEN_Pos              (8)                                               /*!< I2S IEN: TXUDIEN Position              */
S#define I2S_IEN_TXUDIEN_Msk              (0x1ul << I2S_IEN_TXUDIEN_Pos)                    /*!< I2S IEN: TXUDIEN Mask                  */
S
S#define I2S_IEN_TXOVIEN_Pos              (9)                                               /*!< I2S IEN: TXOVIEN Position              */
S#define I2S_IEN_TXOVIEN_Msk              (0x1ul << I2S_IEN_TXOVIEN_Pos)                    /*!< I2S IEN: TXOVIEN Mask                  */
S
S#define I2S_IEN_TXTHIEN_Pos              (10)                                              /*!< I2S IEN: TXTHIEN Position              */
S#define I2S_IEN_TXTHIEN_Msk              (0x1ul << I2S_IEN_TXTHIEN_Pos)                    /*!< I2S IEN: TXTHIEN Mask                  */
S
S#define I2S_IEN_RZCIEN_Pos               (11)                                              /*!< I2S IEN: RZCIEN Position               */
S#define I2S_IEN_RZCIEN_Msk               (0x1ul << I2S_IEN_RZCIEN_Pos)                     /*!< I2S IEN: RZCIEN Mask                   */
S
S#define I2S_IEN_LZCIEN_Pos               (12)                                              /*!< I2S IEN: LZCIEN Position               */
S#define I2S_IEN_LZCIEN_Msk               (0x1ul << I2S_IEN_LZCIEN_Pos)                     /*!< I2S IEN: LZCIEN Mask                   */
S
S#define I2S_STATUS_I2SIF_Pos             (0)                                               /*!< I2S STATUS: I2SIF Position             */
S#define I2S_STATUS_I2SIF_Msk             (0x1ul << I2S_STATUS_I2SIF_Pos)                   /*!< I2S STATUS: I2SIF Mask                 */
S
S#define I2S_STATUS_RXIF_Pos              (1)                                               /*!< I2S STATUS: RXIF Position              */
S#define I2S_STATUS_RXIF_Msk              (0x1ul << I2S_STATUS_RXIF_Pos)                    /*!< I2S STATUS: RXIF Mask                  */
S
S#define I2S_STATUS_TXIF_Pos              (2)                                               /*!< I2S STATUS: TXIF Position              */
S#define I2S_STATUS_TXIF_Msk              (0x1ul << I2S_STATUS_TXIF_Pos)                    /*!< I2S STATUS: TXIF Mask                  */
S
S#define I2S_STATUS_RIGHT_Pos             (3)                                               /*!< I2S STATUS: RIGHT Position             */
S#define I2S_STATUS_RIGHT_Msk             (0x1ul << I2S_STATUS_RIGHT_Pos)                   /*!< I2S STATUS: RIGHT Mask                 */
S
S#define I2S_STATUS_RXUDIF_Pos            (8)                                               /*!< I2S STATUS: RXUDIF Position            */
S#define I2S_STATUS_RXUDIF_Msk            (0x1ul << I2S_STATUS_RXUDIF_Pos)                  /*!< I2S STATUS: RXUDIF Mask                */
S
S#define I2S_STATUS_RXOVIF_Pos            (9)                                               /*!< I2S STATUS: RXOVIF Position            */
S#define I2S_STATUS_RXOVIF_Msk            (0x1ul << I2S_STATUS_RXOVIF_Pos)                  /*!< I2S STATUS: RXOVIF Mask                */
S
S#define I2S_STATUS_RXTHIF_Pos            (10)                                              /*!< I2S STATUS: RXTHIF Position            */
S#define I2S_STATUS_RXTHIF_Msk            (0x1ul << I2S_STATUS_RXTHIF_Pos)                  /*!< I2S STATUS: RXTHIF Mask                */
S
S#define I2S_STATUS_RXFULL_Pos            (11)                                              /*!< I2S STATUS: RXFULL Position            */
S#define I2S_STATUS_RXFULL_Msk            (0x1ul << I2S_STATUS_RXFULL_Pos)                  /*!< I2S STATUS: RXFULL Mask                */
S
S#define I2S_STATUS_RXEMPTY_Pos           (12)                                              /*!< I2S STATUS: RXEMPTY Position           */
S#define I2S_STATUS_RXEMPTY_Msk           (0x1ul << I2S_STATUS_RXEMPTY_Pos)                 /*!< I2S STATUS: RXEMPTY Mask               */
S
S#define I2S_STATUS_TXUDIF_Pos            (16)                                              /*!< I2S STATUS: TXUDIF Position            */
S#define I2S_STATUS_TXUDIF_Msk            (0x1ul << I2S_STATUS_TXUDIF_Pos)                  /*!< I2S STATUS: TXUDIF Mask                */
S
S#define I2S_STATUS_TXOVIF_Pos            (17)                                              /*!< I2S STATUS: TXOVIF Position            */
S#define I2S_STATUS_TXOVIF_Msk            (0x1ul << I2S_STATUS_TXOVIF_Pos)                  /*!< I2S STATUS: TXOVIF Mask                */
S
S#define I2S_STATUS_TXTHIF_Pos            (18)                                              /*!< I2S STATUS: TXTHIF Position            */
S#define I2S_STATUS_TXTHIF_Msk            (0x1ul << I2S_STATUS_TXTHIF_Pos)                  /*!< I2S STATUS: TXTHIF Mask                */
S
S#define I2S_STATUS_TXFULL_Pos            (19)                                              /*!< I2S STATUS: TXFULL Position            */
S#define I2S_STATUS_TXFULL_Msk            (0x1ul << I2S_STATUS_TXFULL_Pos)                  /*!< I2S STATUS: TXFULL Mask                */
S
S#define I2S_STATUS_TXEMPTY_Pos           (20)                                              /*!< I2S STATUS: TXEMPTY Position           */
S#define I2S_STATUS_TXEMPTY_Msk           (0x1ul << I2S_STATUS_TXEMPTY_Pos)                 /*!< I2S STATUS: TXEMPTY Mask               */
S
S#define I2S_STATUS_TXBUSY_Pos            (21)                                              /*!< I2S STATUS: TXBUSY Position            */
S#define I2S_STATUS_TXBUSY_Msk            (0x1ul << I2S_STATUS_TXBUSY_Pos)                  /*!< I2S STATUS: TXBUSY Mask                */
S
S#define I2S_STATUS_RZCIF_Pos             (22)                                              /*!< I2S STATUS: RZCIF Position             */
S#define I2S_STATUS_RZCIF_Msk             (0x1ul << I2S_STATUS_RZCIF_Pos)                   /*!< I2S STATUS: RZCIF Mask                 */
S
S#define I2S_STATUS_LZCIF_Pos             (23)                                              /*!< I2S STATUS: LZCIF Position             */
S#define I2S_STATUS_LZCIF_Msk             (0x1ul << I2S_STATUS_LZCIF_Pos)                   /*!< I2S STATUS: LZCIF Mask                 */
S
S#define I2S_STATUS_RXCNT_Pos             (24)                                              /*!< I2S STATUS: RXCNT Position             */
S#define I2S_STATUS_RXCNT_Msk             (0xful << I2S_STATUS_RXCNT_Pos)                   /*!< I2S STATUS: RXCNT Mask                 */
S
S#define I2S_STATUS_TXCNT_Pos             (28)                                              /*!< I2S STATUS: TXCNT Position             */
S#define I2S_STATUS_TXCNT_Msk             (0xful << I2S_STATUS_TXCNT_Pos)                   /*!< I2S STATUS: TXCNT Mask                 */
S
S#define I2S_TX_TX_Pos                    (0)                                               /*!< I2S TX: TX Position                    */
S#define I2S_TX_TX_Msk                    (0xfffffffful << I2S_TX_TX_Pos)                   /*!< I2S TX: TX Mask                        */
S
S#define I2S_RX_RX_Pos                    (0)                                               /*!< I2S RX: RX Position                    */
S#define I2S_RX_RX_Msk                    (0xfffffffful << I2S_RX_RX_Pos)                   /*!< I2S RX: RX Mask                        */
S
S/**@}*/ /* I2S_CONST */
S/**@}*/ /* end of I2S register group */
S
S
S/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
S/**
S    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
S    Memory Mapped Structure for PDMA Controller
S@{ */
S 
Stypedef struct
S{
S    /**
S     * DSCT_CTL
S     * ===================================================================================================
S     * Offset: 0x00  PDMA Control Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHEN      |PDMA Channel Enable
S     * |        |          |Setting this bit to 1 enables PDMA's operation.
S     * |        |          |If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
S     * |        |          |Note: SWRST will clear this bit.
S     * |[1]     |SWRST     |Software Engine Reset
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the internal state machine and pointers.
S     * |        |          |The contents of the control register will not be cleared.
S     * |        |          |This bit will auto clear after a few clock cycles.
S     * |[2:3]   |MODESEL   |PDMA Mode Select
S     * |        |          |This parameter selects to transfer direction of the PDMA channel. Possible values are:
S     * |        |          |00 = Memory to Memory mode (SRAM-to-SRAM).
S     * |        |          |01 = IP to Memory mode (APB-to-SRAM).
S     * |        |          |10 = Memory to IP mode (SRAM-to-APB).
S     * |[4:5]   |SASEL     |Source Address Select
S     * |        |          |This parameter determines the behavior of the current source address register with each PDMA transfer.
S     * |        |          |It can either be fixed, incremented or wrapped.
S     * |        |          |00 = Transfer Source address is incremented.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Transfer Source address is fixed
S     * |        |          |11 = Transfer Source address is wrapped.
S     * |        |          |When PDMA_CURBCCHn (Current Byte Count) equals zero, the PDMA_CURSACHn (Current Source Address) and PDMA_CURBCCHn registers will be reloaded from the PDMA_DSCTn_ENDSA (Source Address) and PDMA_TXBCCHn (Byte Count) registers automatically and PDMA will start another transfer.
S     * |        |          |Cycle continues until software sets PDMACKEN = 0.
S     * |        |          |When PDMACKEN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address.
S     * |[6:7]   |DASEL     |Destination Address Select
S     * |        |          |This parameter determines the behavior of the current destination address register with each PDMA transfer.
S     * |        |          |It can either be fixed, incremented or wrapped.
S     * |        |          |00 = Transfer Destination Address is incremented.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input).
S     * |        |          |11 = Transfer Destination Address is wrapped.
S     * |        |          |When PDMA_CURBCCHn (Current Byte Count) equals zero, the PDMA_CURDACHn (Current Destination Address) and PDMA_CURBCCHn registers will be reloaded from the PDMA_DSCTn_ENDDA (Destination Address) and PDMA_TXBCCHn (Byte Count) registers automatically and PDMA will start another transfer.
S     * |        |          |Cycle continues until software sets PDMACKEN=0.
S     * |        |          |When PDMACKEN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address.
S     * |[12:15] |WAINTSEL  |Wrap Interrupt Select
S     * |        |          |x1xx: If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when half each PDMA transfer is complete.
S     * |        |          |For example if BYTECNT = 32 then an interrupt could be generated when 16 bytes were sent.
S     * |        |          |xxx1: If this bit is set, and wraparound mode is in operation a Wrap Interrupt can be generated when each PDMA transfer is wrapped.
S     * |        |          |For example if BYTECNT = 32 then an interrupt could be generated when 32 bytes were sent and PDMA wraps around.
S     * |        |          |x1x1: Both half and w interrupts generated.
S     * |[19:20] |TWIDTH    |Peripheral Transfer Width Select
S     * |        |          |This parameter determines the data width to be transferred each PDMA transfer operation.
S     * |        |          |00 = One word (32 bits) is transferred for every PDMA operation.
S     * |        |          |01 = One byte (8 bits) is transferred for every PDMA operation.
S     * |        |          |10 = One half-word (16 bits) is transferred for every PDMA operation.
S     * |        |          |11 = Reserved.
S     * |        |          |Note: This field is meaningful only when MODESEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).
S     * |[23]    |TXEN      |Trigger Enable - Start a PDMA operation
S     * |        |          |0 = Write: no effect. Read: Idle/Finished.
S     * |        |          |1 = Enable PDMA data read or write transfer.
S     * |        |          |Note: When PDMA transfer completed, this bit will be cleared automatically.
S     * |        |          |If a bus error occurs, all PDMA transfer will be stopped.
S     * |        |          |Software must reset PDMA channel, and then trigger again.
S */
S    __IO uint32_t DSCT_CTL;             
S
S    /**
S     * DSCT_ENDSA
S     * ===================================================================================================
S     * Offset: 0x04  PDMA Transfer Source Address Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |ENDSA     |PDMA Transfer Source Address Register
S     * |        |          |This register holds the initial Source Address of PDMA transfer.
S     * |        |          |Note: The source address must be word aligned.
S */
S    __IO uint32_t DSCT_ENDSA;           
S
S    /**
S     * DSCT_ENDDA
S     * ===================================================================================================
S     * Offset: 0x08  PDMA Transfer Destination Address Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |ENDDA     |PDMA Transfer Destination Address Register
S     * |        |          |This register holds the initial Destination Address of PDMA transfer.
S     * |        |          |Note: The destination address must be word aligned.
S */
S    __IO uint32_t DSCT_ENDDA;           
S
S    /**
S     * TXBCCH
S     * ===================================================================================================
S     * Offset: 0x0C  PDMA Transfer Byte Count Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |BYTECNT   |PDMA Transfer Byte Count Register
S     * |        |          |This register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.
S     * |        |          |Note: When in memory-to-memory (PDMA_DSCTn_CTL.MODESEL = 00b) mode, the transfer byte count must be word aligned, that is multiples of 4bytes.
S */
S    __IO uint32_t TXBCCH;               
S
S    /**
S     * INLBPCH
S     * ===================================================================================================
S     * Offset: 0x10  PDMA Internal Buffer Pointer Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |BUFPTR    |PDMA Internal Buffer Pointer Register (Read Only)
S     * |        |          |A PDMA transaction consists of two stages, a read from the source address and a write to the destination address.
S     * |        |          |Internally this data is buffered in a 32bit register.
S     * |        |          |If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.
S */
S    __I  uint32_t INLBPCH0;              
S
S    /**
S     * CURSACH
S     * ===================================================================================================
S     * Offset: 0x14  PDMA Current Source Address Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |CURSA     |PDMA Current Source Address Register (Read Only)
S     * |        |          |This register returns the source address from which the PDMA transfer is occurring.
S     * |        |          |This register is loaded from PDMA_DSCTn_ENDSA when PDMA is triggered or when a wraparound occurs.
S */
S    __I  uint32_t CURSACH;              
S
S    /**
S     * CURDACH
S     * ===================================================================================================
S     * Offset: 0x18  PDMA Current Destination Address Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |CURDA     |PDMA Current Destination Address Register (Read Only)
S     * |        |          |This register returns the destination address to which the PDMA transfer is occurring.
S     * |        |          |This register is loaded from PDMA_DSCTn_ENDDA when PDMA is triggered or when a wraparound occurs.
S */
S    __I  uint32_t CURDACH;              
S
S    /**
S     * CURBCCH
S     * ===================================================================================================
S     * Offset: 0x1C  PDMA Current Byte Count Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |CURBC     |PDMA Current Byte Count Register (Read Only)
S     * |        |          |This field indicates the current remaining byte count of PDMA transfer.
S     * |        |          |This register is initialized with PDMA_TXBCCHn register when PDMA is triggered or when a wraparound occurs.
S */
S    __I  uint32_t CURBCCH;              
S
S    /**
S     * INTENCH0
S     * ===================================================================================================
S     * Offset: 0x20  PDMA Interrupt Enable Control Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXABTIEN  |PDMA Read/Write Target Abort Interrupt Enable
S     * |        |          |If enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error.
S     * |        |          |If a transfer is aborted, PDMA channel must be reset to resume DMA operation.
S     * |        |          |0 = Disable PDMA transfer target abort interrupt generation.
S     * |        |          |1 = Enable PDMA transfer target abort interrupt generation.
S     * |[1]     |TXOKIEN   |PDMA Transfer Done Interrupt Enable
S     * |        |          |If enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.
S     * |        |          |0 = Disable PDMA transfer done interrupt generation.
S     * |        |          |1 = Enable PDMA transfer done interrupt generation.
S     * |[2]     |WAINTEN   |Wraparound Interrupt Enable
S     * |        |          |If enabled, and channel source or destination address is in wraparound mode, the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of PDMA_DSCTn_CTL.WAINTSEL.
S     * |        |          |This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress.
S     * |        |          |This allows the efficient implementation of circular buffers for DMA.
S     * |        |          |0 = Disable Wraparound PDMA interrupt generation.
S     * |        |          |1 = Enable Wraparound interrupt generation.
S */
S    __IO uint32_t INTENCH;              
S
S    /**
S     * CHIF
S     * ===================================================================================================
S     * Offset: 0x24  PDMA Interrupt Status Register of Channel 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXABTIF   |PDMA Read/Write Target Abort Interrupt Flag
S     * |        |          |This flag indicates a Target Abort interrupt condition has occurred.
S     * |        |          |This condition can happen if attempt is made to read/write from invalid or non-existent memory space.
S     * |        |          |It occurs when PDMA controller receives a bus error from AHB master.
S     * |        |          |Upon occurrence PDMA will stop transfer and go to idle state.
S     * |        |          |To resume, software must reset PDMA channel and initiate transfer again.
S     * |        |          |0 = No bus ERROR response received.
S     * |        |          |1 = Bus ERROR response received.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[1]     |TXOKIF    |Block Transfer Done Interrupt Flag
S     * |        |          |This bit indicates that PDMA block transfer complete interrupt has been generated.
S     * |        |          |It is cleared by writing 1 to the bit.
S     * |        |          |0 = Transfer ongoing or Idle.
S     * |        |          |1 = Transfer Complete.
S     * |[8:11]  |WAIF      |Wrap Around Transfer Byte Count Interrupt Flag
S     * |        |          |These flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met.
S     * |        |          |They are cleared by writing one to the bits.
S     * |        |          |0001 = Current transfer finished flag (CURBC aaaaaa 0).
S     * |        |          |0100 = Current transfer half complete flag (CURBC aaaaaa BYTECNT/2).
S     * |[31]    |INTSTS    |Interrupt Pin Status (Read Only)
S     * |        |          |This bit is the Interrupt pin status of PDMA channel.
S */
S    __IO uint32_t CHIF;                 
S } PDMA_T;
S
Stypedef struct
S{
S    /**
S     * GLOCTL
S     * ===================================================================================================
S     * Offset: 0x000  PDMA Global Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SWRST     |PDMA Software Reset
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the internal state machine and pointers.
S     * |        |          |The contents of control register will not be cleared.
S     * |        |          |This bit will auto clear after several clock cycles.
S     * |        |          |Note: This bit can reset all channels (global reset).
S     * |[8:11]  |CHCKEN    |PDMA Controller Channel Clock Enable Control
S     * |        |          |To enable clock for channel n CHCKEN[n] must be set.
S     * |        |          |CHCKEN[n] = 1: Enable Channel n clock
S     * |        |          |CHCKEN[n] = 0: Disable Channel n clock
S */
S    __IO uint32_t GLOCTL;                
S
S    /**
S     * SVCSEL
S     * ===================================================================================================
S     * Offset: 0x004  PDMA Service Selection Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |SPIRXSEL  |PDMA SPI0 Receive Selection
S     * |        |          |This field defines which PDMA channel is connected to SPI0 peripheral receive (PDMA source) request.
S     * |[4:7]   |SPITXSEL  |PDMA SPI0 Transmit Selection
S     * |        |          |This field defines which PDMA channel is connected to SPI0 peripheral transmit (PDMA destination) request.
S     * |[8:11]  |ADCRXSEL  |PDMA ADC Receive Selection
S     * |        |          |This field defines which PDMA channel is connected to ADC peripheral receive (PDMA source) request.
S     * |[12:15] |DPWMTXSEL |PDMA DPWM Transmit Selection
S     * |        |          |This field defines which PDMA channel is connected to DPWM peripheral transmit (PDMA destination) request.
S     * |[16:19] |UARTRXSEL |PDMA UART0 Receive Selection
S     * |        |          |This field defines which PDMA channel is connected to UART0 peripheral receive (PDMA source) request.
S     * |[20:23] |UARTXSEL  |PDMA UART0 Transmit Selection
S     * |        |          |This field defines which PDMA channel is connected to UART0 peripheral transmit (PDMA destination) request
S     * |[24:27] |I2SRXSEL  |PDMA I2S Receive Selection
S     * |        |          |This field defines which PDMA channel is connected to I2S peripheral receive (PDMA source) request.
S     * |[28:31] |I2STXSEL  |PDMA I2S Transmit Selection
S     * |        |          |This field defines which PDMA channel is connected to I2S peripheral transmit (PDMA destination) request
S */
S    __IO uint32_t SVCSEL;                
S         uint32_t RESERVE4[1];
S
S
S    /**
S     * GLOBALIF
S     * ===================================================================================================
S     * Offset: 0x00C  PDMA Global Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |GLOBALIF  |Interrupt Pin Status (Read Only)
S     * |        |          |GLOBALIF[n] is the interrupt status of PDMA channel n.
S */
S    __I  uint32_t GLOBALIF;              
S
S} PDMA_GCR_T;
S
S/**
S    @addtogroup PDMA_CONST PDMA Bit Field Definition
S    Constant Definitions for PDMA Controller
S@{ */
S
S#define PDMA_DSCT_CTL_CHEN_Pos          (0)                                               /*!< PDMA DSCT0_CTL: CHEN Position          */
S#define PDMA_DSCT_CTL_CHEN_Msk          (0x1ul << PDMA_DSCT_CTL_CHEN_Pos)                /*!< PDMA DSCT0_CTL: CHEN Mask              */
S
S#define PDMA_DSCT_CTL_SWRST_Pos         (1)                                               /*!< PDMA DSCT0_CTL: SWRST Position         */
S#define PDMA_DSCT_CTL_SWRST_Msk         (0x1ul << PDMA_DSCT_CTL_SWRST_Pos)               /*!< PDMA DSCT0_CTL: SWRST Mask             */
S
S#define PDMA_DSCT_CTL_MODESEL_Pos       (2)                                               /*!< PDMA DSCT0_CTL: MODESEL Position       */
S#define PDMA_DSCT_CTL_MODESEL_Msk       (0x3ul << PDMA_DSCT_CTL_MODESEL_Pos)             /*!< PDMA DSCT0_CTL: MODESEL Mask           */
S
S#define PDMA_DSCT_CTL_SASEL_Pos         (4)                                               /*!< PDMA DSCT0_CTL: SASEL Position         */
S#define PDMA_DSCT_CTL_SASEL_Msk         (0x3ul << PDMA_DSCT_CTL_SASEL_Pos)               /*!< PDMA DSCT0_CTL: SASEL Mask             */
S
S#define PDMA_DSCT_CTL_DASEL_Pos         (6)                                               /*!< PDMA DSCT0_CTL: DASEL Position         */
S#define PDMA_DSCT_CTL_DASEL_Msk         (0x3ul << PDMA_DSCT_CTL_DASEL_Pos)               /*!< PDMA DSCT0_CTL: DASEL Mask             */
S
S#define PDMA_DSCT_CTL_WAINTSEL_Pos      (12)                                              /*!< PDMA DSCT0_CTL: WAINTSEL Position      */
S#define PDMA_DSCT_CTL_WAINTSEL_Msk      (0xful << PDMA_DSCT_CTL_WAINTSEL_Pos)            /*!< PDMA DSCT0_CTL: WAINTSEL Mask          */
S
S#define PDMA_DSCT_CTL_TXWIDTH_Pos        (19)                                              /*!< PDMA DSCT0_CTL: TWIDTH Position        */
S#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< PDMA DSCT0_CTL: TWIDTH Mask            */
S
S#define PDMA_DSCT_CTL_TXEN_Pos          (23)                                              /*!< PDMA DSCT0_CTL: TXEN Position          */
S#define PDMA_DSCT_CTL_TXEN_Msk          (0x1ul << PDMA_DSCT_CTL_TXEN_Pos)                /*!< PDMA DSCT0_CTL: TXEN Mask              */
S
S#define PDMA_DSCT_ENDSA_ENDSA_Pos       (0)                                               /*!< PDMA DSCT0_ENDSA: ENDSA Position       */
S#define PDMA_DSCT_ENDSA_ENDSA_Msk       (0xfffffffful << PDMA_DSCT_ENDSA_ENDSA_Pos)      /*!< PDMA DSCT0_ENDSA: ENDSA Mask           */
S
S#define PDMA_DSCT_ENDDA_ENDDA_Pos       (0)                                               /*!< PDMA DSCT0_ENDDA: ENDDA Position       */
S#define PDMA_DSCT_ENDDA_ENDDA_Msk       (0xfffffffful << PDMA_DSCT_ENDDA_ENDDA_Pos)      /*!< PDMA DSCT0_ENDDA: ENDDA Mask           */
S
S#define PDMA_TXBCCH_BYTECNT_Pos         (0)                                               /*!< PDMA TXBCCH0: BYTECNT Position         */
S#define PDMA_TXBCCH_BYTECNT_Msk         (0xfffful << PDMA_TXBCCH_BYTECNT_Pos)            /*!< PDMA TXBCCH0: BYTECNT Mask             */
S
S#define PDMA_INLBPCH_BUFPTR_Pos         (0)                                               /*!< PDMA INLBPCH0: BUFPTR Position         */
S#define PDMA_INLBPCH_BUFPTR_Msk         (0xful << PDMA_INLBPCH_BUFPTR_Pos)               /*!< PDMA INLBPCH0: BUFPTR Mask             */
S
S#define PDMA_CURSACH_CURSA_Pos          (0)                                               /*!< PDMA CURSACH0: CURSA Position          */
S#define PDMA_CURSACH_CURSA_Msk          (0xfffffffful << PDMA_CURSACH_CURSA_Pos)         /*!< PDMA CURSACH0: CURSA Mask              */
S
S#define PDMA_CURDACH_CURDA_Pos          (0)                                               /*!< PDMA CURDACH0: CURDA Position          */
S#define PDMA_CURDACH_CURDA_Msk          (0xfffffffful << PDMA_CURDACH_CURDA_Pos)         /*!< PDMA CURDACH0: CURDA Mask              */
S
S#define PDMA_CURBCCH_CURBC_Pos          (0)                                               /*!< PDMA CURBCCH0: CURBC Position          */
S#define PDMA_CURBCCH_CURBC_Msk          (0xfffful << PDMA_CURBCCH_CURBC_Pos)             /*!< PDMA CURBCCH0: CURBC Mask              */
S
S#define PDMA_INTENCH_TXABTIEN_Pos       (0)                                               /*!< PDMA INTENCH0: TXABTIEN Position       */
S#define PDMA_INTENCH_TXABTIEN_Msk       (0x1ul << PDMA_INTENCH_TXABTIEN_Pos)             /*!< PDMA INTENCH0: TXABTIEN Mask           */
S
S#define PDMA_INTENCH_TXOKIEN_Pos        (1)                                               /*!< PDMA INTENCH0: TXOKIEN Position        */
S#define PDMA_INTENCH_TXOKIEN_Msk        (0x1ul << PDMA_INTENCH_TXOKIEN_Pos)              /*!< PDMA INTENCH0: TXOKIEN Mask            */
S
S#define PDMA_INTENCH_WAINTEN_Pos        (2)                                               /*!< PDMA INTENCH0: WAINTEN Position        */
S#define PDMA_INTENCH_WAINTEN_Msk        (0x1ul << PDMA_INTENCH_WAINTEN_Pos)              /*!< PDMA INTENCH0: WAINTEN Mask            */
S
S#define PDMA_CHIF_TXABTIF_Pos           (0)                                               /*!< PDMA CH0IF: TXABTIF Position           */
S#define PDMA_CHIF_TXABTIF_Msk           (0x1ul << PDMA_CHIF_TXABTIF_Pos)                 /*!< PDMA CH0IF: TXABTIF Mask               */
S
S#define PDMA_CHIF_TXOKIF_Pos            (1)                                               /*!< PDMA CH0IF: TXOKIF Position            */
S#define PDMA_CHIF_TXOKIF_Msk            (0x1ul << PDMA_CHIF_TXOKIF_Pos)                  /*!< PDMA CH0IF: TXOKIF Mask                */
S
S#define PDMA_CHIF_WAIF_Pos              (8)                                               /*!< PDMA CH0IF: WAIF Position              */
S#define PDMA_CHIF_WAIF_Msk              (0xful << PDMA_CHIF_WAIF_Pos)                    /*!< PDMA CH0IF: WAIF Mask                  */
S
S#define PDMA_CHIF_INTSTS_Pos            (31)                                              /*!< PDMA CH0IF: INTSTS Position            */
S#define PDMA_CHIF_INTSTS_Msk            (0x1ul << PDMA_CHIF_INTSTS_Pos)                  /*!< PDMA CH0IF: INTSTS Mask                */
S
S#define PDMA_GLOCTL_SWRST_Pos            (0)                                               /*!< PDMA GLOCTL: SWRST Position            */
S#define PDMA_GLOCTL_SWRST_Msk            (0x1ul << PDMA_GLOCTL_SWRST_Pos)                  /*!< PDMA GLOCTL: SWRST Mask                */
S
S#define PDMA_GLOCTL_CHCKEN_Pos           (8)                                               /*!< PDMA GLOCTL: CHCKEN Position           */
S#define PDMA_GLOCTL_CHCKEN_Msk           (0xful << PDMA_GLOCTL_CHCKEN_Pos)                 /*!< PDMA GLOCTL: CHCKEN Mask               */
S
S#define PDMA_SVCSEL_SPIRXSEL_Pos         (0)                                               /*!< PDMA SVCSEL: SPIRXSEL Position         */
S#define PDMA_SVCSEL_SPIRXSEL_Msk         (0xful << PDMA_SVCSEL_SPIRXSEL_Pos)               /*!< PDMA SVCSEL: SPIRXSEL Mask             */
S
S#define PDMA_SVCSEL_SPITXSEL_Pos         (4)                                               /*!< PDMA SVCSEL: SPITXSEL Position         */
S#define PDMA_SVCSEL_SPITXSEL_Msk         (0xful << PDMA_SVCSEL_SPITXSEL_Pos)               /*!< PDMA SVCSEL: SPITXSEL Mask             */
S
S#define PDMA_SVCSEL_ADCRXSEL_Pos         (8)                                               /*!< PDMA SVCSEL: ADCRXSEL Position         */
S#define PDMA_SVCSEL_ADCRXSEL_Msk         (0xful << PDMA_SVCSEL_ADCRXSEL_Pos)               /*!< PDMA SVCSEL: ADCRXSEL Mask             */
S
S#define PDMA_SVCSEL_DPWMTXSEL_Pos        (12)                                              /*!< PDMA SVCSEL: DPWMTXSEL Position        */
S#define PDMA_SVCSEL_DPWMTXSEL_Msk        (0xful << PDMA_SVCSEL_DPWMTXSEL_Pos)              /*!< PDMA SVCSEL: DPWMTXSEL Mask            */
S
S#define PDMA_SVCSEL_UARTRXSEL_Pos        (16)                                              /*!< PDMA SVCSEL: UARTRXSEL Position        */
S#define PDMA_SVCSEL_UARTRXSEL_Msk        (0xful << PDMA_SVCSEL_UARTRXSEL_Pos)              /*!< PDMA SVCSEL: UARTRXSEL Mask            */
S
S#define PDMA_SVCSEL_UARTXSEL_Pos         (20)                                              /*!< PDMA SVCSEL: UARTXSEL Position         */
S#define PDMA_SVCSEL_UARTXSEL_Msk         (0xful << PDMA_SVCSEL_UARTXSEL_Pos)               /*!< PDMA SVCSEL: UARTXSEL Mask             */
S
S#define PDMA_SVCSEL_I2SRXSEL_Pos         (24)                                              /*!< PDMA SVCSEL: I2SRXSEL Position         */
S#define PDMA_SVCSEL_I2SRXSEL_Msk         (0xful << PDMA_SVCSEL_I2SRXSEL_Pos)               /*!< PDMA SVCSEL: I2SRXSEL Mask             */
S
S#define PDMA_SVCSEL_I2STXSEL_Pos         (28)                                              /*!< PDMA SVCSEL: I2STXSEL Position         */
S#define PDMA_SVCSEL_I2STXSEL_Msk         (0xful << PDMA_SVCSEL_I2STXSEL_Pos)               /*!< PDMA SVCSEL: I2STXSEL Mask             */
S
S#define PDMA_GLOBALIF_GLOBALIF_Pos       (0)                                               /*!< PDMA GLOBALIF: GLOBALIF Position       */
S#define PDMA_GLOBALIF_GLOBALIF_Msk       (0xful << PDMA_GLOBALIF_GLOBALIF_Pos)             /*!< PDMA GLOBALIF: GLOBALIF Mask           */
S
S/**@}*/ /* PDMA_CONST */
S/**@}*/ /* end of PDMA register group */
S
S
S/*---------------------- Pulse Width Modulation Controller -------------------------*/
S/**
S    @addtogroup PWM Pulse Width Modulation Controller(PWM)
S    Memory Mapped Structure for PWM Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CLKPSC
S     * ===================================================================================================
S     * Offset: 0x00  PWM Prescaler Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |CLKPSC01  |Clock Pre-scaler For Pair Of PWM CH0 and CH1
S     * |        |          |Clock input is divided by (CLKPSC01 + 1).
S     * |        |          |If CLKPSC01 = 0, then the pre-scaler output clock will be stopped.
S     * |        |          |This implies PWM counter 0 and 1 will also be stopped.
S     * |[16:23] |DTCNT01   |Dead Zone Interval Register For Pair Of PWM CH0 and CH1
S     * |        |          |These 8 bits determine dead zone length.
S     * |        |          |The unit time of dead zone length is that from clock selector 0.
S */
S    __IO uint32_t CLKPSC;                
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x04  PWM Clock Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |CLKDIV0   |Timer 0 Clock Source Selection
S     * |        |          |(Table is as CLKDIV1)
S     * |[4:6]   |CLKDIV1   |Timer 1 Clock Source Selection
S     * |        |          |Value : Input clock divided by
S     * |        |          |0 : 2
S     * |        |          |1 : 4
S     * |        |          |2 : 8
S     * |        |          |3 : 16
S     * |        |          |4 : 1
S */
S    __IO uint32_t CLKDIV;                
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x08  PWM Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTEN0    |PWM-Timer 0 Enable/Disable Start Run
S     * |        |          |0 = Stop PWM-Timer 0 Running
S     * |        |          |1 = Enable PWM-Timer 0 Start/Run
S     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF
S     * |        |          |0 = Inverter OFF
S     * |        |          |1 = Inverter ON
S     * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |Note: A rising transition of this bit will cause PWM_PERIOD0 and PWM_CMPDAT0 to be cleared.
S     * |[4]     |DTEN01    |Dead-Zone 0 Generator Enable/Disable
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM CH0 and CH1 become a complementary pair.
S     * |[8]     |CNTEN1    |PWM-Timer 1 Enable/Disable Start Run
S     * |        |          |0 = Stop PWM-Timer 1
S     * |        |          |1 = Enable PWM-Timer 1 Start/Run
S     * |[10]    |PINV1     |PWM-Timer 1 Output Inverter ON/OFF
S     * |        |          |0 = Inverter OFF
S     * |        |          |1 = Inverter ON
S     * |[11]    |CNTMODE1  |PWM-Timer 1 Auto-reload/One-Shot Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |1 = Auto-load Mode
S     * |        |          |Note: A rising transition of this bit will cause PWM_PERIOD1 and PWM_CMPDAT1 to be cleared.
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * PERIOD0
S     * ===================================================================================================
S     * Offset: 0x0C  PWM Counter Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |PERIOD    |PWM Counter/Timer Reload Value
S     * |        |          |PERIOD determines the PWM period.
S     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
S     * |        |          |Duty ratio = (CMP+1)/(PERIOD+1).
S     * |        |          |CMP > = PERIOD: PWM output is always high.
S     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
S     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
S     * |        |          |(Unit = one PWM clock cycle)
S     * |        |          |Note:
S     * |        |          |Any write to PERIOD will take effect in next PWM cycle.
S */
S    __IO uint32_t PERIOD0;               
S
S    /**
S     * CMPDAT0
S     * ===================================================================================================
S     * Offset: 0x10  PWM Comparator Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |CMP       |PWM Comparator Register
S     * |        |          |CMP determines the PWM duty cycle.
S     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
S     * |        |          |Duty Cycle = (CMP+1)/(PERIOD+1).
S     * |        |          |CMP > = PERIOD: PWM output is always high.
S     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
S     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
S     * |        |          |(Unit = one PWM clock cycle)
S     * |        |          |Note: Any write to CMP will take effect in next PWM cycle.
S */
S    __IO uint32_t CMPDAT0;               
S
S    /**
S     * CNT0
S     * ===================================================================================================
S     * Offset: 0x14  PWM Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |CNT       |PWM Data Register
S     * |        |          |Reports the current value of the 16-bit down counter.
S */
S    __I  uint32_t CNT0;                  
S
S    /**
S     * PERIOD1
S     * ===================================================================================================
S     * Offset: 0x18  PWM Counter Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |PERIOD    |PWM Counter/Timer Reload Value
S     * |        |          |PERIOD determines the PWM period.
S     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
S     * |        |          |Duty ratio = (CMP+1)/(PERIOD+1).
S     * |        |          |CMP > = PERIOD: PWM output is always high.
S     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
S     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
S     * |        |          |(Unit = one PWM clock cycle)
S     * |        |          |Note:
S     * |        |          |Any write to PERIOD will take effect in next PWM cycle.
S */
S    __IO uint32_t PERIOD1;               
S
S    /**
S     * CMPDAT1
S     * ===================================================================================================
S     * Offset: 0x1C  PWM Comparator Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |CMP       |PWM Comparator Register
S     * |        |          |CMP determines the PWM duty cycle.
S     * |        |          |PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(PERIOD+1)
S     * |        |          |Duty Cycle = (CMP+1)/(PERIOD+1).
S     * |        |          |CMP > = PERIOD: PWM output is always high.
S     * |        |          |CMP < PERIOD: PWM low width = (PERIOD-CMP) unit; PWM high width = (CMP+1) unit.
S     * |        |          |CMP = 0: PWM low width = (PERIOD) unit; PWM high width = 1 unit
S     * |        |          |(Unit = one PWM clock cycle)
S     * |        |          |Note: Any write to CMP will take effect in next PWM cycle.
S */
S    __IO uint32_t CMPDAT1;               
S
S    /**
S     * CNT1
S     * ===================================================================================================
S     * Offset: 0x20  PWM Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |CNT       |PWM Data Register
S     * |        |          |Reports the current value of the 16-bit down counter.
S */
S    __I  uint32_t CNT1;                  
S         uint32_t RESERVE0[7];
S
S
S    /**
S     * INTEN
S     * ===================================================================================================
S     * Offset: 0x40  PWM Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PIEN0     |PWM Timer 0 Interrupt Enable
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable 
S     * |[1]     |PIEN1     |PWM Timer 1 Interrupt Enable
S     * |        |          |0 = Disable
S     * |        |          |1 = Enable
S */
S    __IO uint32_t INTEN;                 
S
S    /**
S     * INTSTS
S     * ===================================================================================================
S     * Offset: 0x44  PWM Interrupt Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PIF0      |PWM Timer 0 Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM CH0 down counter reaches zero, software can clear this bit by writing '1' to it.
S     * |[1]     |PIF1      |PWM Timer 1 Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM CH1 down counter reaches zero, software can clear this bit by writing '1' to it.
S */
S    __IO uint32_t INTSTS;                
S         uint32_t RESERVE1[2];
S
S
S    /**
S     * CAPCTL01
S     * ===================================================================================================
S     * Offset: 0x50  Capture Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CAPINV0   |Channel 0 Inverter ON/OFF
S     * |        |          |0 = Inverter OFF
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before Capture timer
S     * |[1]     |CRLIEN0   |Channel 0 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |1 = Enable rising latch interrupt.
S     * |        |          |When enabled, capture block generates an interrupt on rising edge of input.
S     * |[2]     |CFLIEN0   |Channel 0 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |1 = Enable falling latch interrupt.
S     * |        |          |When enabled, capture block generates an interrupt on falling edge of input.
S     * |[3]     |CAPEN0    |Capture Channel 0 transition Enable/Disable
S     * |        |          |0 = Disable capture function on channel 0
S     * |        |          |1 = Enable capture function on channel 0.
S     * |        |          |When enabled, Capture function latches the PMW-counter to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers on input edge transition.
S     * |        |          |When disabled, Capture function is inactive as is interrupt.
S     * |[4]     |CAPIF0    |Capture0 Interrupt Indication Flag
S     * |        |          |If channel 0 rising latch interrupt is enabled (CRLIEN0 = 1), a rising transition at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt is enabled (CFLIEN0 = 1).
S     * |        |          |This flag is cleared by software writing a '1' to it.
S     * |[6]     |CRLIF0    |PWM_RCAPDAT0 Latched Indicator Bit
S     * |        |          |When input channel 0 has a rising transition, PWM_RCAPDAT0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.
S     * |[7]     |CFLIF0    |PWM_FCAPDAT0 Latched Indicator Bit
S     * |        |          |When input channel 0 has a falling transition, PWM_FCAPDAT0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it
S     * |[16]    |CAPINV1   |Channel 1 Inverter ON/OFF
S     * |        |          |0 = Inverter OFF
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before Capture timer
S     * |[17]    |CRLIEN1   |Channel 1 Rising Latch Interrupt Enable
S     * |        |          |0 = Disable rising edge latch interrupt
S     * |        |          |1 = Enable rising edge latch interrupt.
S     * |        |          |When enabled, capture block generates an interrupt on rising edge of input.
S     * |[18]    |CFLIEN1   |Channel 1 Falling Latch Interrupt Enable
S     * |        |          |0 = Disable falling edge latch interrupt
S     * |        |          |1 = Enable falling edge latch interrupt.
S     * |        |          |When enabled, capture block generates an interrupt on falling edge of input.
S     * |[19]    |CAPEN1    |Capture Channel 1 Transition Enable/Disable
S     * |        |          |0 = Disable capture function on channel 1
S     * |        |          |1 = Enable capture function on channel 1.
S     * |        |          |When enabled, Capture function latches the PMW-counter to RCAPDAT (Rising latch) and FCAPDAT (Falling latch) registers on input edge transition.
S     * |        |          |When disabled, Capture function is inactive as is interrupt.
S     * |[20]    |CAPIF1    |Capture1 Interrupt Indication Flag
S     * |        |          |If channel 1 rising latch interrupt is enabled (CRLIEN1 = 1), a rising transition at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt is enabled (CFLIEN1 = 1).
S     * |        |          |This flag is cleared by software writing a '1' to it.
S     * |[22]    |CRLIF1    |PWM_RCAPDAT1 Latched Indicator Bit
S     * |        |          |When input channel 1 has a rising transition, PWM_RCAPDAT1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it.
S     * |[23]    |CFLIF1    |PWM_FCAPDAT1 Latched Indicator Bit
S     * |        |          |When input channel 1 has a falling transition, PWM_FCAPDAT1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing a zero to it
S */
S    __IO uint32_t CAPCTL01;              
S         uint32_t RESERVE2[1];
S
S
S    /**
S     * RCAPDAT0
S     * ===================================================================================================
S     * Offset: 0x58  Capture Rising Latch Register (Channel 0)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
S     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a rising edge of the input signal.
S */
S    __I  uint32_t RCAPDAT0;              
S
S    /**
S     * FCAPDAT0
S     * ===================================================================================================
S     * Offset: 0x5C  Capture Falling Latch Register (Channel 0)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
S     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a falling edge of the input signal.
S */
S    __I  uint32_t FCAPDAT0;              
S
S    /**
S     * RCAPDAT1
S     * ===================================================================================================
S     * Offset: 0x60  Capture Rising Latch Register (Channel 1)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |RCAPDAT   |Capture Rising Latch Register
S     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a rising edge of the input signal.
S */
S    __I  uint32_t RCAPDAT1;              
S
S    /**
S     * FCAPDAT1
S     * ===================================================================================================
S     * Offset: 0x64  Capture Falling Latch Register (Channel 1)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |FCAPDAT   |Capture Falling Latch Register
S     * |        |          |In Capture mode, this register is latched with the value of the PWM counter on a falling edge of the input signal.
S */
S    __I  uint32_t FCAPDAT1;              
S         uint32_t RESERVE3[4];
S
S
S    /**
S     * CAPINEN
S     * ===================================================================================================
S     * Offset: 0x78  Capture Input Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |CAPINEN   |Capture Input Enable Register
S     * |        |          |0 : OFF (PA[13:12] pin input disconnected from Capture block)
S     * |        |          |1 : ON (PA[13:12] pin, if in PWM alternative function, will be configured as an input and fed to capture function)
S     * |        |          |CAPINEN[1:0]
S     * |        |          |Bit 10
S     * |        |          |Bit x1 : Capture channel 0 is from PA [12]
S     * |        |          |Bit 1x : Capture channel 1 is from PA [13] 
S */
S    __IO uint32_t CAPINEN;               
S
S    /**
S     * POEN
S     * ===================================================================================================
S     * Offset: 0x7C  PWM Output Enable Register for PWM CH0~1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |POEN0     |PWM CH0 Output Enable Register
S     * |        |          |0 = Disable PWM CH0 output to pin.
S     * |        |          |1 = Enable PWM CH0 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function (refer to SYS_GPA_MFP Table 5-7)
S     * |[1]     |POEN1     |PWM CH1 Output Enable Register
S     * |        |          |0 = Disable PWM CH1 output to pin.
S     * |        |          |1 = Enable PWM CH1 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function (refer to SYS_GPA_MFP Table 5-7)
S */
S    __IO uint32_t POEN;                  
S
S} PWM_T;
S
S/**
S    @addtogroup PWM_CONST PWM Bit Field Definition
S    Constant Definitions for PWM Controller
S@{ */
S
S#define PWM_CLKPSC_CLKPSC01_Pos          (0)                                               /*!< PWM CLKPSC: CLKPSC01 Position          */
S#define PWM_CLKPSC_CLKPSC01_Msk          (0xfful << PWM_CLKPSC_CLKPSC01_Pos)               /*!< PWM CLKPSC: CLKPSC01 Mask              */
S
S#define PWM_CLKPSC_DTCNT01_Pos           (16)                                              /*!< PWM CLKPSC: DTCNT01 Position           */
S#define PWM_CLKPSC_DTCNT01_Msk           (0xfful << PWM_CLKPSC_DTCNT01_Pos)                /*!< PWM CLKPSC: DTCNT01 Mask               */
S
S#define PWM_CLKDIV_CLKDIV0_Pos           (0)                                               /*!< PWM CLKDIV: CLKDIV0 Position           */
S#define PWM_CLKDIV_CLKDIV0_Msk           (0x7ul << PWM_CLKDIV_CLKDIV0_Pos)                 /*!< PWM CLKDIV: CLKDIV0 Mask               */
S
S#define PWM_CLKDIV_CLKDIV1_Pos           (4)                                               /*!< PWM CLKDIV: CLKDIV1 Position           */
S#define PWM_CLKDIV_CLKDIV1_Msk           (0x7ul << PWM_CLKDIV_CLKDIV1_Pos)                 /*!< PWM CLKDIV: CLKDIV1 Mask               */
S
S#define PWM_CTL_CNTEN0_Pos               (0)                                               /*!< PWM CTL: CNTEN0 Position               */
S#define PWM_CTL_CNTEN0_Msk               (0x1ul << PWM_CTL_CNTEN0_Pos)                     /*!< PWM CTL: CNTEN0 Mask                   */
S
S#define PWM_CTL_PINV0_Pos          	     (2)                                               /*!< PWM CTL: PINV0 Position               */
S#define PWM_CTL_PINV0_Msk           	   (0x1ul << PWM_CTL_PINV0_Pos)       	             /*!< PWM CTL: PINV0 Mask                   */
S
S#define PWM_CTL_CNTMODE0_Pos             (3)                                               /*!< PWM CTL: CNTMODE0 Position               */
S#define PWM_CTL_CNTMODE0_Msk             (0x1ul << PWM_CTL_CNTMODE0_Pos)                   /*!< PWM CTL: CNTMODE0 Mask                   */
S
S#define PWM_CTL_DTEN01_Pos               (4)                                               /*!< PWM CTL: DTEN01 Position               */
S#define PWM_CTL_DTEN01_Msk               (0x1ul << PWM_CTL_DTEN01_Pos)                     /*!< PWM CTL: DTEN01 Mask                   */
S
S#define PWM_CTL_CNTEN1_Pos               (8)                                               /*!< PWM CTL: CNTEN1 Position               */
S#define PWM_CTL_CNTEN1_Msk               (0x1ul << PWM_CTL_CNTEN1_Pos)                     /*!< PWM CTL: CNTEN1 Mask                   */
S
S#define PWM_CTL_PINV1_Pos                (10)                                              /*!< PWM CTL: PINV1 Position                */
S#define PWM_CTL_PINV1_Msk                (0x1ul << PWM_CTL_PINV1_Pos)                      /*!< PWM CTL: PINV1 Mask                    */
S
S#define PWM_CTL_CNTMODE1_Pos             (11)                                              /*!< PWM CTL: CNTMODE1 Position             */
S#define PWM_CTL_CNTMODE1_Msk             (0x1ul << PWM_CTL_CNTMODE1_Pos)                   /*!< PWM CTL: CNTMODE1 Mask                 */
S
S#define PWM_PERIOD0_PERIOD_Pos           (0)                                               /*!< PWM PERIOD0: PERIOD Position           */
S#define PWM_PERIOD0_PERIOD_Msk           (0xfffful << PWM_PERIOD0_PERIOD_Pos)              /*!< PWM PERIOD0: PERIOD Mask               */
S
S#define PWM_CMPDAT0_CMP_Pos              (0)                                               /*!< PWM CMPDAT0: CMP Position              */
S#define PWM_CMPDAT0_CMP_Msk              (0xfffful << PWM_CMPDAT0_CMP_Pos)                 /*!< PWM CMPDAT0: CMP Mask                  */
S
S#define PWM_CNT0_CNT_Pos                 (0)                                               /*!< PWM CNT0: CNT Position                 */
S#define PWM_CNT0_CNT_Msk                 (0xfffful << PWM_CNT0_CNT_Pos)                    /*!< PWM CNT0: CNT Mask                     */
S
S#define PWM_PERIOD1_PERIOD_Pos           (0)                                               /*!< PWM PERIOD1: PERIOD Position           */
S#define PWM_PERIOD1_PERIOD_Msk           (0xfffful << PWM_PERIOD1_PERIOD_Pos)              /*!< PWM PERIOD1: PERIOD Mask               */
S
S#define PWM_CMPDAT1_CMP_Pos              (0)                                               /*!< PWM CMPDAT1: CMP Position              */
S#define PWM_CMPDAT1_CMP_Msk              (0xfffful << PWM_CMPDAT1_CMP_Pos)                 /*!< PWM CMPDAT1: CMP Mask                  */
S
S#define PWM_CNT1_CNT_Pos                 (0)                                               /*!< PWM CNT1: CNT Position                 */
S#define PWM_CNT1_CNT_Msk                 (0xfffful << PWM_CNT1_CNT_Pos)                    /*!< PWM CNT1: CNT Mask                     */
S
S#define PWM_INTEN_PIEN0_Pos              (0)                                               /*!< PWM INTEN: PIEN0 Position              */
S#define PWM_INTEN_PIEN0_Msk              (0x1ul << PWM_INTEN_PIEN0_Pos)                    /*!< PWM INTEN: PIEN0 Mask                  */
S
S#define PWM_INTEN_PIEN1_Pos              (1)                                               /*!< PWM INTEN: PIEN1 Position              */
S#define PWM_INTEN_PIEN1_Msk              (0x1ul << PWM_INTEN_PIEN1_Pos)                    /*!< PWM INTEN: PIEN1 Mask                  */
S
S#define PWM_INTSTS_PIF0_Pos              (0)                                               /*!< PWM INTSTS: PIF0 Position              */
S#define PWM_INTSTS_PIF0_Msk              (0x1ul << PWM_INTSTS_PIF0_Pos)                    /*!< PWM INTSTS: PIF0 Mask                  */
S
S#define PWM_INTSTS_PIF1_Pos              (1)                                               /*!< PWM INTSTS: PIF1 Position              */
S#define PWM_INTSTS_PIF1_Msk              (0x1ul << PWM_INTSTS_PIF1_Pos)                    /*!< PWM INTSTS: PIF1 Mask                  */
S
S#define PWM_CAPCTL01_CAPINV0_Pos         (0)                                               /*!< PWM CAPCTL01: CAPINV0 Position         */
S#define PWM_CAPCTL01_CAPINV0_Msk         (0x1ul << PWM_CAPCTL01_CAPINV0_Pos)               /*!< PWM CAPCTL01: CAPINV0 Mask             */
S
S#define PWM_CAPCTL01_CRLIEN0_Pos         (1)                                               /*!< PWM CAPCTL01: CRLIEN0 Position         */
S#define PWM_CAPCTL01_CRLIEN0_Msk         (0x1ul << PWM_CAPCTL01_CRLIEN0_Pos)               /*!< PWM CAPCTL01: CRLIEN0 Mask             */
S
S#define PWM_CAPCTL01_CFLIEN0_Pos         (2)                                               /*!< PWM CAPCTL01: CFLIEN0 Position         */
S#define PWM_CAPCTL01_CFLIEN0_Msk         (0x1ul << PWM_CAPCTL01_CFLIEN0_Pos)               /*!< PWM CAPCTL01: CFLIEN0 Mask             */
S
S#define PWM_CAPCTL01_CAPEN0_Pos          (3)                                               /*!< PWM CAPCTL01: CAPEN0 Position          */
S#define PWM_CAPCTL01_CAPEN0_Msk          (0x1ul << PWM_CAPCTL01_CAPEN0_Pos)                /*!< PWM CAPCTL01: CAPEN0 Mask              */
S
S#define PWM_CAPCTL01_CAPIF0_Pos          (4)                                               /*!< PWM CAPCTL01: CAPIF0 Position          */
S#define PWM_CAPCTL01_CAPIF0_Msk          (0x1ul << PWM_CAPCTL01_CAPIF0_Pos)                /*!< PWM CAPCTL01: CAPIF0 Mask              */
S
S#define PWM_CAPCTL01_CRLIF0_Pos          (6)                                               /*!< PWM CAPCTL01: CRLIF0 Position          */
S#define PWM_CAPCTL01_CRLIF0_Msk          (0x1ul << PWM_CAPCTL01_CRLIF0_Pos)                /*!< PWM CAPCTL01: CRLIF0 Mask              */
S
S#define PWM_CAPCTL01_CFLIF0_Pos          (7)                                               /*!< PWM CAPCTL01: CFLIF0 Position          */
S#define PWM_CAPCTL01_CFLIF0_Msk          (0x1ul << PWM_CAPCTL01_CFLIF0_Pos)                /*!< PWM CAPCTL01: CFLIF0 Mask              */
S
S#define PWM_CAPCTL01_CAPINV1_Pos         (16)                                              /*!< PWM CAPCTL01: CAPINV1 Position         */
S#define PWM_CAPCTL01_CAPINV1_Msk         (0x1ul << PWM_CAPCTL01_CAPINV1_Pos)               /*!< PWM CAPCTL01: CAPINV1 Mask             */
S
S#define PWM_CAPCTL01_CRLIEN1_Pos         (17)                                              /*!< PWM CAPCTL01: CRLIEN1 Position         */
S#define PWM_CAPCTL01_CRLIEN1_Msk         (0x1ul << PWM_CAPCTL01_CRLIEN1_Pos)               /*!< PWM CAPCTL01: CRLIEN1 Mask             */
S
S#define PWM_CAPCTL01_CFLIEN1_Pos         (18)                                              /*!< PWM CAPCTL01: CFLIEN1 Position         */
S#define PWM_CAPCTL01_CFLIEN1_Msk         (0x1ul << PWM_CAPCTL01_CFLIEN1_Pos)               /*!< PWM CAPCTL01: CFLIEN1 Mask             */
S
S#define PWM_CAPCTL01_CAPEN1_Pos          (19)                                              /*!< PWM CAPCTL01: CAPEN1 Position          */
S#define PWM_CAPCTL01_CAPEN1_Msk          (0x1ul << PWM_CAPCTL01_CAPEN1_Pos)                /*!< PWM CAPCTL01: CAPEN1 Mask              */
S
S#define PWM_CAPCTL01_CAPIF1_Pos          (20)                                              /*!< PWM CAPCTL01: CAPIF1 Position          */
S#define PWM_CAPCTL01_CAPIF1_Msk          (0x1ul << PWM_CAPCTL01_CAPIF1_Pos)                /*!< PWM CAPCTL01: CAPIF1 Mask              */
S
S#define PWM_CAPCTL01_CRLIF1_Pos          (22)                                              /*!< PWM CAPCTL01: CRLIF1 Position          */
S#define PWM_CAPCTL01_CRLIF1_Msk          (0x1ul << PWM_CAPCTL01_CRLIF1_Pos)                /*!< PWM CAPCTL01: CRLIF1 Mask              */
S
S#define PWM_CAPCTL01_CFLIF1_Pos          (23)                                              /*!< PWM CAPCTL01: CFLIF1 Position          */
S#define PWM_CAPCTL01_CFLIF1_Msk          (0x1ul << PWM_CAPCTL01_CFLIF1_Pos)                /*!< PWM CAPCTL01: CFLIF1 Mask              */
S
S#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM RCAPDAT0: RCAPDAT Position         */
S#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM RCAPDAT0: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM FCAPDAT0: FCAPDAT Position         */
S#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM FCAPDAT0: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM RCAPDAT1: RCAPDAT Position         */
S#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM RCAPDAT1: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM FCAPDAT1: FCAPDAT Position         */
S#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM FCAPDAT1: FCAPDAT Mask             */
S
S#define PWM_CAPINEN_CAPINEN_Pos          (0)                                               /*!< PWM CAPINEN: CAPINEN Position          */
S#define PWM_CAPINEN_CAPINEN_Msk          (0x3ul << PWM_CAPINEN_CAPINEN_Pos)                /*!< PWM CAPINEN: CAPINEN Mask              */
S
S#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM POEN: POEN0 Position               */
S#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM POEN: POEN0 Mask                   */
S
S#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM POEN: POEN1 Position               */
S#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM POEN: POEN1 Mask                   */
S
S/**@}*/ /* PWM_CONST */
S/**@}*/ /* end of PWM register group */
S
S
S/*---------------------- Real Time Clock Controller -------------------------*/
S/**
S    @addtogroup RTC Real Time Clock Controller(RTC)
S    Memory Mapped Structure for RTC Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * INIT
S     * ===================================================================================================
S     * Offset: 0x00  RTC Initialization Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ATVSTS    |RTC Active Status (Read only)
S     * |        |          |0: RTC is in reset state
S     * |        |          |1: RTC is in normal active state.
S     * |[1:31]  |INIT      |RTC Initialization
S     * |        |          |After a power-on reset (POR) RTC block should be initialized by writing 0xA5EB1357 to INIT.
S     * |        |          |This will force a hardware reset then release all logic and counters.
S */
S    __IO  uint32_t INIT;                  
S
S    /**
S     * RWEN
S     * ===================================================================================================
S     * Offset: 0x04  RTC Access Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |RWEN      |RTC Register Access Enable Password (Write only)
S     * |        |          |0xA965 = Enable RTC access
S     * |        |          |Others = Disable RTC access 
S     * |[16]    |RWENF     |RTC Register Access Enable Flag (Read only)
S     * |        |          |1 = RTC register read/write enable.
S     * |        |          |0 = RTC register read/write disable
S     * |        |          |This bit will be set after RWEN[15:0] register is set to 0xA965, it will clear automatically in 512 RTC clock cycles or RWEN[15:0] ! = 0xA965.
S     * |        |          |The effect of RTC_RWEN.RWENF on access to each register is given Table 5-72.
S     * |        |          |Table 5-72 RTC_RWEN.RWENF Register Access Effect.
S     * |        |          |Register : RWENF = 1 : RWENF = 0
S     * |        |          |RTC_INIT : R/W : R/W
S     * |        |          |RTC_FREQADJ : R/W : -
S     * |        |          |RTC_TIME : R/W : R
S     * |        |          |RTC_CAL : R/W : R
S     * |        |          |RTC_CLKFMT : R/W : R/W
S     * |        |          |RTC_WEEKDAY : R/W : R
S     * |        |          |RTC_TALM : R/W : -
S     * |        |          |RTC_CALM : R/W : -
S     * |        |          |RTC_LEAPYEAR : R : R
S     * |        |          |RTC_INTEN : R/W : R/W
S     * |        |          |RTC_INTSTS : R/W : R/W
S     * |        |          |RTC_TICK : R/W : -
S */
S    __O  uint32_t RWEN;                  
S
S    /**
S     * FREQADJ
S     * ===================================================================================================
S     * Offset: 0x08  RTC Frequency Compensation Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:5]   |FRACTION  |Fractional Part
S     * |        |          |Formula = (fraction part of detected value) x 60
S     * |        |          |Refer to 5.8.4.4 for the examples.
S     * |[8:11]  |INTEGER   |Integer Part
S     * |        |          |Register should contain the value (INT(Factual) - 32761)
S     * |        |          |Ex: Integer part of detected value = 32772,
S     * |        |          | RTC_FREQADJ.INTEGER = 32772-32761 = 11 (1011b)
S     * |        |          |The range between 32761 and 32776
S */
S    __IO uint32_t FREQADJ;               
S
S    /**
S     * TIME
S     * ===================================================================================================
S     * Offset: 0x0C  Time Load Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |SEC       |1 Sec Time Digit (0~9)
S     * |[4:6]   |TENSEC    |10 Sec Time Digit (0~5)
S     * |[8:11]  |MIN       |1 Min Time Digit (0~9)
S     * |[12:14] |TENMIN    |10 Min Time Digit (0~5)
S     * |[16:19] |HR        |1 Hour Time Digit (0~9)
S     * |[20:21] |TENHR     |10 Hour Time Digit (0~3)
S */
S    __IO uint32_t TIME;                  
S
S    /**
S     * CAL
S     * ===================================================================================================
S     * Offset: 0x10  Calendar Load Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |DAY       |1-Day Calendar Digit (0~9)
S     * |[4:5]   |TENDAY    |10-Day Calendar Digit (0~3)
S     * |[8:11]  |MON       |1-Month Calendar Digit (0~9)
S     * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
S     * |[16:19] |YEAR      |1-Year Calendar Digit (0~9)
S     * |[20:23] |TENYEAR   |10-Year Calendar Digit (0~9)
S */
S    __IO uint32_t CAL;                   
S
S    /**
S     * CLKFMT
S     * ===================================================================================================
S     * Offset: 0x14  Time Scale Selection Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |24HEN     |24-Hour / 12-Hour Mode Selection
S     * |        |          |Determines whether RTC_TIME and RTC_TALM are in 24-hour mode or 12-hour mode
S     * |        |          |1 = select 24-hour time scale
S     * |        |          |0 = select 12-hour time scale with AM and PM indication
S     * |        |          |The range of 24-hour time scale is between 0 and 23.
S     * |        |          |12-hour time scale:
S     * |        |          |01(AM01), 02(AM02), 03(AM03), 04(AM04), 05(AM05), 06(AM06)
S     * |        |          |07(AM07), 08(AM08), 09(AM09), 10(AM10), 11(AM11), 12(AM12)
S     * |        |          |21(PM01), 22(PM02), 23(PM03), 24(PM04), 25(PM05), 26(PM06)
S     * |        |          |27(PM07), 28(PM08), 29(PM09), 30(PM10), 31(PM11), 32(PM12)
S */
S    __IO uint32_t CLKFMT;                
S
S    /**
S     * WEEKDAY
S     * ===================================================================================================
S     * Offset: 0x18  Day of the Week Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |WEEKDAY   |Day of the Week Register
S     * |        |          |0 (Sunday), 1 (Monday), 2 (Tuesday), 3 (Wednesday)
S     * |        |          |4 (Thursday), 5 (Friday), 6 (Saturday)
S */
S    __IO uint32_t WEEKDAY;               
S
S    /**
S     * TALM
S     * ===================================================================================================
S     * Offset: 0x1C  Time Alarm Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |SEC       |1 Sec Time Digit of Alarm Setting (0~9)
S     * |[4:6]   |TENSEC    |10 Sec Time Digit of Alarm Setting (0~5)
S     * |[8:11]  |MIN       |1 Min Time Digit of Alarm Setting (0~9)
S     * |[12:14] |TENMIN    |10 Min Time Digit of Alarm Setting (0~5)
S     * |[16:19] |HR        |1 Hour Time Digit of Alarm Setting (0~9)
S     * |[20:21] |TENHR     |10 Hour Time Digit of Alarm Setting (0~3)
S */
S    __IO uint32_t TALM;                  
S
S    /**
S     * CALM
S     * ===================================================================================================
S     * Offset: 0x20  Calendar Alarm Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
S     * |[4:5]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
S     * |[8:11]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
S     * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
S     * |[16:19] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
S     * |[20:23] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
S */
S    __IO uint32_t CALM;                  
S
S    /**
S     * LEAPYEAR
S     * ===================================================================================================
S     * Offset: 0x24  Leap year Indicator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LEAPYEAR  |Leap Year Indication Register (read only)
S     * |        |          |0 = Current year is not a leap year
S     * |        |          |1 = Current year is leap year
S */
S    __I  uint32_t LEAPYEAR;              
S
S    /**
S     * INTEN
S     * ===================================================================================================
S     * Offset: 0x28  RTC Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ALMIEN    |Alarm Interrupt Enable
S     * |        |          |0 = RTC Alarm Interrupt is disabled
S     * |        |          |1 = RTC Alarm Interrupt is enabled
S     * |[1]     |TICKIEN   |Time-Tick Interrupt and Wakeup-by-Tick Enable
S     * |        |          |0 = RTC Time-Tick Interrupt is disabled.
S     * |        |          |1 = RTC Time-Tick Interrupt is enabled.
S */
S    __IO uint32_t INTEN;                 
S
S    /**
S     * INTSTS
S     * ===================================================================================================
S     * Offset: 0x2C  RTC Interrupt Indicator Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
S     * |        |          |When RTC Alarm Interrupt is enabled (RTC_INTEN.ALMIEN=1), RTC unit will set AIF to high once the RTC real time counters RTC_TIME and RTC_CAL reach the alarm setting time registers RTC_TALM and RTC_CALM.
S     * |        |          |This bit cleared/acknowledged by writing 1 to it.
S     * |        |          |0= Indicates no Alarm Interrupt condition.
S     * |        |          |1= Indicates RTC Alarm Interrupt generated.
S     * |[1]     |TICKIF    |RTC Time-Tick Interrupt Flag
S     * |        |          |When RTC Time-Tick Interrupt is enabled (RTC_INTEN.TICKIEN=1), RTC unit will set TIF high at the rate selected by RTC_TICK[2:0].
S     * |        |          |This bit cleared/acknowledged by writing 1 to it.
S     * |        |          |0= Indicates no Time-Tick Interrupt condition.
S     * |        |          |1= Indicates RTC Time-Tick Interrupt generated.
S */
S    __IO uint32_t INTSTS;                
S
S    /**
S     * TICK
S     * ===================================================================================================
S     * Offset: 0x30  RTC Time Tick Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:2]   |TICKSEL   |Time Tick Register
S     * |        |          |The RTC time tick period for Periodic Time-Tick Interrupt request.
S     * |        |          |Time Tick (second) : 1 / (2^TICKSEL)
S     * |        |          |Note: This register can be read back after the RTC is active.
S     * |[3]     |TWKEN     |RTC Timer Wakeup CPU Function Enable Bit
S     * |        |          |If TWKEN is set before CPU is in power-down mode, when a RTC Time-Tick or Alarm Match occurs, CPU will wake up.
S     * |        |          |0= Disable Wakeup CPU function.
S     * |        |          |1= Enable the Wakeup function.
S */
S    __IO uint32_t TICK;                  
S
S} RTC_T;
S
S/**
S    @addtogroup RTC_CONST RTC Bit Field Definition
S    Constant Definitions for RTC Controller
S@{ */
S
S#define RTC_INIT_ATVSTS_Pos              (0)                                               /*!< RTC INIT: ATVSTS Position              */
S#define RTC_INIT_ATVSTS_Msk              (0x1ul << RTC_INIT_ATVSTS_Pos)                    /*!< RTC INIT: ATVSTS Mask                  */
S
S#define RTC_INIT_INIT_Pos                (1)                                               /*!< RTC INIT: INIT Position                */
S#define RTC_INIT_INIT_Msk                (0x7ffffffful << RTC_INIT_INIT_Pos)               /*!< RTC INIT: INIT Mask                    */
S
S#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC RWEN: RWEN Position                */
S#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC RWEN: RWEN Mask                    */
S
S#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC RWEN: RWENF Position               */
S#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC RWEN: RWENF Mask                   */
S
S#define RTC_FREQADJ_FRACTION_Pos         (0)                                               /*!< RTC FREQADJ: FRACTION Position         */
S#define RTC_FREQADJ_FRACTION_Msk         (0x3ful << RTC_FREQADJ_FRACTION_Pos)              /*!< RTC FREQADJ: FRACTION Mask             */
S
S#define RTC_FREQADJ_INTEGER_Pos          (8)                                               /*!< RTC FREQADJ: INTEGER Position          */
S#define RTC_FREQADJ_INTEGER_Msk          (0xful << RTC_FREQADJ_INTEGER_Pos)                /*!< RTC FREQADJ: INTEGER Mask              */
S
S#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC TIME: SEC Position                 */
S#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC TIME: SEC Mask                     */
S
S#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC TIME: TENSEC Position              */
S#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC TIME: TENSEC Mask                  */
S
S#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC TIME: MIN Position                 */
S#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC TIME: MIN Mask                     */
S
S#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC TIME: TENMIN Position              */
S#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC TIME: TENMIN Mask                  */
S
S#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC TIME: HR Position                  */
S#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC TIME: HR Mask                      */
S
S#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC TIME: TENHR Position               */
S#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC TIME: TENHR Mask                   */
S
S#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC CAL: DAY Position                  */
S#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC CAL: DAY Mask                      */
S
S#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC CAL: TENDAY Position               */
S#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC CAL: TENDAY Mask                   */
S
S#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC CAL: MON Position                  */
S#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC CAL: MON Mask                      */
S
S#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC CAL: TENMON Position               */
S#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC CAL: TENMON Mask                   */
S
S#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC CAL: YEAR Position                 */
S#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC CAL: YEAR Mask                     */
S
S#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC CAL: TENYEAR Position              */
S#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC CAL: TENYEAR Mask                  */
S
S#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC CLKFMT: 24HEN Position             */
S#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC CLKFMT: 24HEN Mask                 */
S
S#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC WEEKDAY: WEEKDAY Position          */
S#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC WEEKDAY: WEEKDAY Mask              */
S
S#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC TALM: SEC Position                 */
S#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC TALM: SEC Mask                     */
S
S#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC TALM: TENSEC Position              */
S#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC TALM: TENSEC Mask                  */
S
S#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC TALM: MIN Position                 */
S#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC TALM: MIN Mask                     */
S
S#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC TALM: TENMIN Position              */
S#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC TALM: TENMIN Mask                  */
S
S#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC TALM: HR Position                  */
S#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC TALM: HR Mask                      */
S
S#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC TALM: TENHR Position               */
S#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC TALM: TENHR Mask                   */
S
S#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC CALM: DAY Position                 */
S#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC CALM: DAY Mask                     */
S
S#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC CALM: TENDAY Position              */
S#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC CALM: TENDAY Mask                  */
S
S#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC CALM: MON Position                 */
S#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC CALM: MON Mask                     */
S
S#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC CALM: TENMON Position              */
S#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC CALM: TENMON Mask                  */
S
S#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC CALM: YEAR Position                */
S#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC CALM: YEAR Mask                    */
S
S#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC CALM: TENYEAR Position             */
S#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC CALM: TENYEAR Mask                 */
S
S#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC LEAPYEAR: LEAPYEAR Position        */
S#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC LEAPYEAR: LEAPYEAR Mask            */
S
S#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC INTEN: ALMIEN Position             */
S#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC INTEN: ALMIEN Mask                 */
S
S#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC INTEN: TICKIEN Position            */
S#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC INTEN: TICKIEN Mask                */
S
S#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC INTSTS: ALMIF Position             */
S#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC INTSTS: ALMIF Mask                 */
S
S#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC INTSTS: TICKIF Position            */
S#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC INTSTS: TICKIF Mask                */
S
S#define RTC_TICK_TICKSEL_Pos             (0)                                               /*!< RTC TICK: TICKSEL Position             */
S#define RTC_TICK_TICKSEL_Msk             (0x7ul << RTC_TICK_TICKSEL_Pos)                   /*!< RTC TICK: TICKSEL Mask                 */
S
S#define RTC_TICK_TWKEN_Pos               (3)                                               /*!< RTC TICK: TWKEN Position               */
S#define RTC_TICK_TWKEN_Msk               (0x1ul << RTC_TICK_TWKEN_Pos)                     /*!< RTC TICK: TWKEN Mask                   */
S
S/**@}*/ /* RTC_CONST */
S/**@}*/ /* end of RTC register group */
S
S
S/*---------------------- Serial Peripheral Interface Controller -------------------------*/
S/**
S    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
S    Memory Mapped Structure for SPI Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  Control and Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BUSY      |Go and Busy Status
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit starts the transfer.
S     * |        |          |This bit remains set during the transfer and is automatically cleared after transfer finished.
S     * |        |          |NOTE: All registers should be set before writing 1 to this BUSY bit.
S     * |        |          |When a transfer is in progress, writing to any register of the SPI master/slave core has no effect.
S     * |[1]     |RXNET     |Receive At Negative Edge
S     * |        |          |0 = The received data input signal is latched at the rising edge of SCLK.
S     * |        |          |1 = The received data input signal is latched at the falling edge of SCLK.
S     * |[2]     |TXNEG     |Transmit At Negative Edge
S     * |        |          |0 = The transmitted data output signal is changed at the rising edge of SCLK.
S     * |        |          |1 = The transmitted data output signal is changed at the falling edge of SCLK.
S     * |[3:7]   |DWIDTH    |Transmit Bit Length
S     * |        |          |This field specifies how many bits are transmitted in one transmit/receive.
S     * |        |          |Up to 32 bits can be transmitted.
S     * |        |          |DWIDTH = 0x01 --- 1 bit
S     * |        |          |DWIDTH = 0x02 --- 2 bits
S     * |        |          |----
S     * |        |          |DWIDTH = 0x1f --- 31 bits
S     * |        |          |DWIDTH = 0x00 --- 32 bits
S     * |[8:9]   |TXCNT     |Transmit/Receive Word Numbers
S     * |        |          |This field specifies how many transmit/receive word numbers should be executed in one transfer.
S     * |        |          |00 = Only one transmit/receive word will be executed in one transfer.
S     * |        |          |01 = Two successive transmit/receive word will be executed in one transfer.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = Reserved.
S     * |[10]    |LSB       |LSB First
S     * |        |          |0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the DWIDTH field).
S     * |        |          |1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the Rx register (bit 0 of SPI_RX0/1).
S     * |[11]    |CLKPOL    |Clock Polarity
S     * |        |          |0 = SCLK idle low.
S     * |        |          |1 = SCLK idle high.
S     * |[12:15] |SUSPITV   |Suspend Interval (Master Only)
S     * |        |          |These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer.
S     * |        |          |The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKPOL = 0.
S     * |        |          |If CLKPOL = 1, the interval is from the rising clock edge to the falling clock edge.
S     * |        |          |The default value is 0x0.
S     * |        |          |When TXCNT = 00b, setting this field has no effect on transfer except as determined by REORDER[0] setting.
S     * |        |          |The suspend interval is determined according to the following equation:.
S     * |        |          |(SUSPITV[3:0] + 2) * period of SCLK
S     * |[16]    |UNITIF    |Interrupt Flag
S     * |        |          |0 = Indicates the transfer is not finished yet.
S     * |        |          |1 = Indicates that the transfer is complete. Interrupt is generated to CPU if enabled.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[17]    |UNITIEN   |Interrupt Enable
S     * |        |          |0 = Disable SPI Interrupt.
S     * |        |          |1 = Enable SPI Interrupt to CPU.
S     * |[18]    |SLAVE     |Master Slave Mode Control
S     * |        |          |0 = Master mode.
S     * |        |          |1 = Slave mode.
S     * |[19]    |BYTEITV   |Insert Sleep Interval Between Bytes
S     * |        |          |This function is only valid for 32bit transfers (DWIDTH = 0).
S     * |        |          |If set then a pause of (SUSPITV+2) SCLK cycles is inserted between each byte transmitted.
S     * |[20]    |REORDER   |Byte Endian Reorder Function
S     * |        |          |This function changes the order of bytes sent/received to be least significant physical byte first. 
S     * |[21]    |FIFOEN    |FIFO Mode
S     * |        |          |0 = No FIFO present on transmit and receive buffer.
S     * |        |          |1 = Enable FIFO on transmit and receive buffer.
S     * |[22]    |TWOBIT    |Two Bits Transfer Mode
S     * |        |          |0 = Disable two-bit transfer mode.
S     * |        |          |1 = Enable two-bit transfer mode.
S     * |        |          |Note that when enabled in master mode, MOSI0 data comes from SPI_TX0 and MOSI1 data from SPI_TX1.
S     * |        |          |Likewise SPI_RX0 receives bit stream from MISO0 and SPI_RX1 from MISO1.
S     * |        |          |Note that when enabled, the setting of TXCNT must be programmed as 0x00.
S     * |[23]    |VARCLKEN  |Variable Clock Enable (Master Only)
S     * |        |          |0 = The serial clock output frequency is fixed and determined only by the value of DIVIDER0.
S     * |        |          |1 = SCLK output frequency is variable.
S     * |        |          |The output frequency is determined by the value of SPI_VARCLK, DIVIDER0, and DIVIDER1.
S     * |        |          |Note that when enabled, the setting of DWIDTH must be programmed as 0x10 (16 bits mode)
S     * |[24]    |RXEMPTY   |Receive FIFO Empty Status
S     * |        |          |0 = The receive data FIFO is not empty.
S     * |        |          |1 = The receive data FIFO is empty.
S     * |[25]    |RXFULL    |Receive FIFO Full Status
S     * |        |          |0 = The receive data FIFO is not full.
S     * |        |          |1 = The receive data FIFO is full.
S     * |[26]    |TXEMPTY   |Transmit FIFO Empty Status
S     * |        |          |0 = The transmit data FIFO is not empty.
S     * |        |          |1 = The transmit data FIFO is empty.
S     * |[27]    |TXFULL    |Transmit FIFO Full Status
S     * |        |          |0 = The transmit data FIFO is not full.
S     * |        |          |1 = The transmit data FIFO is full.
S     * |[28]    |PDMASSEN  |Enable DMA Automatic SS function
S     * |        |          |When enabled, interface will automatically generate a SS signal for an entire PDMA access transaction.
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x04  Clock Divider Register (Master Only)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |DIVIDER0  |Clock Divider Register (master only)
S     * |        |          |The value in this field is the frequency division of the system clock, PCLK, to generate the serial clock on the output SCLK.
S     * |        |          |The desired frequency is obtained according to the following equation:.
S     * |        |          |Fsclk = Fpclk / ((DIVIDER0+1) * 2)
S     * |        |          |In slave mode, the period of SPI clock driven by a master shall satisfy
S     * |        |          |Fsclk < = (Fpclk / 5)
S     * |        |          |In other words, the maximum frequency of SCLK clock is one fifth of the SPI peripheral clock.
S     * |[16:31] |DIVIDER1  |Clock Divider 2 Register (master only)
S     * |        |          |The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SCLK.
S     * |        |          |The desired frequency is obtained according to the following equation:.
S     * |        |          |Fsclk = Fpclk / ((DIVIDER1+1) * 2)
S */
S    __IO uint32_t CLKDIV;                
S
S    /**
S     * SSCTL
S     * ===================================================================================================
S     * Offset: 0x08  Slave Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |SS        |Slave Select Register (Master only)
S     * |        |          |If AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.
S     * |        |          |If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time.
S     * |        |          |(The active level of SPISSx0/1 is specified in SSACTPOL).
S     * |        |          |Note: SPISSx0 is always defined as device/slave select input signal in slave mode. 
S     * |[2]     |SSACTPOL  |Slave Select Active Level
S     * |        |          |It defines the active level of device/slave select signal (SPISSx0/1).
S     * |        |          |0 = The slave select signal SPISSx0/1 is active at low-level/falling-edge.
S     * |        |          |1 = The slave select signal SPISSx0/1 is active at high-level/rising-edge.
S     * |[3]     |AUTOSS    |Automatic Slave Select (Master only)
S     * |        |          |0 = If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SPI_SSCTL[1:0] register.
S     * |        |          |1 = If this bit is set, SPISSx0/1 signals are generated automatically.
S     * |        |          |It means that device/slave select signal, which is set in SPI_SSCTL[1:0] register is asserted by the SPI controller when transmit/receive is started by setting BUSY, and is de-asserted after each transmit/receive is finished.
S     * |[4]     |LVTRGEN   |Slave Select Level Trigger (Slave only)
S     * |        |          |0= The input slave select signal is edge-trigger. This is the default value.
S     * |        |          |1= The slave select signal will be level-trigger.
S     * |        |          |It depends on SSACTPOL to decide the signal is active low or active high.
S     * |[5]     |LVTRGSTS  |Level Trigger Flag
S     * |        |          |When the LVTRGEN bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
S     * |        |          |0=One of the received number and the received bit length doesn't meet the requirement in one transfer.
S     * |        |          |1=The received number and received bits met the requirement which defines in TXCNT and DWIDTH among one transfer.
S     * |        |          |Note: This bit is READ only
S */
S    __IO uint32_t SSCTL;                 
S         uint32_t RESERVE0[1];
S
S
S    /**
S     * RX0
S     * ===================================================================================================
S     * Offset: 0x10  Data Receive Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |RX        |Data Receive Register
S     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer.
S     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
S     * |        |          |For example, if DWIDTH is set to 0x08 and TXCNT is set to 0x0, bit Rx0[7:0] holds the received data.
S     * |        |          |NOTE: The Data Receive Registers are read only registers. 
S */
S    __I  uint32_t RX0;                   
S
S    /**
S     * RX1
S     * ===================================================================================================
S     * Offset: 0x14  Data Receive Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |RX        |Data Receive Register
S     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer.
S     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
S     * |        |          |For example, if DWIDTH is set to 0x08 and TXCNT is set to 0x0, bit Rx0[7:0] holds the received data.
S     * |        |          |NOTE: The Data Receive Registers are read only registers. 
S */
S    __I  uint32_t RX1;                   
S         uint32_t RESERVE1[2];
S
S
S    /**
S     * TX0
S     * ===================================================================================================
S     * Offset: 0x20  Data Transmit Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |TX        |Data Transmit Register
S     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
S     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
S     * |        |          |For example, if DWIDTH is set to 0x08 and the TXCNT is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer.
S     * |        |          |If DWIDTH is set to 0x00 and TXCNT is set to 0x1, the core will perform two 32-bit transmit/receive successive using the same setting (the order is TX0[31:0], TX1[31:0]).
S */
S    __O  uint32_t TX0;                   
S
S    /**
S     * TX1
S     * ===================================================================================================
S     * Offset: 0x24  Data Transmit Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |TX        |Data Transmit Register
S     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
S     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CTL register.
S     * |        |          |For example, if DWIDTH is set to 0x08 and the TXCNT is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer.
S     * |        |          |If DWIDTH is set to 0x00 and TXCNT is set to 0x1, the core will perform two 32-bit transmit/receive successive using the same setting (the order is TX0[31:0], TX1[31:0]).
S */
S    __O  uint32_t TX1;                   
S         uint32_t RESERVE2[3];
S
S
S    /**
S     * VARCLK
S     * ===================================================================================================
S     * Offset: 0x34  Variable Clock Pattern Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |VARCLK    |Variable Clock Pattern
S     * |        |          |The value in this field is the frequency pattern of the SPI clock.
S     * |        |          |If the bit field of VARCLK is '0', the output frequency of SCLK is given by the value of DIVIDER0.
S     * |        |          |If the bit field of VARCLK is '1', the output frequency of SCLK is given by the value of DIVIDER1.
S     * |        |          |Refer to register DIVIDER0.
S     * |        |          |Refer to Variable Serial Clock Frequency paragraph for detailed description.
S     * |        |          |Note: Used for CLKPOL = 0 only, 16 bit transmission.
S */
S    __IO uint32_t VARCLK;                
S
S    /**
S     * PDMACTL
S     * ===================================================================================================
S     * Offset: 0x38  SPI DMA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TXPDMAEN  |Transmit DMA Start
S     * |        |          |Set this bit to 1 will start the transmit DMA process.
S     * |        |          |SPI module will issue request to DMA module automatically.
S     * |        |          |If using DMA mode to transfer data, remember not to set BUSY bit of SPI_CTL register.
S     * |        |          |The DMA controller inside SPI module will set it automatically whenever necessary.
S     * |[1]     |RXPDMAEN  |Receive DMA Start
S     * |        |          |Set this bit to 1 will start the receive DMA process.
S     * |        |          |SPI module will issue request to DMA module automatically.
S */
S    __IO uint32_t PDMACTL;               
S
S} SPI_T;
S
S/**
S    @addtogroup SPI_CONST SPI Bit Field Definition
S    Constant Definitions for SPI Controller
S@{ */
S
S#define SPI_CTL_BUSY_Pos                 (0)                                               /*!< SPI CTL: BUSY Position                 */
S#define SPI_CTL_BUSY_Msk                 (0x1ul << SPI_CTL_BUSY_Pos)                       /*!< SPI CTL: BUSY Mask                     */
S
S#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI CTL: RXNEG Position                */
S#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI CTL: RXNEG Mask                    */
S
S#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI CTL: TXNEG Position                */
S#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI CTL: TXNEG Mask                    */
S
S#define SPI_CTL_DWIDTH_Pos               (3)                                               /*!< SPI CTL: DWIDTH Position               */
S#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI CTL: DWIDTH Mask                   */
S
S#define SPI_CTL_TX_NUM_Pos               (8)                                               /*!< SPI CTL: TX_NUM Position                */
S#define SPI_CTL_TX_NUM_Msk               (0x3ul << SPI_CTL_TX_NUM_Pos)                      /*!< SPI CTL: TX_NUM Mask                    */
S
S#define SPI_CTL_LSB_Pos                  (10)                                              /*!< SPI CTL: LSB Position                  */
S#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI CTL: LSB Mask                      */
S
S#define SPI_CTL_CLKP_Pos                 (11)                                              /*!< SPI CTL: CLKP Position               */
S#define SPI_CTL_CLKP_Msk                 (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI CTL: CLKP Mask                   */
S
S#define SPI_CTL_SUSPITV_Pos              (12)                                              /*!< SPI CTL: SUSPITV Position              */
S#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI CTL: SUSPITV Mask                  */
S
S#define SPI_CTL_UNIT_INTSTS_Pos          (16)                                              /*!< SPI CTL: UNIT_INTSTS Position               */
S#define SPI_CTL_UNIT_INTSTS_Msk          (0x1ul << SPI_CTL_UNIT_INTSTS_Pos)                /*!< SPI CTL: UNITIF Mask                   */
S
S#define SPI_CTL_UNIT_INTEN_Pos           (17)                                              /*!< SPI CTL: UNITIEN Position              */
S#define SPI_CTL_UNIT_INTEN_Msk           (0x1ul << SPI_CTL_UNIT_INTEN_Pos)                 /*!< SPI CTL: UNITIEN Mask                  */
S
S#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI CTL: SLAVE Position                */
S#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI CTL: SLAVE Mask                    */
S
S#define SPI_CTL_BYTEITV_Pos              (19)                                              /*!< SPI CTL: BYTEITV Position              */
S#define SPI_CTL_BYTEITV_Msk              (0x1ul << SPI_CTL_BYTEITV_Pos)                    /*!< SPI CTL: BYTEITV Mask                  */
S
S#define SPI_CTL_REORDER_Pos              (20)                                              /*!< SPI CTL: REORDER Position              */
S#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI CTL: REORDER Mask                  */
S
S#define SPI_CTL_FIFOEN_Pos               (21)                                              /*!< SPI CTL: FIFOEN Position               */
S#define SPI_CTL_FIFOEN_Msk               (0x1ul << SPI_CTL_FIFOEN_Pos)                     /*!< SPI CTL: FIFOEN Mask                   */
S
S#define SPI_CTL_TWOBIT_Pos               (22)                                              /*!< SPI CTL: TWOBIT Position               */
S#define SPI_CTL_TWOBIT_Msk               (0x1ul << SPI_CTL_TWOBIT_Pos)                     /*!< SPI CTL: TWOBIT Mask                   */
S
S#define SPI_CTL_VARCLKEN_Pos             (23)                                              /*!< SPI CTL: VARCLKEN Position             */
S#define SPI_CTL_VARCLKEN_Msk             (0x1ul << SPI_CTL_VARCLKEN_Pos)                   /*!< SPI CTL: VARCLKEN Mask                 */
S
S#define SPI_CTL_RXEMPTY_Pos              (24)                                              /*!< SPI CTL: RXEMPTY Position              */
S#define SPI_CTL_RXEMPTY_Msk              (0x1ul << SPI_CTL_RXEMPTY_Pos)                    /*!< SPI CTL: RXEMPTY Mask                  */
S
S#define SPI_CTL_RXFULL_Pos               (25)                                              /*!< SPI CTL: RXFULL Position               */
S#define SPI_CTL_RXFULL_Msk               (0x1ul << SPI_CTL_RXFULL_Pos)                     /*!< SPI CTL: RXFULL Mask                   */
S
S#define SPI_CTL_TXEMPTY_Pos              (26)                                              /*!< SPI CTL: TXEMPTY Position              */
S#define SPI_CTL_TXEMPTY_Msk              (0x1ul << SPI_CTL_TXEMPTY_Pos)                    /*!< SPI CTL: TXEMPTY Mask                  */
S
S#define SPI_CTL_TXFULL_Pos               (27)                                              /*!< SPI CTL: TXFULL Position               */
S#define SPI_CTL_TXFULL_Msk               (0x1ul << SPI_CTL_TXFULL_Pos)                     /*!< SPI CTL: TXFULL Mask                   */
S
S#define SPI_CTL_PDMASSEN_Pos             (28)                                              /*!< SPI CTL: PDMASSEN Position             */
S#define SPI_CTL_PDMASSEN_Msk             (0x1ul << SPI_CTL_PDMASSEN_Pos)                   /*!< SPI CTL: PDMASSEN Mask                 */
S
S#define SPI_CLKDIV_DIVIDER0_Pos          (0)                                               /*!< SPI CLKDIV: DIVIDER0 Position          */
S#define SPI_CLKDIV_DIVIDER0_Msk          (0xfffful << SPI_CLKDIV_DIVIDER0_Pos)             /*!< SPI CLKDIV: DIVIDER0 Mask              */
S
S#define SPI_CLKDIV_DIVIDER1_Pos          (16)                                              /*!< SPI CLKDIV: DIVIDER1 Position          */
S#define SPI_CLKDIV_DIVIDER1_Msk          (0xfffful << SPI_CLKDIV_DIVIDER1_Pos)             /*!< SPI CLKDIV: DIVIDER1 Mask              */
S
S#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI SSCTL: SS Position                 */
S#define SPI_SSCTL_SS_Msk                 (0x3ul << SPI_SSCTL_SS_Pos)                       /*!< SPI SSCTL: SS Mask                     */
S
S#define SPI_SSCTL_SS_LVL_Pos             (2)                                               /*!< SPI SSCTL: SS_LVL Position           */
S#define SPI_SSCTL_SS_LVL_Msk             (0x1ul << SPI_SSCTL_SS_LVL_Pos)                   /*!< SPI SSCTL: SS_LVL Mask               */
S
S#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI SSCTL: AUTOSS Position             */
S#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI SSCTL: AUTOSS Mask                 */
S
S#define SPI_SSCTL_LVTRGEN_Pos            (4)                                               /*!< SPI SSCTL: LVTRGEN Position            */
S#define SPI_SSCTL_LVTRGEN_Msk            (0x1ul << SPI_SSCTL_LVTRGEN_Pos)                  /*!< SPI SSCTL: LVTRGEN Mask                */
S
S#define SPI_SSCTL_LVTRGSTS_Pos           (5)                                               /*!< SPI SSCTL: LVTRGSTS Position           */
S#define SPI_SSCTL_LVTRGSTS_Msk           (0x1ul << SPI_SSCTL_LVTRGSTS_Pos)                 /*!< SPI SSCTL: LVTRGSTS Mask               */
S
S#define SPI_RX0_RX_Pos                   (0)                                               /*!< SPI RX0: RX Position                   */
S#define SPI_RX0_RX_Msk                   (0xfffffffful << SPI_RX0_RX_Pos)                  /*!< SPI RX0: RX Mask                       */
S
S#define SPI_RX1_RX_Pos                   (0)                                               /*!< SPI RX1: RX Position                   */
S#define SPI_RX1_RX_Msk                   (0xfffffffful << SPI_RX1_RX_Pos)                  /*!< SPI RX1: RX Mask                       */
S
S#define SPI_TX0_TX_Pos                   (0)                                               /*!< SPI TX0: TX Position                   */
S#define SPI_TX0_TX_Msk                   (0xfffffffful << SPI_TX0_TX_Pos)                  /*!< SPI TX0: TX Mask                       */
S
S#define SPI_TX1_TX_Pos                   (0)                                               /*!< SPI TX1: TX Position                   */
S#define SPI_TX1_TX_Msk                   (0xfffffffful << SPI_TX1_TX_Pos)                  /*!< SPI TX1: TX Mask                       */
S
S#define SPI_VARCLK_VARCLK_Pos            (0)                                               /*!< SPI VARCLK: VARCLK Position            */
S#define SPI_VARCLK_VARCLK_Msk            (0xfffffffful << SPI_VARCLK_VARCLK_Pos)           /*!< SPI VARCLK: VARCLK Mask                */
S
S#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI PDMACTL: TXPDMAEN Position         */
S#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI PDMACTL: TXPDMAEN Mask             */
S
S#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI PDMACTL: RXPDMAEN Position         */
S#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI PDMACTL: RXPDMAEN Mask             */
S
S/**@}*/ /* SPI_CONST */
S/**@}*/ /* end of SPI register group */
S
S
S/*---------------------- System Manger Controller -------------------------*/
S/**
S    @addtogroup SYS System Manger Controller(SYS)
S    Memory Mapped Structure for SYS Controller
S@{ */
S 
Stypedef struct
S{
S
S    /**
S     * PDID
S     * ===================================================================================================
S     * Offset: 0x00  Product Identifier Register 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:31]  |CORERSTF  |Chip Part Number Identifier
S */
S         uint32_t PDID;
S
S
S    /**
S     * RSTSTS
S     * ===================================================================================================
S     * Offset: 0x04  System Reset Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CORERSTF  |Reset Source From CORE
S     * |        |          |The CORERSTF flag is set if the core has been reset.
S     * |        |          |Possible sources of reset are a Power-On Reset (POR), RESETn Pin Reset or PMU reset.
S     * |        |          |0= No reset from CORE
S     * |        |          |1= Core was reset by hardware block.
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[2]     |WDTRF     |Reset Source From WDT
S     * |        |          |The WDTRF flag is set if pervious reset source originates from the Watch-Dog module.
S     * |        |          |0= No reset from Watch-Dog
S     * |        |          |1= The Watch-Dog module issued the reset signal to reset the system.
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[5]     |SYSRF     |Reset Source From MCU
S     * |        |          |The SYSRF flag is set if the previous reset source originates from the Cortex_M0 kernel.
S     * |        |          |0= No reset from MCU
S     * |        |          |1= The Cortex_M0 MCU issued a reset signal to reset the system by software writing 1 to bit SYSCTL_AIRCTL.SYSRESTREQ, Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[6]     |PMURSTF   |Reset Source From PMU
S     * |        |          |The PMURSTF flag is set if the PMU.
S     * |        |          |0= No reset from PMU
S     * |        |          |1= PMU reset the system from a power down/standby event.
S     * |        |          |This bit is cleared by writing 1 to itself.
S     * |[7]     |CPURF     |Reset Source From CPU
S     * |        |          |The CPURF flag is set by hardware if software writes SYS_IPRST0.CPURST with a "1" to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).
S     * |        |          |0= No reset from CPU
S     * |        |          |1= The Cortex-M0 CPU kernel and FMC has been reset by software setting CPURST to 1.
S     * |        |          |This bit is cleared by writing 1 to itself.
S */
S    __IO uint32_t RSTSTS;                
S
S    /**
S     * IPRST0
S     * ===================================================================================================
S     * Offset: 0x08  IP Reset Control Resister1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHIPRST   |CHIP One Shot Reset
S     * |        |          |Set this bit will reset the whole chip, this bit will automatically return to "0" after the 2 clock cycles.
S     * |        |          |CHIPRST has same behavior as POR reset, all the chip modules are reset and the chip configuration settings from flash are reloaded.
S     * |        |          |This bit is a protected bit, to program first issue the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
S     * |        |          |0= Normal
S     * |        |          |1= Reset CHIP
S     * |[1]     |CPURST    |CPU Kernel One Shot Reset
S     * |        |          |Setting this bit will reset the CPU kernel and Flash Memory Controller(FMC), this bit will automatically return to "0" after the 2 clock cycles
S     * |        |          |This bit is a protected bit, to program first issue the unlock sequence (see Protected Register Lock Key Register (SYS_REGLCTL))
S     * |        |          |0= Normal
S     * |        |          |1= Reset CPU
S     * |[2]     |PDMARST   |PDMA Controller Reset
S     * |        |          |Set "1" will generate a reset signal to the PDMA Block.
S     * |        |          |User needs to set this bit to "0" to release from the reset state.
S     * |        |          |0= Normal operation
S     * |        |          |1= PDMA IP reset
S */
S    __IO uint32_t IPRST0;                
S
S    /**
S     * IPRST1
S     * ===================================================================================================
S     * Offset: 0x0C  IP Reset Control Resister2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6]     |TMR0RST   |Timer0 Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[7]     |TMR1RST   |Timer1 Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[8]     |I2C0RST   |I2C0 Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[12]    |SPI0RST   |SPI0 Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[13]    |DPWMRST   |DPWM Speaker Driver Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[16]    |UART0RST  |UART0 Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[18]    |BIQRST    |Biquad Filter Block Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[19]    |CRCRST    |CRC Generation Block Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[20]    |PWM0RST   |PWM0 controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[22]    |ACMPRST   |Analog Comparator Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[28]    |EADCRST   |ADC Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[29]    |I2S0RST   |I2S Controller Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S     * |[30]    |ANARST    |Analog Block Control Reset
S     * |        |          |0 = Normal Operation
S     * |        |          |1 = Reset
S */
S    __IO uint32_t IPRST1;                
S         uint32_t RESERVE1[8];
S
S
S    /**
S     * PASMTEN
S     * ===================================================================================================
S     * Offset: 0x30  GPIOA input type control register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[16]    |SMTEN16   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[17]    |SMTEN17   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[18]    |SMTEN18   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[19]    |SMTEN19   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[20]    |SMTEN20   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[21]    |SMTEN21   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[22]    |SMTEN22   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[23]    |SMTEN23   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[24]    |SMTEN24   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[25]    |SMTEN25   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[26]    |SMTEN26   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[27]    |SMTEN27   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[28]    |SMTEN28   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[29]    |SMTEN29   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[30]    |SMTEN30   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S     * |[31]    |SMTEN31   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger disabled
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger enabled
S */
S    __IO uint32_t PASMTEN;               
S
S    /**
S     * PBSMTEN
S     * ===================================================================================================
S     * Offset: 0x34  GPIOB input type control register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[16]    |SMTEN16   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[17]    |SMTEN17   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[18]    |SMTEN18   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[19]    |SMTEN19   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[20]    |SMTEN20   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[21]    |SMTEN21   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[22]    |SMTEN22   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S     * |[23]    |SMTEN23   |Schmitt Trigger
S     * |        |          |This register controls whether the GPIO input buffer Schmitt trigger is enabled.
S     * |        |          |0= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger disabled
S     * |        |          |1= GPIOB(port 0 ~ port 7) I/O input Schmitt Trigger enabled
S */
S    __IO uint32_t PBSMTEN;               
S
S    /**
S     * GPA_MFP
S     * ===================================================================================================
S     * Offset: 0x38  GPIOA multiple function control register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |PA0MFP    |Alternate Function Setting For PA0MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = SPI_MOSI0
S     * |        |          |10 = MCLK
S     * |[2:3]   |PA1MFP    |Alternate Function Setting For PA1MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = SPI_SCLK
S     * |        |          |10 = I2C_SCL
S     * |[4:5]   |PA2MFP    |Alternate Function Setting For PA2MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = SPI_SSB0
S     * |[6:7]   |PA3MFP    |Alternate Function Setting For PA3MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = SPI_MISO0
S     * |        |          |10 = I2C_SDA
S     * |[8:9]   |PA4MFP    |Alternate Function Setting For PA4MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2S_FS
S     * |[10:11] |PA5MFP    |Alternate Function Setting For PA5MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2S_BCLK
S     * |[12:13] |PA6MFP    |Alternate Function Setting For PA6MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2S_SDI
S     * |[14:15] |PA7MFP    |Alternate Function Setting For PA7MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2S_SDO
S     * |[16:17] |PA8MFP    |Alternate Function Setting For PA8MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = UART_TX
S     * |        |          |10 = I2S_FS
S     * |[18:19] |PA9MFP    |Alternate Function Setting For PA0MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = UART_RX
S     * |        |          |10 = I2S_BCLK
S     * |[20:21] |PA10MFP   |Alternate Function Setting For PA10MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2C_SDA
S     * |        |          |10 = I2S_SDI
S     * |        |          |11 = UART_RTSn
S     * |[22:23] |PA11MFP   |Alternate Function Setting For PA11MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2C_SCL
S     * |        |          |10 = I2S_SDO
S     * |        |          |11 = UART_CTSn
S     * |[24:25] |PA12MFP   |Alternate Function Setting For PA12MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = PWM0CH0
S     * |        |          |10 = SPKP
S     * |        |          |11 = I2S_FS
S     * |[26:27] |PA13MFP   |Alternate Function Setting For PA13MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = PWM0CH1
S     * |        |          |10 = SPKM
S     * |        |          |11 = I2S_BCLK
S     * |[28:29] |PA14MFP   |Alternate Function Setting For PA14MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = TM0
S     * |        |          |10 = SDCLK
S     * |        |          |11 = SDCLKn
S     * |[30:31] |PA15MFP   |Alternate Function Setting For PA15MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = TM1
S     * |        |          |10 = SDIN
S */
S    __IO uint32_t GPA_MFP;               
S
S    /**
S     * GPB_MFP
S     * ===================================================================================================
S     * Offset: 0x3C  GPIOB multiple function control register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |PB0MFP    |Alternate Function Setting For PB0MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = SPI_SSB1
S     * |        |          |10 = CMP0
S     * |        |          |11 = SPI_SSB0
S     * |[2:3]   |PB1MFP    |Alternate Function Setting For PB1MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = MCLK
S     * |        |          |10 = CMP1
S     * |        |          |11 = SPI_SSB1
S     * |[4:5]   |PB2MFP    |Alternate Function Setting For PB2MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2C_SCL
S     * |        |          |10 = CMP2
S     * |        |          |11 = SPI_SCLK
S     * |[6:7]   |PB3MFP    |Alternate Function Setting For PB3MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2C_SDA
S     * |        |          |10 = CMP3
S     * |        |          |11 = SPI_MISO0
S     * |[8:9]   |PB4MFP    |Alternate Function Setting For PB4MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = PWM0CH0_INV(PWM0 channel 0 invert output pin)
S     * |        |          |10 = CMP4
S     * |        |          |11 = SPI_MOSI0
S     * |[10:11] |PB5MFP    |Alternate Function Setting For PB5MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = PWM0CH1_INV(PWM0 channel 1 invert output pin)
S     * |        |          |10 = CMP5
S     * |        |          |11 = SPI_MISO1
S     * |[12:13] |PB6MFP    |Alternate Function Setting For PB6MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2S_SDI
S     * |        |          |10 = CMP6
S     * |        |          |11 = SPI_MOSI1
S     * |[14:15] |PB7MFP    |Alternate Function Setting For PB7MFP
S     * |        |          |00 = GPIO
S     * |        |          |01 = I2S_SDO
S     * |        |          |10 = CMP7
S */
S    __IO uint32_t GPB_MFP;               
S         uint32_t RESERVE2[5];
S
S
S    /**
S     * WKCTL
S     * ===================================================================================================
S     * Offset: 0x54  WAKEUP pin control register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKDIN     |State Of Wakeup Pin
S     * |        |          |Read only.
S     * |[1]     |WKPUEN    |Wakeup Pin Pull-up Control
S     * |        |          |This signal is latched in deep power down and preserved.
S     * |        |          |0 = pull-up enable
S     * |        |          |1 = tristate (default)
S     * |[2]     |WKOENB    |Wakeup Pin Output Enable Bar
S     * |        |          |0 = drive WKDOUT to pin
S     * |        |          |1 = tristate (default)
S     * |[3]     |WKDOUT    |Wakeup Output State
S     * |        |          |0 = drive Low if the corresponding output mode bit is set (default)
S     * |        |          |1 = drive High if the corresponding output mode bit is set
S */
S    __IO uint32_t WKCTL;                 
S         uint32_t RESERVE3[42];
S
S
S    /**
S     * REGLCTL
S     * ===================================================================================================
S     * Offset: 0x100  Register Lock Key Address register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |REGLCTL   |Protected Register Unlock Register
S     * |        |          |0 = Protected registers are locked. Any write to the target register is ignored.
S     * |        |          |1 = Protected registers are unlocked
S */
S    __IO uint32_t REGLCTL;               
S         uint32_t RESERVE4[3];
S
S
S    /**
S     * IRCTCTL
S     * ===================================================================================================
S     * Offset: 0x110  Oscillator Frequency Adjustment control register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |FREQ0SEL  |8 Bit Trim For Oscillator
S     * |        |          |FREQ0SEL [7:5] are 8 coarse trim ranges which overlap in frequency.
S     * |        |          |FREQ0SEL [4:0] are 32 fine trim steps of approximately 0.5% resolution.
S     * |[8]     |RGE0SEL   |Range Bit For Oscillator
S     * |        |          |0 = high range
S     * |        |          |1 = low range
S     * |[16:23] |FREQ1SEL  |8 Bit Trim For Oscillator
S     * |        |          |FREQ1SEL [7:5] are 8 coarse trim ranges which overlap in frequency.
S     * |        |          |FREQ1SEL [4:0] are 32 fine trim steps of approximately 0.5% resolution.
S     * |[24]    |RGE1SEL   |Range Bit For Oscillator
S     * |        |          |0 = high range
S     * |        |          |1 = low range
S */
S    __IO uint32_t IRCTCTL;               
S
S} SYS_T;
S
S/**
S    @addtogroup SYS_CONST SYS Bit Field Definition
S    Constant Definitions for SYS Controller
S@{ */
S
S#define SYS_RSTSTS_CORERSTF_Pos          (0)                                               /*!< SYS RSTSTS: CORERSTF Position          */
S#define SYS_RSTSTS_CORERSTF_Msk          (0x1ul << SYS_RSTSTS_CORERSTF_Pos)                /*!< SYS RSTSTS: CORERSTF Mask              */
S
S#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS RSTSTS: WDTRF Position             */
S#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS RSTSTS: WDTRF Mask                 */
S
S#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS RSTSTS: SYSRF Position             */
S#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS RSTSTS: SYSRF Mask                 */
S
S#define SYS_RSTSTS_PMURSTF_Pos           (6)                                               /*!< SYS RSTSTS: PMURSTF Position           */
S#define SYS_RSTSTS_PMURSTF_Msk           (0x1ul << SYS_RSTSTS_PMURSTF_Pos)                 /*!< SYS RSTSTS: PMURSTF Mask               */
S
S#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS RSTSTS: CPURF Position             */
S#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS RSTSTS: CPURF Mask                 */
S
S#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS IPRST0: CHIPRST Position           */
S#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS IPRST0: CHIPRST Mask               */
S
S#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS IPRST0: CPURST Position            */
S#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS IPRST0: CPURST Mask                */
S
S#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS IPRST0: PDMARST Position           */
S#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS IPRST0: PDMARST Mask               */
S
S#define SYS_IPRST1_TMR0RST_Pos           (6)                                               /*!< SYS IPRST1: TMR0RST Position           */
S#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS IPRST1: TMR0RST Mask               */
S
S#define SYS_IPRST1_TMR1RST_Pos           (7)                                               /*!< SYS IPRST1: TMR1RST Position           */
S#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS IPRST1: TMR1RST Mask               */
S
S#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS IPRST1: I2C0RST Position           */
S#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS IPRST1: I2C0RST Mask               */
S
S#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS IPRST1: SPI0RST Position           */
S#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS IPRST1: SPI0RST Mask               */
S
S#define SYS_IPRST1_DPWMRST_Pos           (13)                                              /*!< SYS IPRST1: DPWMRST Position           */
S#define SYS_IPRST1_DPWMRST_Msk           (0x1ul << SYS_IPRST1_DPWMRST_Pos)                 /*!< SYS IPRST1: DPWMRST Mask               */
S
S#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS IPRST1: UART0RST Position          */
S#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS IPRST1: UART0RST Mask              */
S
S#define SYS_IPRST1_BIQRST_Pos            (18)                                              /*!< SYS IPRST1: BIQRST Position            */
S#define SYS_IPRST1_BIQRST_Msk            (0x1ul << SYS_IPRST1_BIQRST_Pos)                  /*!< SYS IPRST1: BIQRST Mask                */
S
S#define SYS_IPRST1_CRCRST_Pos            (19)                                              /*!< SYS IPRST1: CRCRST Position            */
S#define SYS_IPRST1_CRCRST_Msk            (0x1ul << SYS_IPRST1_CRCRST_Pos)                  /*!< SYS IPRST1: CRCRST Mask                */
S
S#define SYS_IPRST1_PWM0RST_Pos           (20)                                              /*!< SYS IPRST1: PWM0RST Position           */
S#define SYS_IPRST1_PWM0RST_Msk           (0x1ul << SYS_IPRST1_PWM0RST_Pos)                 /*!< SYS IPRST1: PWM0RST Mask               */
S
S#define SYS_IPRST1_ACMPRST_Pos           (22)                                              /*!< SYS IPRST1: ACMPRST Position           */
S#define SYS_IPRST1_ACMPRST_Msk           (0x1ul << SYS_IPRST1_ACMPRST_Pos)                 /*!< SYS IPRST1: ACMPRST Mask               */
S
S#define SYS_IPRST1_EADCRST_Pos           (28)                                              /*!< SYS IPRST1: EADCRST Position           */
S#define SYS_IPRST1_EADCRST_Msk           (0x1ul << SYS_IPRST1_EADCRST_Pos)                 /*!< SYS IPRST1: EADCRST Mask               */
S
S#define SYS_IPRST1_I2S0RST_Pos           (29)                                              /*!< SYS IPRST1: I2S0RST Position           */
S#define SYS_IPRST1_I2S0RST_Msk           (0x1ul << SYS_IPRST1_I2S0RST_Pos)                 /*!< SYS IPRST1: I2S0RST Mask               */
S
S#define SYS_IPRST1_ANARST_Pos            (30)                                              /*!< SYS IPRST1: ANARST Position            */
S#define SYS_IPRST1_ANARST_Msk            (0x1ul << SYS_IPRST1_ANARST_Pos)                  /*!< SYS IPRST1: ANARST Mask                */
S
S#define SYS_PASMTEN_SMTEN16_Pos          (16)                                              /*!< SYS PASMTEN: SMTEN16 Position          */
S#define SYS_PASMTEN_SMTEN16_Msk          (0x1ul << SYS_PASMTEN_SMTEN16_Pos)                /*!< SYS PASMTEN: SMTEN16 Mask              */
S
S#define SYS_PASMTEN_SMTEN17_Pos          (17)                                              /*!< SYS PASMTEN: SMTEN17 Position          */
S#define SYS_PASMTEN_SMTEN17_Msk          (0x1ul << SYS_PASMTEN_SMTEN17_Pos)                /*!< SYS PASMTEN: SMTEN17 Mask              */
S
S#define SYS_PASMTEN_SMTEN18_Pos          (18)                                              /*!< SYS PASMTEN: SMTEN18 Position          */
S#define SYS_PASMTEN_SMTEN18_Msk          (0x1ul << SYS_PASMTEN_SMTEN18_Pos)                /*!< SYS PASMTEN: SMTEN18 Mask              */
S
S#define SYS_PASMTEN_SMTEN19_Pos          (19)                                              /*!< SYS PASMTEN: SMTEN19 Position          */
S#define SYS_PASMTEN_SMTEN19_Msk          (0x1ul << SYS_PASMTEN_SMTEN19_Pos)                /*!< SYS PASMTEN: SMTEN19 Mask              */
S
S#define SYS_PASMTEN_SMTEN20_Pos          (20)                                              /*!< SYS PASMTEN: SMTEN20 Position          */
S#define SYS_PASMTEN_SMTEN20_Msk          (0x1ul << SYS_PASMTEN_SMTEN20_Pos)                /*!< SYS PASMTEN: SMTEN20 Mask              */
S
S#define SYS_PASMTEN_SMTEN21_Pos          (21)                                              /*!< SYS PASMTEN: SMTEN21 Position          */
S#define SYS_PASMTEN_SMTEN21_Msk          (0x1ul << SYS_PASMTEN_SMTEN21_Pos)                /*!< SYS PASMTEN: SMTEN21 Mask              */
S
S#define SYS_PASMTEN_SMTEN22_Pos          (22)                                              /*!< SYS PASMTEN: SMTEN22 Position          */
S#define SYS_PASMTEN_SMTEN22_Msk          (0x1ul << SYS_PASMTEN_SMTEN22_Pos)                /*!< SYS PASMTEN: SMTEN22 Mask              */
S
S#define SYS_PASMTEN_SMTEN23_Pos          (23)                                              /*!< SYS PASMTEN: SMTEN23 Position          */
S#define SYS_PASMTEN_SMTEN23_Msk          (0x1ul << SYS_PASMTEN_SMTEN23_Pos)                /*!< SYS PASMTEN: SMTEN23 Mask              */
S
S#define SYS_PASMTEN_SMTEN24_Pos          (24)                                              /*!< SYS PASMTEN: SMTEN24 Position          */
S#define SYS_PASMTEN_SMTEN24_Msk          (0x1ul << SYS_PASMTEN_SMTEN24_Pos)                /*!< SYS PASMTEN: SMTEN24 Mask              */
S
S#define SYS_PASMTEN_SMTEN25_Pos          (25)                                              /*!< SYS PASMTEN: SMTEN25 Position          */
S#define SYS_PASMTEN_SMTEN25_Msk          (0x1ul << SYS_PASMTEN_SMTEN25_Pos)                /*!< SYS PASMTEN: SMTEN25 Mask              */
S
S#define SYS_PASMTEN_SMTEN26_Pos          (26)                                              /*!< SYS PASMTEN: SMTEN26 Position          */
S#define SYS_PASMTEN_SMTEN26_Msk          (0x1ul << SYS_PASMTEN_SMTEN26_Pos)                /*!< SYS PASMTEN: SMTEN26 Mask              */
S
S#define SYS_PASMTEN_SMTEN27_Pos          (27)                                              /*!< SYS PASMTEN: SMTEN27 Position          */
S#define SYS_PASMTEN_SMTEN27_Msk          (0x1ul << SYS_PASMTEN_SMTEN27_Pos)                /*!< SYS PASMTEN: SMTEN27 Mask              */
S
S#define SYS_PASMTEN_SMTEN28_Pos          (28)                                              /*!< SYS PASMTEN: SMTEN28 Position          */
S#define SYS_PASMTEN_SMTEN28_Msk          (0x1ul << SYS_PASMTEN_SMTEN28_Pos)                /*!< SYS PASMTEN: SMTEN28 Mask              */
S
S#define SYS_PASMTEN_SMTEN29_Pos          (29)                                              /*!< SYS PASMTEN: SMTEN29 Position          */
S#define SYS_PASMTEN_SMTEN29_Msk          (0x1ul << SYS_PASMTEN_SMTEN29_Pos)                /*!< SYS PASMTEN: SMTEN29 Mask              */
S
S#define SYS_PASMTEN_SMTEN30_Pos          (30)                                              /*!< SYS PASMTEN: SMTEN30 Position          */
S#define SYS_PASMTEN_SMTEN30_Msk          (0x1ul << SYS_PASMTEN_SMTEN30_Pos)                /*!< SYS PASMTEN: SMTEN30 Mask              */
S
S#define SYS_PASMTEN_SMTEN31_Pos          (31)                                              /*!< SYS PASMTEN: SMTEN31 Position          */
S#define SYS_PASMTEN_SMTEN31_Msk          (0x1ul << SYS_PASMTEN_SMTEN31_Pos)                /*!< SYS PASMTEN: SMTEN31 Mask              */
S
S#define SYS_PBSMTEN_SMTEN16_Pos          (16)                                              /*!< SYS PBSMTEN: SMTEN16 Position          */
S#define SYS_PBSMTEN_SMTEN16_Msk          (0x1ul << SYS_PBSMTEN_SMTEN16_Pos)                /*!< SYS PBSMTEN: SMTEN16 Mask              */
S
S#define SYS_PBSMTEN_SMTEN17_Pos          (17)                                              /*!< SYS PBSMTEN: SMTEN17 Position          */
S#define SYS_PBSMTEN_SMTEN17_Msk          (0x1ul << SYS_PBSMTEN_SMTEN17_Pos)                /*!< SYS PBSMTEN: SMTEN17 Mask              */
S
S#define SYS_PBSMTEN_SMTEN18_Pos          (18)                                              /*!< SYS PBSMTEN: SMTEN18 Position          */
S#define SYS_PBSMTEN_SMTEN18_Msk          (0x1ul << SYS_PBSMTEN_SMTEN18_Pos)                /*!< SYS PBSMTEN: SMTEN18 Mask              */
S
S#define SYS_PBSMTEN_SMTEN19_Pos          (19)                                              /*!< SYS PBSMTEN: SMTEN19 Position          */
S#define SYS_PBSMTEN_SMTEN19_Msk          (0x1ul << SYS_PBSMTEN_SMTEN19_Pos)                /*!< SYS PBSMTEN: SMTEN19 Mask              */
S
S#define SYS_PBSMTEN_SMTEN20_Pos          (20)                                              /*!< SYS PBSMTEN: SMTEN20 Position          */
S#define SYS_PBSMTEN_SMTEN20_Msk          (0x1ul << SYS_PBSMTEN_SMTEN20_Pos)                /*!< SYS PBSMTEN: SMTEN20 Mask              */
S
S#define SYS_PBSMTEN_SMTEN21_Pos          (21)                                              /*!< SYS PBSMTEN: SMTEN21 Position          */
S#define SYS_PBSMTEN_SMTEN21_Msk          (0x1ul << SYS_PBSMTEN_SMTEN21_Pos)                /*!< SYS PBSMTEN: SMTEN21 Mask              */
S
S#define SYS_PBSMTEN_SMTEN22_Pos          (22)                                              /*!< SYS PBSMTEN: SMTEN22 Position          */
S#define SYS_PBSMTEN_SMTEN22_Msk          (0x1ul << SYS_PBSMTEN_SMTEN22_Pos)                /*!< SYS PBSMTEN: SMTEN22 Mask              */
S
S#define SYS_PBSMTEN_SMTEN23_Pos          (23)                                              /*!< SYS PBSMTEN: SMTEN23 Position          */
S#define SYS_PBSMTEN_SMTEN23_Msk          (0x1ul << SYS_PBSMTEN_SMTEN23_Pos)                /*!< SYS PBSMTEN: SMTEN23 Mask              */
S
S#define SYS_GPA_MFP_PA0MFP_Pos           (0)                                               /*!< SYS GPA_MFP: PA0MFP Position           */
S#define SYS_GPA_MFP_PA0MFP_Msk           (0x3ul << SYS_GPA_MFP_PA0MFP_Pos)                 /*!< SYS GPA_MFP: PA0MFP Mask               */
S
S#define SYS_GPA_MFP_PA1MFP_Pos           (2)                                               /*!< SYS GPA_MFP: PA1MFP Position           */
S#define SYS_GPA_MFP_PA1MFP_Msk           (0x3ul << SYS_GPA_MFP_PA1MFP_Pos)                 /*!< SYS GPA_MFP: PA1MFP Mask               */
S
S#define SYS_GPA_MFP_PA2MFP_Pos           (4)                                               /*!< SYS GPA_MFP: PA2MFP Position           */
S#define SYS_GPA_MFP_PA2MFP_Msk           (0x3ul << SYS_GPA_MFP_PA2MFP_Pos)                 /*!< SYS GPA_MFP: PA2MFP Mask               */
S
S#define SYS_GPA_MFP_PA3MFP_Pos           (6)                                               /*!< SYS GPA_MFP: PA3MFP Position           */
S#define SYS_GPA_MFP_PA3MFP_Msk           (0x3ul << SYS_GPA_MFP_PA3MFP_Pos)                 /*!< SYS GPA_MFP: PA3MFP Mask               */
S
S#define SYS_GPA_MFP_PA4MFP_Pos           (8)                                               /*!< SYS GPA_MFP: PA4MFP Position           */
S#define SYS_GPA_MFP_PA4MFP_Msk           (0x3ul << SYS_GPA_MFP_PA4MFP_Pos)                 /*!< SYS GPA_MFP: PA4MFP Mask               */
S
S#define SYS_GPA_MFP_PA5MFP_Pos           (10)                                              /*!< SYS GPA_MFP: PA5MFP Position           */
S#define SYS_GPA_MFP_PA5MFP_Msk           (0x3ul << SYS_GPA_MFP_PA5MFP_Pos)                 /*!< SYS GPA_MFP: PA5MFP Mask               */
S
S#define SYS_GPA_MFP_PA6MFP_Pos           (12)                                              /*!< SYS GPA_MFP: PA6MFP Position           */
S#define SYS_GPA_MFP_PA6MFP_Msk           (0x3ul << SYS_GPA_MFP_PA6MFP_Pos)                 /*!< SYS GPA_MFP: PA6MFP Mask               */
S
S#define SYS_GPA_MFP_PA7MFP_Pos           (14)                                              /*!< SYS GPA_MFP: PA7MFP Position           */
S#define SYS_GPA_MFP_PA7MFP_Msk           (0x3ul << SYS_GPA_MFP_PA7MFP_Pos)                 /*!< SYS GPA_MFP: PA7MFP Mask               */
S
S#define SYS_GPA_MFP_PA8MFP_Pos           (16)                                              /*!< SYS GPA_MFP: PA8MFP Position           */
S#define SYS_GPA_MFP_PA8MFP_Msk           (0x3ul << SYS_GPA_MFP_PA8MFP_Pos)                 /*!< SYS GPA_MFP: PA8MFP Mask               */
S
S#define SYS_GPA_MFP_PA9MFP_Pos           (18)                                              /*!< SYS GPA_MFP: PA9MFP Position           */
S#define SYS_GPA_MFP_PA9MFP_Msk           (0x3ul << SYS_GPA_MFP_PA9MFP_Pos)                 /*!< SYS GPA_MFP: PA9MFP Mask               */
S
S#define SYS_GPA_MFP_PA10MFP_Pos          (20)                                              /*!< SYS GPA_MFP: PA10MFP Position          */
S#define SYS_GPA_MFP_PA10MFP_Msk          (0x3ul << SYS_GPA_MFP_PA10MFP_Pos)                /*!< SYS GPA_MFP: PA10MFP Mask              */
S
S#define SYS_GPA_MFP_PA11MFP_Pos          (22)                                              /*!< SYS GPA_MFP: PA11MFP Position          */
S#define SYS_GPA_MFP_PA11MFP_Msk          (0x3ul << SYS_GPA_MFP_PA11MFP_Pos)                /*!< SYS GPA_MFP: PA11MFP Mask              */
S
S#define SYS_GPA_MFP_PA12MFP_Pos          (24)                                              /*!< SYS GPA_MFP: PA12MFP Position          */
S#define SYS_GPA_MFP_PA12MFP_Msk          (0x3ul << SYS_GPA_MFP_PA12MFP_Pos)                /*!< SYS GPA_MFP: PA12MFP Mask              */
S
S#define SYS_GPA_MFP_PA13MFP_Pos          (26)                                              /*!< SYS GPA_MFP: PA13MFP Position          */
S#define SYS_GPA_MFP_PA13MFP_Msk          (0x3ul << SYS_GPA_MFP_PA13MFP_Pos)                /*!< SYS GPA_MFP: PA13MFP Mask              */
S
S#define SYS_GPA_MFP_PA14MFP_Pos          (28)                                              /*!< SYS GPA_MFP: PA14MFP Position          */
S#define SYS_GPA_MFP_PA14MFP_Msk          (0x3ul << SYS_GPA_MFP_PA14MFP_Pos)                /*!< SYS GPA_MFP: PA14MFP Mask              */
S
S#define SYS_GPA_MFP_PA15MFP_Pos          (30)                                              /*!< SYS GPA_MFP: PA15MFP Position          */
S#define SYS_GPA_MFP_PA15MFP_Msk          (0x3ul << SYS_GPA_MFP_PA15MFP_Pos)                /*!< SYS GPA_MFP: PA15MFP Mask              */
S
S#define SYS_GPB_MFP_PB0MFP_Pos           (0)                                               /*!< SYS GPB_MFP: PB0MFP Position           */
S#define SYS_GPB_MFP_PB0MFP_Msk           (0x3ul << SYS_GPB_MFP_PB0MFP_Pos)                 /*!< SYS GPB_MFP: PB0MFP Mask               */
S
S#define SYS_GPB_MFP_PB1MFP_Pos           (2)                                               /*!< SYS GPB_MFP: PB1MFP Position           */
S#define SYS_GPB_MFP_PB1MFP_Msk           (0x3ul << SYS_GPB_MFP_PB1MFP_Pos)                 /*!< SYS GPB_MFP: PB1MFP Mask               */
S
S#define SYS_GPB_MFP_PB2MFP_Pos           (4)                                               /*!< SYS GPB_MFP: PB2MFP Position           */
S#define SYS_GPB_MFP_PB2MFP_Msk           (0x3ul << SYS_GPB_MFP_PB2MFP_Pos)                 /*!< SYS GPB_MFP: PB2MFP Mask               */
S
S#define SYS_GPB_MFP_PB3MFP_Pos           (6)                                               /*!< SYS GPB_MFP: PB3MFP Position           */
S#define SYS_GPB_MFP_PB3MFP_Msk           (0x3ul << SYS_GPB_MFP_PB3MFP_Pos)                 /*!< SYS GPB_MFP: PB3MFP Mask               */
S
S#define SYS_GPB_MFP_PB4MFP_Pos           (8)                                               /*!< SYS GPB_MFP: PB4MFP Position           */
S#define SYS_GPB_MFP_PB4MFP_Msk           (0x3ul << SYS_GPB_MFP_PB4MFP_Pos)                 /*!< SYS GPB_MFP: PB4MFP Mask               */
S
S#define SYS_GPB_MFP_PB5MFP_Pos           (10)                                              /*!< SYS GPB_MFP: PB5MFP Position           */
S#define SYS_GPB_MFP_PB5MFP_Msk           (0x3ul << SYS_GPB_MFP_PB5MFP_Pos)                 /*!< SYS GPB_MFP: PB5MFP Mask               */
S
S#define SYS_GPB_MFP_PB6MFP_Pos           (12)                                              /*!< SYS GPB_MFP: PB6MFP Position           */
S#define SYS_GPB_MFP_PB6MFP_Msk           (0x3ul << SYS_GPB_MFP_PB6MFP_Pos)                 /*!< SYS GPB_MFP: PB6MFP Mask               */
S
S#define SYS_GPB_MFP_PB7MFP_Pos           (14)                                              /*!< SYS GPB_MFP: PB7MFP Position           */
S#define SYS_GPB_MFP_PB7MFP_Msk           (0x3ul << SYS_GPB_MFP_PB7MFP_Pos)                 /*!< SYS GPB_MFP: PB7MFP Mask               */
S
S#define SYS_WKCTL_WKDIN_Pos              (0)                                               /*!< SYS WKCTL: WKDIN Position              */
S#define SYS_WKCTL_WKDIN_Msk              (0x1ul << SYS_WKCTL_WKDIN_Pos)                    /*!< SYS WKCTL: WKDIN Mask                  */
S
S#define SYS_WKCTL_WKPUEN_Pos             (1)                                               /*!< SYS WKCTL: WKPUEN Position             */
S#define SYS_WKCTL_WKPUEN_Msk             (0x1ul << SYS_WKCTL_WKPUEN_Pos)                   /*!< SYS WKCTL: WKPUEN Mask                 */
S
S#define SYS_WKCTL_WKOENB_Pos             (2)                                               /*!< SYS WKCTL: WKOENB Position             */
S#define SYS_WKCTL_WKOENB_Msk             (0x1ul << SYS_WKCTL_WKOENB_Pos)                   /*!< SYS WKCTL: WKOENB Mask                 */
S
S#define SYS_WKCTL_WKDOUT_Pos             (3)                                               /*!< SYS WKCTL: WKDOUT Position             */
S#define SYS_WKCTL_WKDOUT_Msk             (0x1ul << SYS_WKCTL_WKDOUT_Pos)                   /*!< SYS WKCTL: WKDOUT Mask                 */
S
S#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS REGLCTL: REGLCTL Position          */
S#define SYS_REGLCTL_REGLCTL_Msk          (0x1ul << SYS_REGLCTL_REGLCTL_Pos)                /*!< SYS REGLCTL: REGLCTL Mask              */
S
S#define SYS_IRCTCTL_FREQ0SEL_Pos         (0)                                               /*!< SYS IRCTCTL: FREQ0SEL Position         */
S#define SYS_IRCTCTL_FREQ0SEL_Msk         (0xfful << SYS_IRCTCTL_FREQ0SEL_Pos)              /*!< SYS IRCTCTL: FREQ0SEL Mask             */
S
S#define SYS_IRCTCTL_RGE0SEL_Pos          (8)                                               /*!< SYS IRCTCTL: RGE0SEL Position          */
S#define SYS_IRCTCTL_RGE0SEL_Msk          (0x1ul << SYS_IRCTCTL_RGE0SEL_Pos)                /*!< SYS IRCTCTL: RGE0SEL Mask              */
S
S#define SYS_IRCTCTL_FREQ1SEL_Pos         (16)                                              /*!< SYS IRCTCTL: FREQ1SEL Position         */
S#define SYS_IRCTCTL_FREQ1SEL_Msk         (0xfful << SYS_IRCTCTL_FREQ1SEL_Pos)              /*!< SYS IRCTCTL: FREQ1SEL Mask             */
S
S#define SYS_IRCTCTL_RGE1SEL_Pos          (24)                                              /*!< SYS IRCTCTL: RGE1SEL Position          */
S#define SYS_IRCTCTL_RGE1SEL_Msk          (0x1ul << SYS_IRCTCTL_RGE1SEL_Pos)                /*!< SYS IRCTCTL: RGE1SEL Mask              */
S
S/**@}*/ /* SYS_CONST */
S/**@}*/ /* end of SYS register group */
S
S
S/*---------------------- Timer Controller -------------------------*/
S/**
S    @addtogroup TMR Timer Controller(TMR)
S    Memory Mapped Structure for TMR Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  Timer Control and Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |PSC       |Pre-scale Counter
S     * |        |          |Clock input is divided by PSC+1 before it is fed to the counter. If PSC = 0, then there is no scaling.
S     * |[16]    |CNTDATEN  |Data Latch Enable
S     * |        |          |When CNTDATEN is set, TIMERx_CNT (Timer Data Register) will be updated continuously with the 24-bit up-counter value as the timer is counting.
S     * |        |          |1 = Timer Data Register update enable.
S     * |        |          |0 = Timer Data Register update disable. 
S     * |[25]    |ACTSTS    |Timer Active Status Bit (Read only)
S     * |        |          |This bit indicates the counter status of timer.
S     * |        |          |0 = Timer is not active.
S     * |        |          |1 = Timer is active.
S     * |[26]    |RSTCNT    |Counter Reset Bit
S     * |        |          |Set this bit will reset the timer counter, prescale and also force CNTEN to 0.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset Timer's prescale counter, internal 24-bit up-counter and CNTEN bit.
S     * |[27:28] |OPMODE    |Timer Operating Mode
S     * |        |          |0 = The timer is operating in the one-shot mode.
S     * |        |          |The associated interrupt signal is generated once (if INTEN is enabled) and CNTEN is automatically cleared by hardware.
S     * |        |          |1 = The timer is operating in the periodic mode.
S     * |        |          |The associated interrupt signal is generated periodically (if INTEN is enabled).
S     * |        |          |2 = Reserved.
S     * |        |          |3 = The timer is operating in continuous counting mode.
S     * |        |          |The associated interrupt signal is generated when CNT = CMPDAT (if INTEN is enabled); however, the 24-bit up-counter counts continuously without reset.
S     * |[29]    |INTEN     |Interrupt Enable Bit
S     * |        |          |0 = Disable TIMER Interrupt.
S     * |        |          |1 = Enable TIMER Interrupt.
S     * |        |          |If timer interrupt is enabled, the timer asserts its interrupt signal when the count is equal to TIMERx_CMP.
S     * |[30]    |CNTEN     |Counter Enable Bit
S     * |        |          |0 = Stops/Suspends counting
S     * |        |          |1 = Starts counting
S     * |        |          |Note1: Setting CNTEN = 1 enables 24-bit counter. It continues count from last value.
S     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (OPMODE = 00b) when the timer interrupt is generated (INTEN = 1b).
S */
S    __IO uint32_t CTL;                   
S
S    /**
S     * CMP
S     * ===================================================================================================
S     * Offset: 0x04  Timer Compare Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:24]  |CMPDAT    |Timer Comparison Value
S     * |        |          |CMPDAT is a 24-bit comparison register.
S     * |        |          |When the 24-bit up-counter is enabled and its value is equal to CMPDAT value, a Timer Interrupt is requested if the timer interrupt is enabled with TIMERx_CTL.INTEN = 1.
S     * |        |          |The CMPDAT value defines the timer cycle time.
S     * |        |          |Time out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT)
S     * |        |          |NOTE1: Never set CMPDAT to 0x000 or 0x001. Timer will not function correctly.
S     * |        |          |NOTE2: Regardless of CNTEN state, whenever a new value is written to this register, TIMER will restart counting using this new value and abort previous count.
S */
S    __IO uint32_t CMP;                   
S
S    /**
S     * INTSTS
S     * ===================================================================================================
S     * Offset: 0x08  Timer Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Timer Interrupt Flag
S     * |        |          |This bit indicates the interrupt status of Timer.
S     * |        |          |TIF bit is set by hardware when the 24-bit counter matches the timer comparison value (CMPDAT).
S     * |        |          |It is cleared by writing 1.
S */
S    __IO uint32_t INTSTS;                
S
S    /**
S     * CNT
S     * ===================================================================================================
S     * Offset: 0x0C  Timer Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:23]  |CNT       |Timer Data Register
S     * |        |          |When TIMERx_CTL.CNTDATEN is set to 1, the internal 24-bit timer up-counter value will be latched into CNT.
S     * |        |          |User can read this register for the up-counter value.
S */
S    __IO uint32_t CNT;                   
S
S} TMR_T;
S
S/**
S    @addtogroup TMR_CONST TMR Bit Field Definition
S    Constant Definitions for TMR Controller
S@{ */
S
S#define TMR_CTL_PSC_Pos                  (0)                                               /*!< TMR CTL: PSC Position                  */
S#define TMR_CTL_PSC_Msk                  (0xfful << TMR_CTL_PSC_Pos)                       /*!< TMR CTL: PSC Mask                      */
S
S#define TMR_CTL_CNTDATEN_Pos             (16)                                              /*!< TMR CTL: CNTDATEN Position             */
S#define TMR_CTL_CNTDATEN_Msk             (0x1ul << TMR_CTL_CNTDATEN_Pos)                   /*!< TMR CTL: CNTDATEN Mask                 */
S
S#define TMR_CTL_ACTSTS_Pos               (25)                                              /*!< TMR CTL: ACTSTS Position               */
S#define TMR_CTL_ACTSTS_Msk               (0x1ul << TMR_CTL_ACTSTS_Pos)                     /*!< TMR CTL: ACTSTS Mask                   */
S
S#define TMR_CTL_RSTCNT_Pos               (26)                                              /*!< TMR CTL: RSTCNT Position               */
S#define TMR_CTL_RSTCNT_Msk               (0x1ul << TMR_CTL_RSTCNT_Pos)                     /*!< TMR CTL: RSTCNT Mask                   */
S
S#define TMR_CTL_OPMODE_Pos               (27)                                              /*!< TMR CTL: OPMODE Position               */
S#define TMR_CTL_OPMODE_Msk               (0x3ul << TMR_CTL_OPMODE_Pos)                     /*!< TMR CTL: OPMODE Mask                   */
S
S#define TMR_CTL_INTEN_Pos                (29)                                              /*!< TMR CTL: INTEN Position                */
S#define TMR_CTL_INTEN_Msk                (0x1ul << TMR_CTL_INTEN_Pos)                      /*!< TMR CTL: INTEN Mask                    */
S
S#define TMR_CTL_CNTEN_Pos                (30)                                              /*!< TMR CTL: CNTEN Position                */
S#define TMR_CTL_CNTEN_Msk                (0x1ul << TMR_CTL_CNTEN_Pos)                      /*!< TMR CTL: CNTEN Mask                    */
S
S#define TMR_CMP_CMPDAT_Pos               (0)                                               /*!< TMR CMP: CMPDAT Position               */
S#define TMR_CMP_CMPDAT_Msk               (0x1fffffful << TMR_CMP_CMPDAT_Pos)               /*!< TMR CMP: CMPDAT Mask                   */
S
S#define TMR_INTSTS_TIF_Pos               (0)                                               /*!< TMR INTSTS: TIF Position               */
S#define TMR_INTSTS_TIF_Msk               (0x1ul << TMR_INTSTS_TIF_Pos)                     /*!< TMR INTSTS: TIF Mask                   */
S
S#define TMR_CNT_CNT_Pos                  (0)                                               /*!< TMR CNT: CNT Position                  */
S#define TMR_CNT_CNT_Msk                  (0xfffffful << TMR_CNT_CNT_Pos)                   /*!< TMR CNT: CNT Mask                      */
S
S/**@}*/ /* TMR_CONST */
S/**@}*/ /* end of TMR register group */
S
S
S/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
S/**
S    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
S    Memory Mapped Structure for UART Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * DAT
S     * ===================================================================================================
S     * Offset: 0x00  UART0 Receive/Transfer FIFO Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:7]   |DAT       |Receive FIFO Register
S     * |        |          |Reading this register will return data from the receive data FIFO.
S     * |        |          |By reading this register, the UART will return the 8-bit data received from Rx pin (LSB first).
S */
S    __IO uint32_t DAT;                   
S
S    /**
S     * INTEN
S     * ===================================================================================================
S     * Offset: 0x04  UART0 Interrupt Enable Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable.
S     * |        |          |0 = Mask off RDAINT
S     * |        |          |1 = Enable RDAINT
S     * |[1]     |THREIEN   |Transmit FIFO Register Empty Interrupt Enable
S     * |        |          |0 = Mask off THERINT
S     * |        |          |1 = Enable THERINT
S     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable
S     * |        |          |0 = Mask off RLSINT
S     * |        |          |1 = Enable RLSINT
S     * |[3]     |MODEMIEN  |Modem Status Interrupt Enable
S     * |        |          |0 = Mask off MODEMINT
S     * |        |          |1 = Enable MODEMINT
S     * |[4]     |RXTOIEN   |Receive Time out Interrupt Enable
S     * |        |          |0 = Mask off RXTOINT
S     * |        |          |1 = Enable RXTOINT
S     * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable
S     * |        |          |0 = Mask off BUFERRINT
S     * |        |          |1 = Enable IBUFERRINT
S     * |[8]     |LINIEN    |LIN RX Break Field Detected Interrupt Enable
S     * |        |          |0 = Mask off Lin bus Rx break field interrupt.
S     * |        |          |1 = Enable Lin bus Rx break field interrupt.
S     * |[11]    |TOCNTEN   |Time-Out Counter Enable
S     * |        |          |0 = Disable Time-out counter.
S     * |        |          |1 = Enable.
S     * |[12]    |ATORTSEN  |RTS Auto Flow Control Enable
S     * |        |          |0 = Disable RTS auto flow control.
S     * |        |          |1 = Enable.
S     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals UART_FIFO.RTSTRGLV, the UART will de-assert the RTS signal.
S     * |[13]    |ATOCTSEN  |CTS Auto Flow Control Enable
S     * |        |          |0 = Disable CTS auto flow control.
S     * |        |          |1 = Enable.
S     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input is asserted (UART will not send data to device until CTS is asserted).
S     * |[14]    |DMATXEN   |Transmit DMA Enable
S     * |        |          |If enabled, the UART will request DMA service when space is available in transmit FIFO.
S     * |[15]    |DMARXEN   |Receive DMA Enable
S     * |        |          |If enabled, the UART will request DMA service when data is available in receive FIFO. 
S */
S    __IO uint32_t INTEN;                 
S
S    /**
S     * FIFO
S     * ===================================================================================================
S     * Offset: 0x08  UART0 FIFO Control Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RXRST     |Receive FIFO Reset
S     * |        |          |When RXRST is set, all the bytes in the receive FIFO are cleared and receive internal state machine is reset.
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the receiving internal state machine and pointers.
S     * |        |          |Note: This bit will auto-clear after 3 UART engine clock cycles.
S     * |[2]     |TXRST     |Transmit FIFO Reset
S     * |        |          |When TXRST is set, all the bytes in the transmit FIFO are cleared and transmit internal state machine is reset.
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the transmitting internal state machine and pointers.
S     * |        |          |Note: This bit will auto-clear after 3 UART engine clock cycles.
S     * |[4:7]   |RFITL     |Receive FIFO Interrupt (RDAINT) Trigger Level
S     * |        |          |When the number of bytes in the receive FIFO equals the RFITL then the RDAIF will be set and, if enabled, an RDAINT interrupt will generated.
S     * |        |          |Value : INTR_RDA Trigger Level (Bytes)
S     * |        |          |0 : 1
S     * |        |          |1 : 4
S     * |        |          |2 : 8
S     * |[16:19] |RTSTRGLV  |RTS Trigger Level for Auto-flow Control
S     * |        |          |Sets the FIFO trigger level when auto-flow control will de-assert RTS (request-to-send).
S     * |        |          |Value : Trigger Level (Bytes)
S     * |        |          |0 : 1
S     * |        |          |1 : 4
S     * |        |          |2 : 8
S */
S    __IO uint32_t FIFO;                  
S
S    /**
S     * LINE
S     * ===================================================================================================
S     * Offset: 0x0C  UART0 Line Control Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:1]   |WLS       |Word Length Select
S     * |        |          |0 (5bits), 1(6bits), 2(7bits), 3(8bits)
S     * |[2]     |NSB       |Number of STOP bits
S     * |        |          |0= One "STOP bit" is generated after the transmitted data
S     * |        |          |1= Two "STOP bits" are generated when 6-, 7- and 8-bit word length is selected; One and a half "STOP bits" are generated in the transmitted data when 5-bit word length is selected
S     * |[3]     |PBE       |Parity Bit Enable
S     * |        |          |0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
S     * |        |          |1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
S     * |[4]     |EPE       |Even Parity Enable
S     * |        |          |0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
S     * |        |          |1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
S     * |        |          |This bit has effect only when PBE (parity bit enable) is set.
S     * |[5]     |SPE       |Stick Parity Enable
S     * |        |          |0 = Disable stick parity
S     * |        |          |1 = When bits PBE and SPE are set 'Stick Parity' is enabled.
S     * |        |          |If EPE=0 the parity bit is transmitted and checked as always set, if EPE=1, the parity bit is transmitted and checked as always cleared.
S     * |[6]     |BCB       |Break Control Bit
S     * |        |          |When this bit is set to logic 1, the serial data output (Tx) is forced to the 'Space' state (logic 0).
S     * |        |          |Normal condition is serial data output is 'Mark' state.
S     * |        |          |This bit acts only on Tx and has no effect on the transmitter logic.
S */
S    __IO uint32_t LINE;                  
S
S    /**
S     * MODEM
S     * ===================================================================================================
S     * Offset: 0x10  UART0 Modem Control Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RTS       |RTS (Request-To-Send) Signal
S     * |        |          |If UART_INTEN.ATORTSEN = 0, this bit controls whether RTS pin is active or not.
S     * |        |          |0 = Drive RTS inactive ( = ~RTSACTLV).
S     * |        |          |1 = Drive RTS active ( = RTSACTLV).
S     * |[4]     |LBMEN     |Loopback Mode Enable
S     * |        |          |0=Disable
S     * |        |          |1=Enable
S     * |[9]     |RTSACTLV  |Request-to-Send (RTS) Active Trigger Level
S     * |        |          |This bit can change the RTS trigger level.
S     * |        |          |0= RTS is active low level.
S     * |        |          |1= RTS is active high level
S     * |[13]    |RTSSTS    |RTS Pin State (read only)
S     * |        |          |This bit is the pin status of RTS.
S */
S    __IO uint32_t MODEM;                 
S
S    /**
S     * MODEMSTS
S     * ===================================================================================================
S     * Offset: 0x14  UART0 Modem Status Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CTSDETF   |Detect CTS State Change Flag
S     * |        |          |This bit is set whenever CTS input has state change.
S     * |        |          |It will generate Modem interrupt to CPU when UART_INTEN.MODEMIEN = 1.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[4]     |CTSSTS    |CTS Pin Status (read only)
S     * |        |          |This bit is the pin status of CTS. 
S     * |[8]     |CTSACTLV  |Clear-to-Send (CTS) Active Trigger Level
S     * |        |          |This bit can change the CTS trigger level.
S     * |        |          |0= CTS is active low level.
S     * |        |          |1= CTS is active high level 
S */
S    __IO uint32_t MODEMSTS;              
S
S    /**
S     * FIFOSTS
S     * ===================================================================================================
S     * Offset: 0x18  UART0 FIFO Status Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXOVIF    |Rx Overflow Error Interrupt Flag
S     * |        |          |If the Rx FIFO ( UART_DAT) is full, and an additional byte is received by the UART, an overflow condition will occur and set this bit to logic 1.
S     * |        |          |It will also generate a BUFERRIF event and interrupt if enabled.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[4]     |PEF       |Parity Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
S     * |[5]     |FEF       |Framing Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
S     * |[6]     |BIF       |Break Interrupt Flag
S     * |        |          |This bit is set to a logic 1 whenever the receive data input (Rx) is held in the "space" state (logic 0) for longer than a full word transmission time (that is, the total time of start bit + data bits + parity + stop bits).
S     * |        |          |It is reset whenever the CPU writes 1 to this bit.
S     * |[8:13]  |RXPTR     |Rx FIFO pointer (Read Only)
S     * |        |          |This field returns the Rx FIFO buffer pointer.
S     * |        |          |It is the number of bytes available for read in the Rx FIFO.
S     * |        |          |When UART receives one byte from external device, RXPTR is incremented.
S     * |        |          |When one byte of Rx FIFO is read by CPU, RXPTR is decremented.
S     * |[14]    |RXEMPTY   |Receive FIFO Empty (Read Only)
S     * |        |          |This bit indicates whether the Rx FIFO is empty or not.
S     * |        |          |When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high.
S     * |        |          |It will be cleared when UART receives any new data.
S     * |[15]    |RXFULL    |Receive FIFO Full (Read Only)
S     * |        |          |This bit indicates whether the Rx FIFO is full or not.
S     * |        |          |This bit is set when Rx FIFO is full; otherwise it is cleared by hardware.
S     * |[16:21] |TXPTR     |Tx FIFO Pointer (Read Only)
S     * |        |          |This field returns the Tx FIFO buffer pointer.
S     * |        |          |When CPU writes a byte into the Tx FIFO, TXPTR is incremented.
S     * |        |          |When a byte from Tx FIFO is transferred to the Transmit Shift Register, TXPTR is decremented.
S     * |[22]    |TXEMPTY   |Transmit FIFO Empty (Read Only)
S     * |        |          |This bit indicates whether the Tx FIFO is empty or not.
S     * |        |          |When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
S     * |        |          |It will be cleared after writing data to FIFO (Tx FIFO not empty).
S     * |[23]    |TXFULL    |Transmit FIFO Full (Read Only)
S     * |        |          |This bit indicates whether the Tx FIFO is full or not.
S     * |        |          |This bit is set when Tx FIFO is full; otherwise it is cleared by hardware.
S     * |        |          |TXFULL=0 indicates there is room to write more data to Tx FIFO.
S     * |[24]    |TXOVIF    |Tx Overflow Error Interrupt Flag
S     * |        |          |If the Tx FIFO ( UART_DAT) is full, an additional write to UART_DAT will cause an overflow condition and set this bit to logic 1.
S     * |        |          |It will also generate a BUFERRIF event and interrupt if enabled.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[28]    |TXEMPTYF  |Transmitter Empty (Read Only)
S     * |        |          |Bit is set by hardware when Tx FIFO is empty and the STOP bit of the last byte has been transmitted.
S     * |        |          |Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
S     * |        |          |NOTE: This bit is read only. 
S */
S    __IO uint32_t FIFOSTS;               
S
S    /**
S     * INTSTS
S     * ===================================================================================================
S     * Offset: 0x1C  UART0 Interrupt Status Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
S     * |        |          |When the number of bytes in the Rx FIFO equals UART_FIFO.RFITL then the RDAIF will be set.
S     * |        |          |If UART_INTEN.RDAIEN is enabled, the RDA interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).
S     * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register.
S     * |        |          |If UART_INTEN.THREIEN is enabled, the THRE interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and it will be cleared when writing data into the Tx FIFO.
S     * |[2]     |RLSIF     |Receive Line Status Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Rx receive data has a parity, framing or break error (at least one of, UART_FIFOSTS.BIF, UART_FIFOSTS.FEF and UART_FIFOSTS.PEF, is set).
S     * |        |          |If UART_INTEN.RLSIEN is enabled, the RLS interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
S     * |[3]     |MODENIF   |MODEM Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the CTS pin has changed state (UART_MODEMSTS.CTSDETF=1).
S     * |        |          |If UART_INTEN.MODEMIEN is enabled, a CPU interrupt request will be generated.
S     * |        |          |NOTE: This bit is read only and reset when bit UART_MODEMSTS.CTSDETF is cleared by a write 1.
S     * |[4]     |RXTOIF    |Time Out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Rx FIFO is not empty and no activity occurs in the Rx FIFO and the time out counter equal to TOIC.
S     * |        |          |If UART_INTEN.TOUT_IEN is enabled a CPU interrupt request will be generated.
S     * |        |          |NOTE: This bit is read only and user can read FIFO to clear it.
S     * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when either the Tx or Rx FIFO overflows (UART_FIFOSTS.TXOVIF or UART_FIFOSTS.RXOVIF is set).
S     * |        |          |When BUFERRIF is set, the serial transfer may be corrupted.
S     * |        |          |If UART_INTEN.BUFERRIEN is enabled a CPU interrupt request will be generated.
S     * |        |          |NOTE: This bit is cleared when both UART_FIFOSTS.TXOVIF and UART_FIFOSTS.RXOVIF are cleared. 
S     * |[7]     |LINIF     |LIN Bus Rx Break Field Detected Flag
S     * |        |          |This bit is set when LIN controller detects a break field. This bit is cleared by writing a 1.
S     * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.RDAIEN and RDAIF.
S     * |[9]     |THERINT   |Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.THREIEN and THREIF.
S     * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.RLSIEN and RLSIF.
S     * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator to Interrupt
S     * |        |          |Logical AND of UART_INTEN.MODEMIEN and MODENIF.
S     * |[12]    |RXTOINT   |Time Out Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.RXTOIEN and RXTOIF.
S     * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.BUFERRIEN and BUFERRIF.
S     * |[15]    |LININT    |LIN Bus Rx Break Field Detected Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.LINIEN and LINIF.
S     * |[18]    |DRLSIF    |DMA MODE Receive Line Status Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Rx receive data has a parity, framing or break error (at least one of, UART_FIFOSTS.BIF, UART_FIFOSTS.FEF and UART_FIFOSTS.PEF, is set).
S     * |        |          |If UART_INTEN.RLSIEN is enabled, the RLS interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
S     * |[19]    |DMODEMIF  |DMA MODE MODEM Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the CTS pin has changed state (UART_MODEMSTS.CTSDETF=1).
S     * |        |          |If UART_INTEN.MODEMIEN is enabled, a CPU interrupt request will be generated.
S     * |        |          |NOTE: This bit is read only and reset when bit UART_MODEMSTS.CTSDETF is cleared by a write 1.
S     * |[20]    |DRXTOIF   |DMA MODE Time Out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Rx FIFO is not empty and no activity occurs in the Rx FIFO and the time out counter equal to TOIC.
S     * |        |          |If UART_INTEN.TOUT_IEN is enabled a CPU interrupt request will be generated.
S     * |        |          |NOTE: This bit is read only and user can read FIFO to clear it.
S     * |[21]    |DBERRIF   |DMA MODE Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when either the Tx or Rx FIFO overflows (UART_FIFOSTS.TXOVIF or UART_FIFOSTS.RXOVIF is set).
S     * |        |          |When BUFERRIF is set, the serial transfer may be corrupted.
S     * |        |          |If UART_INTEN.BUFERRIEN is enabled a CPU interrupt request will be generated.
S     * |        |          |NOTE: This bit is cleared when both UART_FIFOSTS.TXOVIF and UART_FIFOSTS.RXOVIF are cleared. 
S     * |[23]    |DLINIF    |DMA MODE LIN Bus Rx Break Field Detected Flag
S     * |        |          |This bit is set when LIN controller detects a break field. This bit is cleared by writing a 1.
S     * |[26]    |DRLSINT   |DMA MODE Receive Line Status Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DRLSIF.
S     * |[27]    |DMODEMI   |DMA MODE MODEM Status Interrupt Indicator to Interrupt
S     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DMODENIF.
S     * |[28]    |DRXTOINT  |DMA MODE Time Out Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DRXTOIF.
S     * |[29]    |DBERRINT  |DMA MODE Buffer Error Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DBERRIF.
S     * |[31]    |DLININT   |DMA MODE LIN Bus Rx Break Field Detected Interrupt Indicator to Interrupt Controller
S     * |        |          |Logical AND of UART_INTEN.DMARXEN or UART_INTEN.DMATXEN and DLINIF.
S */
S    __IO  uint32_t INTSTS;                
S
S    /**
S     * TOUT
S     * ===================================================================================================
S     * Offset: 0x20  UART0 Time Out Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:6]   |TOIC      |Time Out Interrupt Comparator
S     * |        |          |The time out counter resets and starts counting whenever the Rx FIFO receives a new data word.
S     * |        |          |Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (RXTOINT) is generated if UART_INTEN.RXTOIEN is set.
S     * |        |          |A new incoming data word or RX FIFO empty clears RXTOIF.
S     * |        |          |The period of the time out counter is the baud rate.
S */
S    __IO uint32_t TOUT;                  
S
S    /**
S     * BAUD
S     * ===================================================================================================
S     * Offset: 0x24  UART0 Baud Rate Divisor Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:15]  |BRD       |Baud Rate Divider
S     * |        |          |Refer to Table 5-111 for more information.
S     * |[24:27] |EDIVM1    |Divider X
S     * |        |          |The baud rate divider M = EDIVM1+1.
S     * |[28]    |BAUDM0    |Divider X equal 1
S     * |        |          |0: M = EDIVM1+1, with restriction EDIVM1 >= 8.
S     * |        |          |1: M = 1, with restriction BRD[15:0] >= 3.
S     * |        |          |Refer to Table 5-111 for more information.
S     * |[29]    |BAUDM1    |Divider X Enable
S     * |        |          |The baud rate equation is:
S     * |        |          |Baud Rate = UART_CLK / [ M * (BRD + 2) ] ; The default value of M is 16.
S     * |        |          |0 = Disable divider X ( M = 16)
S     * |        |          |1 = Enable divider X (M = EDIVM1+1, with EDIVM1 >= 8).
S     * |        |          |Refer to Table 5-111 for more information.
S     * |        |          |NOTE: When in IrDA mode, this bit must disabled.
S */
S    __IO uint32_t BAUD;                  
S
S    /**
S     * IRDA
S     * ===================================================================================================
S     * Offset: 0x28  UART0 IrDA Control Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TXEN      |Transmit/Receive Selection
S     * |        |          |0=Enable IrDA receiver.
S     * |        |          |1= Enable IrDA transmitter.
S     * |[2]     |LOOPBACK  |IrDA Loopback Test Mode
S     * |        |          |Loopback Tx to Rx.
S     * |[5]     |TXINV     |Transmit inversion enable
S     * |        |          |0= No inversion
S     * |        |          |1= Invert Tx output signal
S     * |[6]     |RXINV     |Receive Inversion Enable
S     * |        |          |0= No inversion
S     * |        |          |1= Invert Rx input signal
S */
S    __IO uint32_t IRDA;                  
S
S    /**
S     * ALTCTL
S     * ===================================================================================================
S     * Offset: 0x2C  UART0 LIN Control Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0:3]   |BRKFL     |UART LIN Break Field Length Count
S     * |        |          |This field indicates a 4-bit LIN Tx break field count.
S     * |        |          |NOTE: This break field length is BRKFL + 2
S     * |[6]     |LINRXEN   |LIN RX Enable
S     * |        |          |0 = Disable LIN Rx mode.
S     * |        |          |1 = Enable LIN Rx mode.
S     * |[7]     |LINTXEN   |LIN TX Break Mode Enable
S     * |        |          |0 = Disable LIN Tx Break Mode.
S     * |        |          |1 = Enable LIN Tx Break Mode.
S     * |        |          |NOTE: When Tx break field transfer operation finished, this bit will be cleared automatically.
S */
S    __IO uint32_t ALTCTL;                
S
S    /**
S     * FUNCSEL
S     * ===================================================================================================
S     * Offset: 0x30  UART0 Function Select Register.
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LINEN     |Enable LIN Function
S     * |        |          |0 = UART Function.
S     * |        |          |1 = Enable LIN Function.
S     * |        |          |Note that IrDA and LIN functions are mutually exclusive: both cannot be active at same time.
S     * |[1]     |IRDAEN    |Enable IrDA Function
S     * |        |          |0 = UART Function.
S     * |        |          |1 = Enable IrDA Function.
S */
S    __IO uint32_t FUNCSEL;               
S
S} UART_T;
S
S/**
S    @addtogroup UART_CONST UART Bit Field Definition
S    Constant Definitions for UART Controller
S@{ */
S
S#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART DAT: DAT Position                 */
S#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART DAT: DAT Mask                     */
S
S#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART INTEN: RDAIEN Position            */
S#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART INTEN: RDAIEN Mask                */
S
S#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART INTEN: THREIEN Position           */
S#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART INTEN: THREIEN Mask               */
S
S#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART INTEN: RLSIEN Position            */
S#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART INTEN: RLSIEN Mask                */
S
S#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART INTEN: MODEMIEN Position          */
S#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART INTEN: MODEMIEN Mask              */
S
S#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART INTEN: RXTOIEN Position           */
S#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART INTEN: RXTOIEN Mask               */
S
S#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART INTEN: BUFERRIEN Position         */
S#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART INTEN: BUFERRIEN Mask             */
S
S#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART INTEN: LINIEN Position            */
S#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART INTEN: LINIEN Mask                */
S
S#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART INTEN: TOCNTEN Position           */
S#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART INTEN: TOCNTEN Mask               */
S
S#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART INTEN: ATORTSEN Position          */
S#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART INTEN: ATORTSEN Mask              */
S
S#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART INTEN: ATOCTSEN Position          */
S#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART INTEN: ATOCTSEN Mask              */
S
S#define UART_INTEN_DMATXEN_Pos           (14)                                              /*!< UART INTEN: DMATXEN Position           */
S#define UART_INTEN_DMATXEN_Msk           (0x1ul << UART_INTEN_DMATXEN_Pos)                 /*!< UART INTEN: DMATXEN Mask               */
S
S#define UART_INTEN_DMARXEN_Pos           (15)                                              /*!< UART INTEN: DMARXEN Position           */
S#define UART_INTEN_DMARXEN_Msk           (0x1ul << UART_INTEN_DMARXEN_Pos)                 /*!< UART INTEN: DMARXEN Mask               */
S
S#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART FIFO: RXRST Position              */
S#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART FIFO: RXRST Mask                  */
S
S#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART FIFO: TXRST Position              */
S#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART FIFO: TXRST Mask                  */
S
S#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART FIFO: RFITL Position              */
S#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART FIFO: RFITL Mask                  */
S
S#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART FIFO: RTSTRGLV Position           */
S#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART FIFO: RTSTRGLV Mask               */
S
S#define UART_LINE_WLS_Pos                (0)                                               /*!< UART LINE: WLS Position                */
S#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART LINE: WLS Mask                    */
S
S#define UART_LINE_NSB_Pos                (2)                                               /*!< UART LINE: NSB Position                */
S#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART LINE: NSB Mask                    */
S
S#define UART_LINE_PBE_Pos                (3)                                               /*!< UART LINE: PBE Position                */
S#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART LINE: PBE Mask                    */
S
S#define UART_LINE_EPE_Pos                (4)                                               /*!< UART LINE: EPE Position                */
S#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART LINE: EPE Mask                    */
S
S#define UART_LINE_SPE_Pos                (5)                                               /*!< UART LINE: SPE Position                */
S#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART LINE: SPE Mask                    */
S
S#define UART_LINE_BCB_Pos                (6)                                               /*!< UART LINE: BCB Position                */
S#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART LINE: BCB Mask                    */
S
S#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART MODEM: RTS Position               */
S#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART MODEM: RTS Mask                   */
S
S#define UART_MODEM_LBMEN_Pos             (4)                                               /*!< UART MODEM: LBMEN Position             */
S#define UART_MODEM_LBMEN_Msk             (0x1ul << UART_MODEM_LBMEN_Pos)                   /*!< UART MODEM: LBMEN Mask                 */
S
S#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART MODEM: RTSACTLV Position          */
S#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART MODEM: RTSACTLV Mask              */
S
S#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART MODEM: RTSSTS Position            */
S#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART MODEM: RTSSTS Mask                */
S
S#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART MODEMSTS: CTSDETF Position        */
S#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART MODEMSTS: CTSDETF Mask            */
S
S#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART MODEMSTS: CTSSTS Position         */
S#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART MODEMSTS: CTSSTS Mask             */
S
S#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART MODEMSTS: CTSACTLV Position       */
S#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART MODEMSTS: CTSACTLV Mask           */
S
S#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART FIFOSTS: RXOVIF Position          */
S#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART FIFOSTS: RXOVIF Mask              */
S
S#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART FIFOSTS: PEF Position             */
S#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART FIFOSTS: PEF Mask                 */
S
S#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART FIFOSTS: FEF Position             */
S#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART FIFOSTS: FEF Mask                 */
S
S#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART FIFOSTS: BIF Position             */
S#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART FIFOSTS: BIF Mask                 */
S
S#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART FIFOSTS: RXPTR Position           */
S#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART FIFOSTS: RXPTR Mask               */
S
S#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART FIFOSTS: RXEMPTY Position         */
S#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART FIFOSTS: RXEMPTY Mask             */
S
S#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART FIFOSTS: RXFULL Position          */
S#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART FIFOSTS: RXFULL Mask              */
S
S#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART FIFOSTS: TXPTR Position           */
S#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART FIFOSTS: TXPTR Mask               */
S
S#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART FIFOSTS: TXEMPTY Position         */
S#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART FIFOSTS: TXEMPTY Mask             */
S
S#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART FIFOSTS: TXFULL Position          */
S#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART FIFOSTS: TXFULL Mask              */
S
S#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART FIFOSTS: TXOVIF Position          */
S#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART FIFOSTS: TXOVIF Mask              */
S
S#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART FIFOSTS: TXEMPTYF Position        */
S#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART FIFOSTS: TXEMPTYF Mask            */
S
S#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART INTSTS: RDAIF Position            */
S#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART INTSTS: RDAIF Mask                */
S
S#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART INTSTS: THREIF Position           */
S#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART INTSTS: THREIF Mask               */
S
S#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART INTSTS: RLSIF Position            */
S#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART INTSTS: RLSIF Mask                */
S
S#define UART_INTSTS_MODENIF_Pos          (3)                                               /*!< UART INTSTS: MODENIF Position          */
S#define UART_INTSTS_MODENIF_Msk          (0x1ul << UART_INTSTS_MODENIF_Pos)                /*!< UART INTSTS: MODENIF Mask              */
S
S#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART INTSTS: RXTOIF Position           */
S#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART INTSTS: RXTOIF Mask               */
S
S#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART INTSTS: BUFERRIF Position         */
S#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART INTSTS: BUFERRIF Mask             */
S
S#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART INTSTS: LINIF Position            */
S#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART INTSTS: LINIF Mask                */
S
S#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART INTSTS: RDAINT Position           */
S#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART INTSTS: RDAINT Mask               */
S
S#define UART_INTSTS_THERINT_Pos          (9)                                               /*!< UART INTSTS: THERINT Position          */
S#define UART_INTSTS_THERINT_Msk          (0x1ul << UART_INTSTS_THERINT_Pos)                /*!< UART INTSTS: THERINT Mask              */
S
S#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART INTSTS: RLSINT Position           */
S#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART INTSTS: RLSINT Mask               */
S
S#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART INTSTS: MODEMINT Position         */
S#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART INTSTS: MODEMINT Mask             */
S
S#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART INTSTS: RXTOINT Position          */
S#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART INTSTS: RXTOINT Mask              */
S
S#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART INTSTS: BUFERRINT Position        */
S#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART INTSTS: BUFERRINT Mask            */
S
S#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART INTSTS: LININT Position           */
S#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART INTSTS: LININT Mask               */
S
S#define UART_INTSTS_DRLSIF_Pos           (18)                                              /*!< UART INTSTS: DRLSIF Position           */
S#define UART_INTSTS_DRLSIF_Msk           (0x1ul << UART_INTSTS_DRLSIF_Pos)                 /*!< UART INTSTS: DRLSIF Mask               */
S
S#define UART_INTSTS_DMODEMIF_Pos         (19)                                              /*!< UART INTSTS: DMODEMIF Position         */
S#define UART_INTSTS_DMODEMIF_Msk         (0x1ul << UART_INTSTS_DMODEMIF_Pos)               /*!< UART INTSTS: DMODEMIF Mask             */
S
S#define UART_INTSTS_DRXTOIF_Pos          (20)                                              /*!< UART INTSTS: DRXTOIF Position          */
S#define UART_INTSTS_DRXTOIF_Msk          (0x1ul << UART_INTSTS_DRXTOIF_Pos)                /*!< UART INTSTS: DRXTOIF Mask              */
S
S#define UART_INTSTS_DBERRIF_Pos          (21)                                              /*!< UART INTSTS: DBERRIF Position          */
S#define UART_INTSTS_DBERRIF_Msk          (0x1ul << UART_INTSTS_DBERRIF_Pos)                /*!< UART INTSTS: DBERRIF Mask              */
S
S#define UART_INTSTS_DLINIF_Pos           (23)                                              /*!< UART INTSTS: DLINIF Position           */
S#define UART_INTSTS_DLINIF_Msk           (0x1ul << UART_INTSTS_DLINIF_Pos)                 /*!< UART INTSTS: DLINIF Mask               */
S
S#define UART_INTSTS_DRLSINT_Pos          (26)                                              /*!< UART INTSTS: DRLSINT Position          */
S#define UART_INTSTS_DRLSINT_Msk          (0x1ul << UART_INTSTS_DRLSINT_Pos)                /*!< UART INTSTS: DRLSINT Mask              */
S
S#define UART_INTSTS_DMODEMI_Pos          (27)                                              /*!< UART INTSTS: DMODEMI Position          */
S#define UART_INTSTS_DMODEMI_Msk          (0x1ul << UART_INTSTS_DMODEMI_Pos)                /*!< UART INTSTS: DMODEMI Mask              */
S
S#define UART_INTSTS_DRXTOINT_Pos         (28)                                              /*!< UART INTSTS: DRXTOINT Position         */
S#define UART_INTSTS_DRXTOINT_Msk         (0x1ul << UART_INTSTS_DRXTOINT_Pos)               /*!< UART INTSTS: DRXTOINT Mask             */
S
S#define UART_INTSTS_DBERRINT_Pos         (29)                                              /*!< UART INTSTS: DBERRINT Position         */
S#define UART_INTSTS_DBERRINT_Msk         (0x1ul << UART_INTSTS_DBERRINT_Pos)               /*!< UART INTSTS: DBERRINT Mask             */
S
S#define UART_INTSTS_DLININT_Pos          (31)                                              /*!< UART INTSTS: DLININT Position          */
S#define UART_INTSTS_DLININT_Msk          (0x1ul << UART_INTSTS_DLININT_Pos)                /*!< UART INTSTS: DLININT Mask              */
S
S#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART TOUT: TOIC Position               */
S#define UART_TOUT_TOIC_Msk               (0x7ful << UART_TOUT_TOIC_Pos)                    /*!< UART TOUT: TOIC Mask                   */
S
S#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART BAUD: BRD Position                */
S#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART BAUD: BRD Mask                    */
S
S#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART BAUD: EDIVM1 Position             */
S#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART BAUD: EDIVM1 Mask                 */
S
S#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART BAUD: BAUDM0 Position             */
S#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART BAUD: BAUDM0 Mask                 */
S
S#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART BAUD: BAUDM1 Position             */
S#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART BAUD: BAUDM1 Mask                 */
S
S#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART IRDA: TXEN Position               */
S#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART IRDA: TXEN Mask                   */
S
S#define UART_IRDA_LOOPBACK_Pos           (2)                                               /*!< UART IRDA: LOOPBACK Position           */
S#define UART_IRDA_LOOPBACK_Msk           (0x1ul << UART_IRDA_LOOPBACK_Pos)                 /*!< UART IRDA: LOOPBACK Mask               */
S
S#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART IRDA: TXINV Position              */
S#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART IRDA: TXINV Mask                  */
S
S#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART IRDA: RXINV Position              */
S#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART IRDA: RXINV Mask                  */
S
S#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART ALTCTL: BRKFL Position            */
S#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART ALTCTL: BRKFL Mask                */
S
S#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART ALTCTL: LINRXEN Position          */
S#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART ALTCTL: LINRXEN Mask              */
S
S#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART ALTCTL: LINTXEN Position          */
S#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART ALTCTL: LINTXEN Mask              */
S
S#define UART_FUNCSEL_LINEN_Pos           (0)                                               /*!< UART FUNCSEL: LINEN Position           */
S#define UART_FUNCSEL_LINEN_Msk           (0x1ul << UART_FUNCSEL_LINEN_Pos)                 /*!< UART FUNCSEL: LINEN Mask               */
S
S#define UART_FUNCSEL_IRDAEN_Pos          (1)                                               /*!< UART FUNCSEL: IRDAEN Position          */
S#define UART_FUNCSEL_IRDAEN_Msk          (0x1ul << UART_FUNCSEL_IRDAEN_Pos)                /*!< UART FUNCSEL: IRDAEN Mask              */
S
S/**@}*/ /* UART_CONST */
S/**@}*/ /* end of UART register group */
S
S
S/*---------------------- Watch Dog Timer Controller -------------------------*/
S/**
S    @addtogroup WDT Watch Dog Timer Controller(WDT)
S    Memory Mapped Structure for WDT Controller
S@{ */
S 
Stypedef struct
S{
S
S
S    /**
S     * CTL
S     * ===================================================================================================
S     * Offset: 0x00  Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RSTCNT    |Clear Watchdog Timer
S     * |        |          |Set this bit will clear the Watchdog timer.
S     * |        |          |0 = Writing 0 to this bit has no effect
S     * |        |          |1 = Reset the contents of the Watchdog timer
S     * |        |          |NOTE: This bit will auto clear after few clock cycle
S     * |[1]     |RSTEN     |Watchdog Timer Reset Enable
S     * |        |          |Setting this bit will enable the Watchdog timer reset function.
S     * |        |          |0 = Disable Watchdog timer reset function
S     * |        |          |1= Enable Watchdog timer reset function
S     * |[2]     |RSTF      |Watchdog Timer Reset Flag
S     * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit.
S     * |        |          |This flag can be read by software to determine the source of reset.
S     * |        |          |Software is responsible to clear it manually by writing 1 to it.
S     * |        |          |If RSTEN is disabled, then the Watchdog timer has no effect on this bit.
S     * |        |          |0 = Watchdog timer reset has not occurred.
S     * |        |          |1= Watchdog timer reset has occurred.
S     * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
S     * |[3]     |IF        |Watchdog Timer Interrupt Flag
S     * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred.
S     * |        |          |If the Watchdog timer interrupt is not enabled, then this bit indicates that a timeout period has elapsed.
S     * |        |          |0 = Watchdog timer interrupt has not occurred.
S     * |        |          |1 = Watchdog timer interrupt has occurred.
S     * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
S     * |[6]     |INTEN     |Watchdog Timer Interrupt Enable
S     * |        |          |0 = Disable the Watchdog timer interrupt
S     * |        |          |1 = Enable the Watchdog timer interrupt
S     * |[7]     |WDTEN     |Watchdog Timer Enable
S     * |        |          |0 = Disable the Watchdog timer (This action will reset the internal counter)
S     * |        |          |1 = Enable the Watchdog timer
S     * |[8:10]  |TOUTSEL   |Watchdog Timer Interval Select
S     * |        |          |These three bits select the timeout interval for the Watchdog timer, a watchdog reset will occur 1024 clock cycles later if WDG not reset.
S     * |        |          |The timeout is given by:.
S     * |        |          |Interrupt Timeout = 2^(2xWTIS+4) x WDT_CLK
S     * |        |          |Reset Timeout = (2^(2xWTIS+4) +1024) x WDT_CLK
S     * |        |          |Where WDT_CLK is the period of the Watchdog Timer clock source.
S */
S    __IO uint32_t CTL;                   
S
S} WDT_T;
S
S/**
S    @addtogroup WDT_CONST WDT Bit Field Definition
S    Constant Definitions for WDT Controller
S@{ */
S
S#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT CTL: RSTCNT Position               */
S#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT CTL: RSTCNT Mask                   */
S
S#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT CTL: RSTEN Position                */
S#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT CTL: RSTEN Mask                    */
S
S#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT CTL: RSTF Position                 */
S#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT CTL: RSTF Mask                     */
S
S#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT CTL: IF Position                   */
S#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT CTL: IF Mask                       */
S
S#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT CTL: INTEN Position                */
S#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT CTL: INTEN Mask                    */
S
S#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT CTL: WDTEN Position                */
S#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT CTL: WDTEN Mask                    */
S
S#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT CTL: TOUTSEL Position              */
S#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT CTL: TOUTSEL Mask                  */
S
S/**@}*/ /* WDT_CONST */
S/**@}*/ /* end of WDT register group */
S
S/**@}*/ /* end of SBRAM register group */
Stypedef struct
S{
S    __IO uint32_t	D[64];
S} SBRAM_T;
S/**@}*/ /* end of REGISTER group */
S
S
S/**@}*/ /* end of REGISTER group */
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup ISD9100_PERIPHERAL_MEM_MAP ISD9100 Peripheral Memory Map
S  Memory Mapped Structure for ISD9100 Series Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S
S/* Peripheral memory map */
S
S#define WDT_BASE       	     (APB1_BASE      + 0x04000)
S#define RTC_BASE             (APB1_BASE      + 0x08000)
S#define TIMER0_BASE          (APB1_BASE      + 0x10000)
S#define TIMER1_BASE          (APB1_BASE      + 0x10020)
S#define I2C0_BASE            (APB1_BASE      + 0x20000)
S#define SPI0_BASE            (APB1_BASE      + 0x30000)
S#define PWM0_BASE            (APB1_BASE      + 0x40000)
S#define UART0_BASE           (APB1_BASE      + 0x50000)
S#define DPWM_BASE            (APB1_BASE      + 0x70000)
S#define ANA_BASE             (APB1_BASE      + 0x80000)
S#define BODTALM_BASE         (APB1_BASE      + 0x84000)
S#define CRC_BASE             (APB1_BASE      + 0x90000)
S#define I2S0_BASE            (APB1_BASE      + 0xA0000)
S#define BIQ_BASE             (APB1_BASE      + 0xB0000)
S#define ALC_BASE             (APB1_BASE      + 0xB0048)
S#define ACMP_BASE            (APB1_BASE      + 0xD0000)
S#define ADC_BASE             (APB1_BASE      + 0xE0000)
S#define SBRAM_BASE           (APB1_BASE      + 0xF0000)
S
S#define SYS_BASE             (AHB_BASE       + 0x00000)
S#define CLK_BASE             (AHB_BASE       + 0x00200)
S#define INT_BASE             (AHB_BASE       + 0x00300)
S#define GPIO_BASE            (AHB_BASE       + 0x04000)
S#define GPIOA_BASE           (GPIO_BASE               )
S#define GPIOB_BASE           (GPIO_BASE      + 0x00040)
S#define GPIO_DBNCECON_BASE   (GPIO_BASE      + 0x00180)
S
S#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
S#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
S#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
S#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
S
S#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Grobal Base Address                         */
S
S
S
S#define FMC_BASE             (AHB_BASE       + 0x0C000)
S
S/*@}*/ /* end of group ISD9100_PERIPHERAL_MEM_MAP */
S/******************************************************************************/
S/*                         Peripheral declaration                             */
S/******************************************************************************/
S/** @addtogroup ISD9100_PeripheralDecl ISD9100 Peripheral Declaration
S    @{
S*/
S#define PA                  ((GPIO_T *) GPIOA_BASE)
S#define PB                  ((GPIO_T *) GPIOB_BASE)
S#define GPIO                ((GPIO_DB_T *) GPIO_DBNCECON_BASE)
S
S#define UART0               ((UART_T *) UART0_BASE)
S#define DPWM                ((DPWM_T *) DPWM_BASE)
S
S#define TIMER0              ((TMR_T *) TIMER0_BASE)
S#define TIMER1              ((TMR_T *) TIMER1_BASE)
S
S#define WDT                 ((WDT_T *) WDT_BASE)
S
S#define SPI0                ((SPI_T *) SPI0_BASE)
S
S#define I2C0                ((I2C_T *) I2C0_BASE)
S
S#define I2S0                ((I2S_T *) I2S0_BASE)
S
S#define RTC                 ((RTC_T *) RTC_BASE)
S
S#define ADC                 ((ADC_T*) ADC_BASE)
S
S#define ACMP                ((ACMP_T *) ACMP_BASE)
S#define ANA					((ANA_T *) ANA_BASE)
S#define BODTALM             ((BODTALM_T *) BODTALM_BASE)
S
S#define BIQ                 ((BIQ_T *) BIQ_BASE)
S#define ALC                 ((ALC_T *) ALC_BASE)
S#define SBRAM				((SBRAM_T *) SBRAM_BASE)
S
S#define CLK                 ((CLK_T *) CLK_BASE)
S#define SYS                 ((SYS_T *) SYS_BASE)
S
S#define FMC                 ((FMC_T *) FMC_BASE)
S
S#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
S#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
S#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
S#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
S
S#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
S
S#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
S
S#define PWM0                ((PWM_T *) PWM0_BASE)
S
S/*@}*/ /* end of group ISD9100_PeripheralDecl */
S
S#define UNLOCKREG(x)        do{*((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(SYS_BASE + 0x100))==0)
S#define LOCKREG(x)          *((__IO uint32_t *)(SYS_BASE + 0x100)) = 0x00
S
S#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
S#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
S
S//=============================================================================
S/** @addtogroup ISD9100_IO_ROUTINE ISD9100 I/O routines
S  The Declaration of ISD9100 I/O routines
S  @{
S */
S
Stypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Stypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Stypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
S
S/**
S  * @brief Get a 8-bit unsigned value from specified address
S  * @param[in] addr Address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified address
S  */
S#define M8(addr)  (*((vu8  *) (addr)))
S
S/**
S  * @brief Get a 16-bit unsigned value from specified address
S  * @param[in] addr Address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified address
S  * @note The input address must be 16-bit aligned
S  */
S#define M16(addr) (*((vu16 *) (addr)))
S
S/**
S  * @brief Get a 32-bit unsigned value from specified address
S  * @param[in] addr Address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified address
S  * @note The input address must be 32-bit aligned
S  */
S#define M32(addr) (*((vu32 *) (addr)))
S
S/**
S  * @brief Set a 32-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 32-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 32-bit aligned
S  */
S#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
S
S/**
S  * @brief Get a 32-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified I/O port
S  * @note The input port must be 32-bit aligned
S  */
S#define inpw(port)            (*((volatile unsigned int *)(port)))
S
S/**
S  * @brief Set a 16-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 16-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 16-bit aligned
S  */
S#define outps(port,value)     *((volatile unsigned short *)(port)) = value
S
S/**
S  * @brief Get a 16-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified I/O port
S  * @note The input port must be 16-bit aligned
S  */
S#define inps(port)            (*((volatile unsigned short *)(port)))
S
S/**
S  * @brief Set a 8-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 8-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  */
S#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
S
S/**
S  * @brief Get a 8-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified I/O port
S  */
S#define inpb(port)            (*((volatile unsigned char *)(port)))
S
S/**
S  * @brief Set a 32-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 32-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 32-bit aligned
S  */
S#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
S
S/**
S  * @brief Get a 32-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified I/O port
S  * @note The input port must be 32-bit aligned
S  */
S#define inp32(port)           (*((volatile unsigned int *)(port)))
S
S/**
S  * @brief Set a 16-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 16-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 16-bit aligned
S  */
S#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
S
S/**
S  * @brief Get a 16-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified I/O port
S  * @note The input port must be 16-bit aligned
S  */
S#define inp16(port)           (*((volatile unsigned short *)(port)))
S
S/**
S  * @brief Set a 8-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 8-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  */
S#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
S
S/**
S  * @brief Get a 8-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified I/O port
S  */
S#define inp8(port)            (*((volatile unsigned char *)(port)))
S
S/*@}*/ /* end of group ISD9100_IO_ROUTINE */
S
S
S
S
S/** @addtogroup ISD9100_legacy_Constants ISD9100 Legacy Constants
S  ISD9100 Legacy Constants
S  @{
S*/
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE     1
S#define DISABLE    0
S
S/* Define one bit mask */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S/*@}*/ /* end of group ISD9100_legacy_Constants */
S
S/*@}*/ /* end of group ISD9100_Definitions */
S
S#define __ISD9100_SERIES__  (0x91000000)
S#define __CHIP_SERIES__     __ISD9100_SERIES__
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/
S#include "acmp.h"
S#include "adc.h"
S#include "biq.h"
S#include "bod.h"
S#include "capsense.h"
S#include "clk.h"
S#include "crc.h"
S#include "dpwm.h"
S#include "fmc.h"
S#include "gpio.h"
S#include "i2c.h"
S#include "i2s.h"
S#include "osc.h"
S#include "pdma.h"
S#include "pwm.h"
S#include "rtc.h"
S#include "spi.h"
S#include "sys.h"
S#include "talarm.h"
S#include "timer.h"
S#include "uart.h"
S#include "wdt.h"
S
S
N#endif	// __ISD9100_H__
N
L 15 "..\..\..\..\Library\StdDriver\inc\i2s.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_I2S_Driver I2S Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_I2S_EXPORTED_CONSTANTS I2S Exported Constants
N  @{
N*/
N#define I2S_DATABIT_8           (0 << I2S_CTL_WDWIDTH_Pos)       /*!< I2S data width is 8-bit  \hideinitializer */
N#define I2S_DATABIT_16          (1 << I2S_CTL_WDWIDTH_Pos)       /*!< I2S data width is 16-bit  \hideinitializer */
N#define I2S_DATABIT_24          (2 << I2S_CTL_WDWIDTH_Pos)       /*!< I2S data width is 24-bit  \hideinitializer */
N#define I2S_DATABIT_32          (3 << I2S_CTL_WDWIDTH_Pos)       /*!< I2S data width is 32-bit  \hideinitializer */
N
N/* Audio Format */
N#define I2S_MONO                I2S_CTL_MONO_Msk                   /*!< Mono channel  \hideinitializer */
N#define I2S_STEREO              0                                  /*!< Stereo channel  \hideinitializer */
N
N/* I2S Data Format */
N#define I2S_FORMAT_MSB          I2S_CTL_FORMAT_Msk                 /*!< MSB data format  \hideinitializer */
N#define I2S_FORMAT_I2S          0                                  /*!< I2S data format  \hideinitializer */
N#define I2S_FORMAT_PCMB         I2S_CTL_FORMAT_Msk                 /*!< PCMB data format  \hideinitializer */
N#define I2S_FORMAT_PCMA         0                                  /*!< PCMA data format  \hideinitializer */
N
N/* I2S Interface */
N#define I2S_PCM                 I2S_CTL_PCMEN_Msk                  /*!< PCM interface is selected  \hideinitializer */
N#define I2S_I2S                 0                                  /*!< I2S interface is selected  \hideinitializer */
N
N/* I2S Operation mode */
N#define I2S_MODE_SLAVE          I2S_CTL_SLAVE_Msk                  /*!< As slave mode  \hideinitializer */
N#define I2S_MODE_MASTER         0                                  /*!< As master mode  \hideinitializer */
N
N/* I2S FIFO Threshold */
N#define I2S_FIFO_TX_LEVEL_WORD_0    0                              /*!< TX threshold is 0 word  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_1    (1 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 1 word  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_2    (2 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 2 words  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_3    (3 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 3 words  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_4    (4 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 4 words  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_5    (5 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 5 words  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_6    (6 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 6 words  \hideinitializer */
N#define I2S_FIFO_TX_LEVEL_WORD_7    (7 << I2S_CTL_TXTH_Pos)        /*!< TX threshold is 7 words  \hideinitializer */
N
N#define I2S_FIFO_RX_LEVEL_WORD_1    0                              /*!< RX threshold is 1 word  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_2    (1 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 2 words  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_3    (2 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 3 words  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_4    (3 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 4 words  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_5    (4 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 5 words  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_6    (5 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 6 words  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_7    (6 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 7 words  \hideinitializer */
N#define I2S_FIFO_RX_LEVEL_WORD_8    (7 << I2S_CTL_RXTH_Pos)        /*!< RX threshold is 8 words  \hideinitializer */
N
N/* I2S Record Channel */
N#define I2S_MONO_RIGHT          0                                  /*!< Record mono right channel  \hideinitializer */
N#define I2S_MONO_LEFT           I2S_CTL_RXLCH_Msk                  /*!< Record mono left channel  \hideinitializer */
N
N/* I2S Channel */
N#define I2S_RIGHT               0                                  /*!< Select right channel  \hideinitializer */
N#define I2S_LEFT                1                                  /*!< Select left channel  \hideinitializer */
N
N/*@}*/ /* end of group ISD9100_I2S_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_I2S_EXPORTED_FUNCTIONS I2S Exported Functions
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N  * @brief  Enable zero cross detect function.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32ChMask is the mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CTL |= I2S_CTL_RZCEN_Msk;
X        i2s->CTL |= (0x1ul << (16));
N    else
N        i2s->CTL |= I2S_CTL_LZCEN_Msk;
X        i2s->CTL |= (0x1ul << (17));
N}
N
N/**
N  * @brief  Disable zero cross detect function.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32ChMask is the mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CTL &= ~I2S_CTL_RZCEN_Msk;
X        i2s->CTL &= ~(0x1ul << (16));
N    else
N        i2s->CTL &= ~I2S_CTL_LZCEN_Msk;
X        i2s->CTL &= ~(0x1ul << (17));
N}
N
N/**
N  * @brief  Enable I2S Tx DMA function. I2S requests DMA to transfer data to Tx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_TXDMA(i2s)  ( (i2s)->CTL |= I2S_CTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Disable I2S Tx DMA function. I2S requests DMA to transfer data to Tx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_TXDMA(i2s) ( (i2s)->CTL &= ~I2S_CTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Enable I2S Rx DMA function. I2S requests DMA to transfer data from Rx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_RXDMA(i2s) ( (i2s)->CTL |= I2S_CTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Disable I2S Rx DMA function. I2S requests DMA to transfer data from Rx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_RXDMA(i2s) ( (i2s)->CTL &= ~I2S_CTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Enable I2S Tx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_TX(i2s) ( (i2s)->CTL |= I2S_CTL_TXEN_Msk )
N
N/**
N  * @brief  Disable I2S Tx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_TX(i2s) ( (i2s)->CTL &= ~I2S_CTL_TXEN_Msk )
N
N/**
N  * @brief  Enable I2S Rx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_RX(i2s) ( (i2s)->CTL |= I2S_CTL_RXEN_Msk )
N
N/**
N  * @brief  Disable I2S Rx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_RX(i2s) ( (i2s)->CTL &= ~I2S_CTL_RXEN_Msk )
N
N/**
N  * @brief  Enable Tx Mute function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_TX_MUTE(i2s)  ( (i2s)->CTL |= I2S_CTL_MUTE_Msk )
N
N/**
N  * @brief  Disable Tx Mute function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_TX_MUTE(i2s) ( (i2s)->CTL &= ~I2S_CTL_MUTE_Msk )
N
N/**
N  * @brief  Clear Tx FIFO. Internal pointer is reset to FIFO start point.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_CLR_TX_FIFO(i2s) ( (i2s)->CTL |= I2S_CTL_TXCLR_Msk )
N
N/**
N  * @brief  Clear Rx FIFO. Internal pointer is reset to FIFO start point.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_CLR_RX_FIFO(i2s) ( (i2s)->CTL |= I2S_CTL_RXCLR_Msk )
N
N/**
N  * @brief  Write data to I2S Tx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Data: The data written to FIFO.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_WRITE_TX_FIFO(i2s, u32Data)  ( (i2s)->TX = u32Data )
N
N/**
N  * @brief  Read Rx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return Data in Rx FIFO.
N  * \hideinitializer
N  */
N#define I2S_READ_RX_FIFO(i2s) ( (i2s)->RX )
N
N/**
N  * @brief  This function gets the interrupt flag according to the mask parameter.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Mask is the mask for the all interrupt flags.
N  * @return The masked bit value of interrupt flag.
N  * \hideinitializer
N  */
N#define I2S_GET_INT_FLAG(i2s, u32Mask) ( (i2s)->STATUS & u32Mask )
N
N/**
N  * @brief  This function clears the interrupt flag according to the mask parameter.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Mask is the mask for the all interrupt flags.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_CLR_INT_FLAG(i2s, u32Mask) ( (i2s)->STATUS |= u32Mask )
N
N/**
N  * @brief  Get transmit FIFO level
N  * @param[in] i2s is the base address of I2S module.
N  * @return FIFO level
N  * \hideinitializer
N  */
N#define I2S_GET_TX_FIFO_LEVEL(i2s) ( (((i2s)->STATUS & I2S_STATUS_TXCNT_Msk) >> I2S_STATUS_TXCNT_Pos) & 0xF )
N
N/**
N  * @brief  Get receive FIFO level
N  * @param[in] i2s is the base address of I2S module.
N  * @return FIFO level
N  * \hideinitializer
N  */
N#define I2S_GET_RX_FIFO_LEVEL(i2s) ( (((i2s)->STATUS & I2S_STATUS_RXCNT_Msk) >> I2S_STATUS_RXCNT_Pos) & 0xF )
N
Nuint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat, uint32_t u32AudioInterface);
Nvoid I2S_Close(I2S_T *i2s);
Nvoid I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
Nvoid I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
Nuint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
Nvoid I2S_DisableMCLK(I2S_T *i2s);
N
N/*@}*/ /* end of group ISD9100_I2S_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group ISD9100_I2S_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 9158 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "osc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\osc.h" 1
N/**************************************************************************//**
N * @file     OSC.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/07/08 10:00a $
N * @brief    ISD9100 Series OSC Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N 
N#ifndef __OSC_H__
N#define __OSC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_OSC_Driver OSC Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_OSC_EXPORTED_CONSTANTS OSC Exported Constants
N  @{
N*/
N	
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Hardware bit field define(Temp)                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_IRCT10K_TRIM_Pos             (0)
N#define SYS_IRCT10K_TRIM_Msk             (0x1fful<<SYS_IRCT10K_TRIM_Pos)
N#define SYS_IRCT10K_TMREG_Pos            (16)  
N#define SYS_IRCT10K_TMREG_Msk            (0x1ful<<SYS_IRCT10K_TMREG_Pos)  	
N#define SYS_IRCT10K_IBGEN_Pos            (22)
N#define SYS_IRCT10K_IBGEN_Msk            (0x3ul<<SYS_IRCT10K_IBGEN_Pos)  
N#define SYS_IRCT10K_TRIMCLK_Pos          (31)
N#define SYS_IRCT10K_TRIMCLK_Msk          (0x1ul<<SYS_IRCT10K_TRIMCLK_Pos)  
N
N#define SYS_IRCTTRIM_TRIM_Pos            (0)
N#define SYS_IRCTTRIM_TRIM_Msk            (0xfful<<SYS_IRCTTRIM_TRIM_Pos)
N#define SYS_IRCTTRIM_RANGE_Pos           (8)  
N#define SYS_IRCTTRIM_RANGE_Msk           (0x1ul<<SYS_IRCTTRIM_RANGE_Pos)  	
N#define SYS_IRCTTRIM_FINE_Pos            (9)
N#define SYS_IRCTTRIM_FINE_Msk            (0xful<<SYS_IRCTTRIM_FINE_Pos)  
N#define SYS_IRCTTRIM_TC_Pos              (16)
N#define SYS_IRCTTRIM_TC_Msk              (0xfful<<SYS_IRCTTRIM_TC_Pos)  
N	
N/*---------------------------------------------------------------------------------------------------------*/
N/*  OSC trim onfiguration constant definitions.                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define OSC_LOWEST_FRQ_THAN_TARGET_FRQ   (1)
N#define OSC_MAX_COARSE                   (7)
N#define OSC_MAX_FINE                     (31)
N#define OSC_NUM_SFINE                    (8)
N#define OSC_RESERVE_RANGE	             (3)
N#define OSC_MEASURE_HCL_DIV              (2)
N#define OSC_NUM_CYCLES                   (36)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  OSC trim fine constant definitions.                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define OSC_TRIM_FINE_100R               (0x00)
N#define OSC_TRIM_FINE_75R                (0x01)
N#define OSC_TRIM_FINE_50R                (0x02)
N#define OSC_TRIM_FINE_42R                (0x03)
N#define OSC_TRIM_FINE_33R                (0x06)
N#define OSC_TRIM_FINE_30R                (0x07)
N#define OSC_TRIM_FINE_25R                (0x0E)
N#define OSC_TRIM_FINE_23R                (0x0F)
N
Nint32_t OSC_Trim(int32_t i32Target, uint8_t u8TrimIdx);
N
N/*@}*/ /* end of group ISD9100_OSC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_OSC_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__OSC_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 9159 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "pdma.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pdma.h" 1
N/**************************************************************************//**
N * @file     PDMA.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 Series PDMA Controller Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  * @{
N  */
N
N/** @addtogroup ISD9100_PDMA_Driver PDMA Driver
N  * @{
N  */
N
N/** @addtogroup ISD9100_PDMA_EXPORTED_CONSTANTS PDMA Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Data Width Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_WIDTH_8        0x00080000UL            /*!<DMA Transfer Width 8-bit */
N#define PDMA_WIDTH_16       0x00100000UL            /*!<DMA Transfer Width 16-bit */
N#define PDMA_WIDTH_32       0x00000000UL            /*!<DMA Transfer Width 32-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Address Attribute Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SAR_INC        0x00000000UL            /*!<DMA SAR increment */
N#define PDMA_SAR_FIX        0x00000020UL            /*!<DMA SAR fix address */
N#define PDMA_SAR_WRA        0x00000030UL            /*!<DMA SAR wrap around */
N#define PDMA_DAR_INC        0x00000000UL            /*!<DMA DAR increment */
N#define PDMA_DAR_FIX        0x00000080UL            /*!<DMA DAR fix address */
N#define PDMA_DAR_WRA        0x000000C0UL            /*!<DMA DAR wrap around */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PDMA Transfer Direction Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SRAM_SRAM      0x00000000UL            /*!<DMA Transfer from SRAM to SRAM */
N#define PDMA_APB_SRAM       0x00000004UL            /*!<DMA Transfer from APB to SRAM */
N#define PDMA_SRAM_APB       0x00000008UL            /*!<DMA Transfer from SRAM to APB */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Peripheral Transfer Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SPI0_TX        0x00000000UL            /*!<DMA Connect to SPI0 TX */
N#define PDMA_SPI0_RX        0x00000001UL            /*!<DMA Connect to SPI0 RX */
N#define PDMA_I2S_TX         0x00000002UL            /*!<DMA Connect to I2S TX */
N#define PDMA_I2S_RX         0x00000003UL            /*!<DMA Connect to I2S RX */
N#define PDMA_UART0_TX       0x00000004UL            /*!<DMA Connect to UART0 TX */
N#define PDMA_UART0_RX       0x00000005UL            /*!<DMA Connect to UART0 RX */
N#define PDMA_ADC            0x00000006UL            /*!<DMA Connect to ADC */
N#define PDMA_DPWM           0x00000007UL            /*!<DMA Connect to DPWM */
N#define PDMA_MEM            0x000000ffUL            /*!<DMA Connect to Memory */
N
N/*@}*/ /* end of group ISD9100_PDMA_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_PDMA_EXPORTED_FUNCTIONS PDMA Exported Functions
N  @{
N*/
N
N/**
N * @brief       Get PDMA Global Interrupt Status
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the global interrupt status.
N */
N#define PDMA_GET_INT_STATUS()   ((uint32_t)(PDMA_GCR->GLOBALIF))
N
N/**
N * @brief       Get PDMA Channel Interrupt Status
N *
N * @param[in]   u32Ch   Selected DMA channel
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the channel interrupt status.
N */
N#define PDMA_GET_CH_INT_STS(u32Ch)   (*((__IO uint32_t *)((uint32_t)&PDMA0->CHIF + (uint32_t)((u32Ch)*0x100))))
N
N/**
N * @brief       Clear PDMA Channel Interrupt Flag
N *
N * @param[in]   u32Ch   Selected DMA channel
N * @param[in]   u32Mask Interrupt Mask
N *
N * @return      None
N *
N * @details     This macro clear the channel interrupt flag.
N */
N#define PDMA_CLR_CH_INT_FLAG(u32Ch, u32Mask)   (*((__IO uint32_t *)((uint32_t)&PDMA0->CHIF + (uint32_t)((u32Ch)*0x100))) = (u32Mask))
N
N/**
N * @brief       Check Channel Status
N *
N * @param[in]   u32Ch    The selected channel
N *
N * @retval      0        The selected channel is idle
N * @retval      1        The selected channel is busy
N *
N * @details     Check the selected channel is busy or not.
N */
N#define PDMA_IS_CH_BUSY(u32Ch)    (*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL +(uint32_t)((u32Ch)*0x100)))&PDMA_DSCT_CTL_TXEN_Msk)? 1 : 0)
N
N/**
N * @brief       Set Source Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel source address.
N */
N#define PDMA_SET_SRC_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_ENDSA + (uint32_t)((u32Ch)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Destination Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel destination address.
N */
N#define PDMA_SET_DST_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_ENDDA + (uint32_t)((u32Ch)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Transfer Count
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Count  Transfer Count
N *
N * @return      None
N *
N * @details     This macro set the selected channel transfer count.
N */
N#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) {   \
N    if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) & PDMA_DSCT_CTL_TXWIDTH_Msk) == PDMA_WIDTH_32)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->TXBCCH + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 2);  \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) & PDMA_DSCT_CTL_TXWIDTH_Msk) == PDMA_WIDTH_8)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->TXBCCH + (uint32_t)((u32Ch)*0x100))) = (u32Count); \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) & PDMA_DSCT_CTL_TXWIDTH_Msk) == PDMA_WIDTH_16) \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->TXBCCH + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 1);  \
N}
X#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) {       if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) & PDMA_DSCT_CTL_TXWIDTH_Msk) == PDMA_WIDTH_32)          *((__IO uint32_t *)((uint32_t)&PDMA0->TXBCCH + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 2);      else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) & PDMA_DSCT_CTL_TXWIDTH_Msk) == PDMA_WIDTH_8)          *((__IO uint32_t *)((uint32_t)&PDMA0->TXBCCH + (uint32_t)((u32Ch)*0x100))) = (u32Count);     else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) & PDMA_DSCT_CTL_TXWIDTH_Msk) == PDMA_WIDTH_16)         *((__IO uint32_t *)((uint32_t)&PDMA0->TXBCCH + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 1);  }
N
N/**
N * @brief       Stop the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro stop the selected channel.
N */
N#define PDMA_STOP(u32Ch) (*((__IO uint32_t *)((uint32_t)&PDMA0->DSCT_CTL + (uint32_t)((u32Ch)*0x100))) &= ~PDMA_DSCT_CTL_CHEN_Msk)
N
Nvoid PDMA_Open(uint32_t u32Mask);
Nvoid PDMA_Close(void);
Nvoid PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
Nvoid PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
Nvoid PDMA_SetTransferDirection(uint32_t u32Ch, uint32_t u32Direction);
Nvoid PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Periphral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
Nvoid PDMA_Trigger(uint32_t u32Ch);
Nvoid PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
Nvoid PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);
N
N
N/*@}*/ /* end of group SD9100_PDMA_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SD9100_PDMA_Driver */
N
N/*@}*/ /* end of group SD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  // __PDMA_H__ 
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9160 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "pwm.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/15 2:52p $
N * @brief    ISD9100 series PWM driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N	
N#define PWM_CHANNEL_NUM                     (2)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divide by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divide by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divide by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divide by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divide by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL) /*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (1UL) /*!< PWM working in center aligned type */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                         /*!< PWM period interrupt triggered if counter underflow */
N//#define PWM_PERIOD_INT_MATCH_CNR            (PWM_PIER_INT01TYPE_Msk)    /*!< PWM period interrupt triggered if counter match CNR */
N#define PWM_CAPTURE_INT_RISING_LATCH        (PWM_CAPCTL01_CRLIEN0_Msk)      /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH       (PWM_CAPCTL01_CFLIEN0_Msk)      /*!< PWM capture interrupt if channel has falling transition */
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel number constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0                             0x0                         /*!< PWM Group 0/1 channel 0 */
N#define PWM_CH1                             0x1                         /*!< PWM Group 0/1 channel 1 */
N#define PWM_CCR_MASK                        0x000F000F                  /*!< PWM CCR0/CCR2 bit0~3 and bit16~19 mask */
N
N/*@}*/ /* end of group ISD9100_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief Enable output inverter of specified channel(s) and disable others
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable capture input inverter for specified channel(s) and disable others.
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    { \
N        int i;\
N                (pwm)->CTL &= ~(PWM_CTL_PINV0_Msk|PWM_CTL_PINV1_Msk);\
N        for(i = 0; i < PWM_CHANNEL_NUM; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->CTL |= (PWM_CTL_PINV0_Msk << (PWM_CTL_PINV0_Pos * (i * 4))); \
N        } \
N    }
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     {         int i;                (pwm)->CTL &= ~(PWM_CTL_PINV0_Msk|PWM_CTL_PINV1_Msk);        for(i = 0; i < PWM_CHANNEL_NUM; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->CTL |= (PWM_CTL_PINV0_Msk << (PWM_CTL_PINV0_Pos * (i * 4)));         }     }
N
N/**
N * @brief Get captured rising data of specified channel
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~1
N * @return The timer counter, 0~0xFFFF
N * @details This macro is used to get captured rising data for specified channel.
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->RCAPDAT0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Get captured falling data of specified channel
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~1
N * @return The timer counter, 0~0xFFFF
N * @details This macro is used to get captured falling data for specified channel.
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->FCAPDAT0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Set the prescaler of the selected channel
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~1
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @details This macro is used to set timer pre-scale for specified channel.
N * @note If u32Prescaler = 0, corresponding PWM-timer will be stopped.
N * @note If u32Prescaler = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    ((pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     ((pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
N
N/**
N * @brief Set the divider of the selected channel
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~1
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16
N * @return None
N * @details This macro is used to set Timer clock source divider selection for specified channel.
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    ((pwm)->CLKDIV = ((pwm)->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     ((pwm)->CLKDIV = ((pwm)->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief Set the duty of the selected channel
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~1
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set PWM Comparator value for specified channel.
N * @note This new setting will take effect on next PWM period.
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CMPDAT0)) + (u32ChannelNum) * 12))) = u32CMR)
N
N/**
N * @brief Set the period of the selected channel
N * @param[in] pwm The base address of PWM module
N *                - PWM0 : PWM Group 0
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~1
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set timer loaded value(CNR) for specified channel.\n
N *          Loaded value determines the PWM period.
N * @note This new setting will take effect on next PWM period.
N * @note PWM counter will stop if period length set to 0.
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (*((__IO uint32_t *) ((((uint32_t)&((pwm)->PERIOD0)) + (u32ChannelNum) * 12))) = u32CNR)
N
N
N
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum,
N                                  uint32_t u32UnitTimeNsec,
N                                  uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                 uint32_t u32ChannelNum,
N                                 uint32_t u32Frequncy,
N                                 uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntType);
Nvoid PWM_DisableInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N/*@}*/ /* end of group ISD9100_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_PWM_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9161 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "rtc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\rtc.h" 1
N/**************************************************************************//**
N * @file     rtc.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/06/25 5:06p $
N * @brief    ISD9100 RTC driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __RTC_H
N#define __RTC_H
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_RTC_Driver RTC Driver
N  @{
N*/
N
N
N/** @addtogroup ISD9100_RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N
N
N#define RTC_INIT_KEY         0xA5EB1357UL  /*!< RTC Access Key   \hideinitializer */
N#define RTC_WRITE_KEY        0xA965         /*!< RTC Access Key  \hideinitializer */
N
N#define RTC_WAIT_COUNT       0xFFFFFFFF     /*!< Initial Time Out Value  \hideinitializer */
N
N#define RTC_YEAR2000         2000            /*!< RTC Reference \hideinitializer */
N#define RTC_FCR_REFERENCE    32761           /*!< RTC Reference \hideinitializer */
N
N#define RTC_CLOCK_12         0                /*!< RTC 12 Hour \hideinitializer */
N#define RTC_CLOCK_24         1                /*!< RTC 24 Hour \hideinitializer */
N
N#define RTC_AM               1                /*!< RTC AM \hideinitializer */
N#define RTC_PM               2                /*!< RTC PM \hideinitializer */
N
N#define RTC_TICK_1_SEC       ((uint32_t) 0x00000000)   /*!< Time tick is 1 second \hideinitializer */
N#define RTC_TICK_1_2_SEC     ((uint32_t) 0x00000001)   /*!< Time tick is 1/2 second \hideinitializer */
N#define RTC_TICK_1_4_SEC     ((uint32_t) 0x00000002)   /*!< Time tick is 1/4 second \hideinitializer */
N#define RTC_TICK_1_8_SEC     ((uint32_t) 0x00000003)   /*!< Time tick is 1/8 second \hideinitializer */
N#define RTC_TICK_1_16_SEC    ((uint32_t) 0x00000004)   /*!< Time tick is 1/16 second \hideinitializer */
N#define RTC_TICK_1_32_SEC    ((uint32_t) 0x00000005)   /*!< Time tick is 1/32 second \hideinitializer */
N#define RTC_TICK_1_64_SEC    ((uint32_t) 0x00000006)   /*!< Time tick is 1/64 second \hideinitializer */
N#define RTC_TICK_1_128_SEC   ((uint32_t) 0x00000007)   /*!< Time tick is 1/128 second \hideinitializer */
N
N#define RTC_SUNDAY       ((uint32_t) 0x00000000)
N#define RTC_MONDAY       ((uint32_t) 0x00000001)
N#define RTC_TUESDAY      ((uint32_t) 0x00000002)
N#define RTC_WEDNESDAY    ((uint32_t) 0x00000003)
N#define RTC_THURSDAY     ((uint32_t) 0x00000004)
N#define RTC_FRIDAY       ((uint32_t) 0x00000005)
N#define RTC_SATURDAY     ((uint32_t) 0x00000006)
N/*@}*/ /* end of group ISD9100_RTC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_RTC_EXPORTED_STRUCTS RTC Exported Structs
N  @{
N*/
N
N/**
N  * @brief  RTC define Time Data Struct
N  */
Ntypedef struct {
N    uint32_t u32Year;          /*!<  Year value */
N    uint32_t u32Month;         /*!<  Month value */
N    uint32_t u32Day;           /*!<  Day value */
N    uint32_t u32DayOfWeek;     /*!<  Day of week value */
N    uint32_t u32Hour;          /*!<  Hour value */
N    uint32_t u32Minute;        /*!<  Minute value */
N    uint32_t u32Second;        /*!<  Second value */
N    uint32_t u32TimeScale;     /*!<  12-Hour, 24-Hour */
N    uint32_t u32AmPm;          /*!<  Only Time Scale select 12-hr used */
N} S_RTC_TIME_DATA_T;
N
N/*@}*/ /* end of group ISD9100_RTC_EXPORTED_STRUCTS */
N
N
N
N
N/** @addtogroup ISD9100_RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
N
N/**
N *  @brief    According to current time, return this year is leap year or not
N *
N *  @param    None
N *
N *  @return   0 = This year is not a leap year. \n
N *            1 = This year is a leap year.
N * \hideinitializer 
N */
N#define RTC_IS_LEAP_YEAR    ((RTC->LEAPYEAR & (RTC_LEAPYEAR_LEAPYEAR_Msk))?1:0)
N
N/**
N *  @brief    Clear alarm interrupt status.
N *
N *  @param    None
N *
N *  @return   None
N * \hideinitializer 
N */
N#define RTC_CLEAR_ALARM_INT_FLAG    (RTC->INTSTS = RTC_INTSTS_ALMIF_Msk)
N
N/**
N *  @brief    Clear tick interrupt status.
N *
N *  @param    None
N *
N *  @return    None
N * \hideinitializer 
N */
N#define RTC_CLEAR_TICK_INT_FLAG    (RTC->INTSTS = RTC_INTSTS_TICKIF_Msk)
N
N/**
N *  @brief    Get alarm interrupt status.
N *
N *  @param    None
N *
N *  @return   Alarm interrupt status
N * \hideinitializer 
N */
N#define RTC_GET_ALARM_INT_FLAG    ((RTC->INTSTS & RTC_INTSTS_ALMIF_Msk) >> RTC_INTSTS_ALMIF_Pos)
N
N/**
N *  @brief    Get tick interrupt status.
N *
N *  @param    None
N *
N *  @return   tick interrupt status
N * \hideinitializer 
N */
N#define RTC_GET_TICK_INT_FLAG    ((RTC->INTSTS & RTC_INTSTS_TICKIF_Msk) >> RTC_INTSTS_TICKIF_Pos)
N
N
Nvoid RTC_Open(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_Close(void);
Nvoid RTC_32KCalibration(int32_t i32FrequencyX100);
Nvoid RTC_SetTickPeriod(uint32_t u32TickSelection);
Nvoid RTC_EnableInt(uint32_t u32IntFlagMask);
Nvoid RTC_DisableInt(uint32_t u32IntFlagMask);
Nuint32_t RTC_GetDayOfWeek(void);
Nvoid RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
Nvoid RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
Nvoid RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_EnableWakeUp(void);
Nvoid RTC_DisableWakeUp(void);
N
N
N/*@}*/ /* end of group ISD9100_RTC_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group ISD9100_RTC_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif /* __RTC_H */
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9162 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "spi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\spi.h" 1
N/****************************************************************************//**
N * @file     spi.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/07/25 10:10a $
N * @brief    ISD9100 SPI driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0            (SPI_CTL_TXNEG_Msk)                         /*!< CLKP=0; RX_NEG=0; TX_NEG=1 \hideinitializer */
N#define SPI_MODE_1            (SPI_CTL_RXNET_Msk)                         /*!< CLKP=0; RX_NEG=1; TX_NEG=0 \hideinitializer */
N#define SPI_MODE_2            (SPI_CTL_CLKPOL_Msk | SPI_CTL_TXNEG_Msk)    /*!< CLKP=1; RX_NEG=1; TX_NEG=0 \hideinitializer */
N#define SPI_MODE_3            (SPI_CTL_CLKPOL_Msk | SPI_CTL_RXNET_Msk)    /*!< CLKP=1; RX_NEG=0; TX_NEG=1 \hideinitializer */
N
N#define SPI_SLAVE             (0x1ul << SPI_CTL_SLAVE_Pos)                /*!< Set as slave \hideinitializer */
N#define SPI_MASTER            (0x0ul << SPI_CTL_SLAVE_Pos)                /*!< Set as master \hideinitializer */
N
N#define SPI_SS_NONE           (0x0ul<<SPI_SSCTL_SS_Pos)                   /*!< unset any spi port \hideinitializer */
N#define SPI_SS0               (0x1ul<<SPI_SSCTL_SS_Pos)                   /*!< Set SS0 \hideinitializer */
N#define SPI_SS1               (0x2ul<<SPI_SSCTL_SS_Pos)                   /*!< Set SS1 \hideinitializer */
N
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSCTL_SSACTPOL_Msk)                    /*!< SS active high \hideinitializer */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low \hideinitializer */
N
N#define SPI_TXNUM_ONE         (0x00ul << SPI_CTL_TX_NUM_Pos)              /*!< Only one transmit/receive word will be executed in one transfer \hideinitializer */      
N#define SPI_TXNUM_TWO         (0x01ul << SPI_CTL_TX_NUM_Pos)              /*!< Two successive transmit/receive word will be executed in one transfer \hideinitializer */      
N
N/*@}*/ /* end of group ISD9100_SPI_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief  Get the status flags.
N  * @param  spi is the base address of SPI module.
N  * @return status flags
N  * \hideinitializer
N  */
N#define SPI_GET_STATUS(spi) ( (spi)->CTL )
N
N/**
N  * @brief  Clear the unit transfer interrupt flag.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi) ( (spi)->CTL |= SPI_CTL_UNIT_INTSTS_Msk )
N
N/**
N  * @brief  Get the Rx FIFO empty flag.
N  * @param  spi is the base address of SPI module.
N  * @return Rx FIFO flag
N  * @retval 0: Rx FIFO is not empty
N  * @retval 1: Rx FIFO is empty
N  * \hideinitializer
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi) ( ((spi)->CTL & SPI_CTL_RXEMPTY_Msk) == SPI_CTL_RXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Rx FIFO full flag.
N  * @param  spi is the base address of SPI module.
N  * @return Rx FIFO flag
N  * @retval 0: Rx FIFO is not full
N  * @retval 1: Rx FIFO is full
N  * \hideinitializer
N  */
N#define SPI_GET_RX_FIFO_FULL_FLAG(spi) ( ((spi)->CTL & SPI_CTL_RXEMPTY_Msk) == SPI_CTL_RXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx FIFO empty flag.
N  * @param  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0: Tx FIFO is not empty
N  * @retval 1: Tx FIFO is empty
N  * \hideinitializer
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi) ( ((spi)->CTL & SPI_CTL_TXEMPTY_Msk) == SPI_CTL_TXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx FIFO full flag.
N  * @param  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0: Tx FIFO is not full
N  * @retval 1: Tx FIFO is full
N  * \hideinitializer
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi) ( ((spi)->CTL & SPI_CTL_TXFULL_Msk) == SPI_CTL_TXFULL_Msk ? 1:0 )
N
N/**
N  * @brief  Get the datum read from RX0 FIFO.
N  * @param  spi is the base address of SPI module.
N  * @return data in Rx0 register
N  * \hideinitializer
N  */
N#define SPI_READ_RX0(spi) ((spi)->RX0)
N
N
N/**
N  * @brief  Get the datum read from RX1 FIFO.
N  * @param  spi is the base address of SPI module.
N  * @return data in Rx1 register
N  * \hideinitializer
N  */
N#define SPI_READ_RX1(spi) ((spi)->RX1)
N
N/**
N  * @brief  Write datum to TX0 register.
N  * @param  spi is the base address of SPI module.
N  * @param  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_WRITE_TX0(spi, u32TxData) ( (spi)->TX0 = u32TxData )
N
N/**
N  * @brief  Write datum to TX1 register.
N  * @param  spi is the base address of SPI module.
N  * @param  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_WRITE_TX1(spi, u32TxData) ( (spi)->TX1 = u32TxData )
N
N/**
N  * @brief  Configure the slave select pins. 
N  * @param  spi is the base address of SPI module.
N  * @param  u32SS is the specified slave select pins will be set to active state.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_SS(spi,u32SS) ( (spi)->SSCTL = ( (spi)->SSCTL & ~SPI_SSCTL_SS_Msk ) | u32SS )
N
N/**
N  * @brief  Configure the set slave active level. 
N  * @param  spi is the base address of SPI module.
N  * @param  u32Level is the specified slave active level.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_SLAVE_ACTIVE_LEVEL(spi,u32Level) ( (spi)->SSCTL = ( (spi)->SSCTL & ~SPI_SSCTL_SS_LVL_Msk ) | u32Level )
N
N/**
N  * @brief Enable byte reorder function.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi) ( (spi)->CTL |= SPI_CTL_REORDER_Msk )
N
N/**
N  * @brief  Disable byte reorder function.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi) ( (spi)->CTL &= ~SPI_CTL_REORDER_Msk )
N
N/**
N  * @brief  Set the length of suspend interval.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @param  u32SuspCycle decides the length of suspend interval.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle) ( (spi)->CTL = ((spi)->CTL & ~SPI_CTL_SUSPITV_Msk) | (u32SuspCycle << SPI_CTL_SUSPITV_Pos) )
N
N/**
N  * @brief  Set the SPI transfer sequence with LSB first.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_LSB_FIRST(spi) ( (spi)->CTL |= SPI_CTL_LSB_Msk )
N
N/**
N  * @brief  Set the SPI transfer sequence with MSB first.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_MSB_FIRST(spi) ( (spi)->CTL &= ~SPI_CTL_LSB_Msk )
N
N/**
N  * @brief  Set the data width of a SPI transaction.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @param  u32Width data width
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_DATA_WIDTH(spi,u32Width) ( (spi)->CTL = ((spi)->CTL & ~SPI_CTL_DWIDTH_Msk)|((u32Width == 32 ? 0:u32Width)<<SPI_CTL_DWIDTH_Pos) ) 
N
N/**
N  * @brief  Set the data count of a SPI transaction.
N  * @param  spi is the base address of SPI module.
N  * @param  u32TxNum is the transmit/receive word numbers.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_SET_TX_NUM(spi,u32TxNum)  ((spi)->CTL = ((spi)->CTL & ~SPI_CTL_TX_NUM_Msk ) | u32TxNum)
N
N/**
N  * @brief  Get the SPI busy state.
N  * @param  spi is the base address of SPI module.
N  * @return SPI busy status
N  * @retval 0: SPI module is not busy
N  * @retval 1: SPI module is busy
N  * \hideinitializer
N  */
N#define SPI_IS_BUSY(spi) ( ((spi)->CTL & SPI_CTL_BUSY_Msk) == SPI_CTL_BUSY_Msk ? 1:0 )
N
N/**
N  * @brief  Set SPI to busy state.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_GO(spi) ((spi)->CTL |= SPI_CTL_BUSY_Msk)
N
N/**
N  * @brief  Enable SPI interrupt.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_ENABLE_INTERRUPT(spi)  ((spi)->CTL |= SPI_CTL_UNIT_INTEN_Msk)
N
N/**
N  * @brief  Disable SPI interrupt.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_DISABLE_INTERRUPT(spi)  ((spi)->CTL &= ~SPI_CTL_UNIT_INTEN_Msk)
N
N/**
N  * @brief  Enable the automatic slave select function. Only available in Master mode.
N  * @param  spi is the base address of SPI module.
N  * @param  u32SSPin specifies slave select pins. Valid values are:
N  *                     - \ref SPI_SS0
N  *                     - \ref SPI_SS1
N  * @param  u32ActiveLvl specifies the active level of slave select signal. Valid values are:
N  *                     - \ref SPI_SS_ACTIVE_HIGH
N  *                     - \ref SPI_SS_ACTIVE_LOW
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_ENABLE_AUTOSS(spi,u32SSPin,u32ActiveLvl)  ((spi)->SSCTL = ((spi)->SSCTL&~(SPI_SSCTL_SS_Msk|SPI_SSCTL_SS_LVL_Msk))|(u32SSPin|u32ActiveLvl|SPI_SSCTL_AUTOSS_Msk))
N
N/**
N  * @brief  Disable the automatic slave select function. 
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_DISABLE_AUTOSS(spi)  ((spi)->SSCTL &= ~SPI_SSCTL_AUTOSS_Msk)
N
N/**
N  * @brief  Trigger RX PDMA transfer.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_TRIGGER_RX_PDMA(spi) ( (spi)->PDMACTL |= SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Trigger TX PDMA transfer.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_TRIGGER_TX_PDMA(spi) ( (spi)->PDMACTL |= SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Disable RX PDMA transfer.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_DISABLE_RX_PDMA(spi) ( (spi)->PDMACTL &= ~SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Trigger TX PDMA transfer.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_DISABLE_TX_PDMA(spi) ( (spi)->PDMACTL &= ~SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Enable 2-bit transfer mode.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_ENABLE_2BIT_MODE(spi) ( (spi)->CTL |= SPI_CTL_TWOBIT_Msk )
N
N/**
N  * @brief  Disable 2-bit transfer mode.
N  * @note Before calling this function, SPI must be stopped first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define SPI_DISABLE_2BIT_MODE(spi) ( (spi)->CTL &= ~SPI_CTL_TWOBIT_Msk )
N
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32BusClock, uint32_t u32VarClock);
Nvoid     SPI_Close(SPI_T *spi);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid     SPI_SetVarClock(SPI_T *spi, uint32_t u32VarClock);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nuint32_t SPI_GetVarClock(SPI_T *spi);
N
N/*@}*/ /* end of group ISD9100_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_SPI_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9163 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "sys.h"
L 1 "..\..\..\..\Library\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/07/17 11:40a $
N * @brief    ISD9100 Series SYS Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N 
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RSTSTS constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define  SYS_RSTSTS_CORERSTF      (0x1UL<<SYS_RSTSTS_CORERSTF_Pos)   /*!<Core reset flag  \hideinitializer */
N#define  SYS_RSTSTS_WDTRF         (0x1UL<<SYS_RSTSTS_WDTRF_Pos)      /*!<Watch dog reset flag  \hideinitializer */
N#define  SYS_RSTSTS_SYSRF         (0x1UL<<SYS_RSTSTS_SYSRF_Pos)      /*!<System reset flag  \hideinitializer */
N#define  SYS_RSTSTS_PMURSTF       (0x1UL<<SYS_RSTSTS_PMURSTF_Pos)    /*!<Wake up reset flag  \hideinitializer */
N#define  SYS_RSTSTS_CPURF         (0x1UL<<SYS_RSTSTS_CPURF_Pos)      /*!<CPU reset flag   \hideinitializer */
N 	
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CHIP_RST    ((0x0<<24) | SYS_IPRST0_CHIPRST_Pos  ) /*!<Reset CHIP  \hideinitializer */
N#define CPU_RST     ((0x0<<24) | SYS_IPRST0_CPURST_Pos   ) /*!<Reset CPU  \hideinitializer  */
N#define PDMA_RST    ((0x0<<24) | SYS_IPRST0_PDMARST_Pos  ) /*!<Reset PDMA  \hideinitializer  */
N#define TMR0_RST    ((0x4<<24) | SYS_IPRST1_TMR0RST_Pos  ) /*!<Reset TMR0  \hideinitializer  */
N#define TMR1_RST    ((0x4<<24) | SYS_IPRST1_TMR1RST_Pos  ) /*!<Reset TMR1  \hideinitializer  */
N#define I2C0_RST    ((0x4<<24) | SYS_IPRST1_I2C0RST_Pos  ) /*!<Reset I2C0  \hideinitializer  */
N#define SPI0_RST    ((0x4<<24) | SYS_IPRST1_SPI0RST_Pos  ) /*!<Reset SPI0  \hideinitializer  */
N#define DPWM_RST    ((0x4<<24) | SYS_IPRST1_DPWMRST_Pos  ) /*!<Reset DPWM  \hideinitializer  */
N#define UART0_RST   ((0x4<<24) | SYS_IPRST1_UART0RST_Pos ) /*!<Reset UART0  \hideinitializer  */
N#define BIQ_RST     ((0x4<<24) | SYS_IPRST1_BIQRST_Pos   ) /*!<Reset BIQ  \hideinitializer  */
N#define CRC_RST     ((0x4<<24) | SYS_IPRST1_CRCRST_Pos   ) /*!<Reset CRC  \hideinitializer  */
N#define PWM0_RST    ((0x4<<24) | SYS_IPRST1_PWM0RST_Pos  ) /*!<Reset PWM0  \hideinitializer  */
N#define ACMP_RST    ((0x4<<24) | SYS_IPRST1_ACMPRST_Pos  ) /*!<Reset ACMP  \hideinitializer  */
N#define EADC_RST    ((0x4<<24) | SYS_IPRST1_EADCRST_Pos  ) /*!<Reset EADC  \hideinitializer  */
N#define I2S0_RST    ((0x4<<24) | SYS_IPRST1_I2S0RST_Pos  ) /*!<Reset I2S0  \hideinitializer  */
N#define ANA_RST     ((0x4<<24) | SYS_IPRST1_ANARST_Pos   ) /*!<Reset ANA  \hideinitializer  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Input Type Control Resister constant definitions.                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N// GPIOA
N#define SYS_PASMTEN_SMTEN16_GPIOA0     (0x1UL<<SYS_PASMTEN_SMTEN16_Pos)          /*!< PASMTEN SMTEN16 setting for GPIOA0 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN17_GPIOA1     (0x1UL<<SYS_PASMTEN_SMTEN17_Pos)          /*!< PASMTEN SMTEN17 setting for GPIOA1 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN18_GPIOA2     (0x1UL<<SYS_PASMTEN_SMTEN18_Pos)          /*!< PASMTEN SMTEN18 setting for GPIOA2 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN19_GPIOA3     (0x1UL<<SYS_PASMTEN_SMTEN19_Pos)          /*!< PASMTEN SMTEN19 setting for GPIOA3 input type   \hideinitializer */   
N#define SYS_PASMTEN_SMTEN20_GPIOA4     (0x1UL<<SYS_PASMTEN_SMTEN20_Pos)          /*!< PASMTEN SMTEN20 setting for GPIOA4 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN21_GPIOA5     (0x1UL<<SYS_PASMTEN_SMTEN21_Pos)          /*!< PASMTEN SMTEN21 setting for GPIOA5 input type   \hideinitializer */   
N#define SYS_PASMTEN_SMTEN22_GPIOA6     (0x1UL<<SYS_PASMTEN_SMTEN22_Pos)          /*!< PASMTEN SMTEN22 setting for GPIOA6 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN23_GPIOA7     (0x1UL<<SYS_PASMTEN_SMTEN23_Pos)          /*!< PASMTEN SMTEN23 setting for GPIOA7 input type   \hideinitializer */   
N#define SYS_PASMTEN_SMTEN24_GPIOA8     (0x1UL<<SYS_PASMTEN_SMTEN24_Pos)          /*!< PASMTEN SMTEN24 setting for GPIOA8 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN25_GPIOA9     (0x1UL<<SYS_PASMTEN_SMTEN25_Pos)          /*!< PASMTEN SMTEN25 setting for GPIOA9 input type   \hideinitializer */   
N#define SYS_PASMTEN_SMTEN26_GPIOA10    (0x1UL<<SYS_PASMTEN_SMTEN26_Pos)          /*!< PASMTEN SMTEN26 setting for GPIOA10 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN27_GPIOA11    (0x1UL<<SYS_PASMTEN_SMTEN27_Pos)          /*!< PASMTEN SMTEN27 setting for GPIOA11 input type   \hideinitializer */   
N#define SYS_PASMTEN_SMTEN28_GPIOA12    (0x1UL<<SYS_PASMTEN_SMTEN28_Pos)          /*!< PASMTEN SMTEN28 setting for GPIOA12 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN29_GPIOA13    (0x1UL<<SYS_PASMTEN_SMTEN29_Pos)          /*!< PASMTEN SMTEN29 setting for GPIOA13 input type   \hideinitializer */   
N#define SYS_PASMTEN_SMTEN30_GPIOA14    (0x1UL<<SYS_PASMTEN_SMTEN30_Pos)          /*!< PASMTEN SMTEN30 setting for GPIOA14 input type   \hideinitializer */     
N#define SYS_PASMTEN_SMTEN31_GPIOA15    (0x1UL<<SYS_PASMTEN_SMTEN31_Pos)          /*!< PASMTEN SMTEN31 setting for GPIOA15 input type   \hideinitializer */   
N
N// GPIOB
N#define SYS_PBSMTEN_SMTEN16_GPIOB0     (0x1UL<<SYS_PBSMTEN_SMTEN16_Pos)          /*!< PBSMTEN SMTEN16 setting for GPIOB0 input type   \hideinitializer */     
N#define SYS_PBSMTEN_SMTEN17_GPIOB1     (0x1UL<<SYS_PBSMTEN_SMTEN17_Pos)          /*!< PBSMTEN SMTEN17 setting for GPIOB1 input type   \hideinitializer */     
N#define SYS_PBSMTEN_SMTEN18_GPIOB2     (0x1UL<<SYS_PBSMTEN_SMTEN18_Pos)          /*!< PBSMTEN SMTEN18 setting for GPIOB2 input type   \hideinitializer */     
N#define SYS_PBSMTEN_SMTEN19_GPIOB3     (0x1UL<<SYS_PBSMTEN_SMTEN19_Pos)          /*!< PBSMTEN SMTEN19 setting for GPIOB3 input type   \hideinitializer */   
N#define SYS_PBSMTEN_SMTEN20_GPIOB4     (0x1UL<<SYS_PBSMTEN_SMTEN20_Pos)          /*!< PBSMTEN SMTEN20 setting for GPIOB4 input type   \hideinitializer */     
N#define SYS_PBSMTEN_SMTEN21_GPIOB5     (0x1UL<<SYS_PBSMTEN_SMTEN21_Pos)          /*!< PBSMTEN SMTEN21 setting for GPIOB5 input type   \hideinitializer */   
N#define SYS_PBSMTEN_SMTEN22_GPIOB6     (0x1UL<<SYS_PBSMTEN_SMTEN22_Pos)          /*!< PBSMTEN SMTEN22 setting for GPIOB6 input type   \hideinitializer */     
N#define SYS_PBSMTEN_SMTEN23_GPIOB7     (0x1UL<<SYS_PBSMTEN_SMTEN23_Pos)          /*!< PBSMTEN SMTEN23 setting for GPIOB7 input type   \hideinitializer */   
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N/* How to use below #define?
NExample 1: If user want to set PA.0 as SPI_MOSI0 in initial function,
N           user can issue following command to achieve it.
N
N           SYS->GPA_MFP  = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA0MFP_Msk) ) | SYS_GPA_MFP_PA0MFP_SPI_MOSI0  ;
N
N*/
N//GPA_MFP_PA0MFP
N#define SYS_GPA_MFP_PA0MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA0MFP_Pos)           /*!< GPA_MFP PA0 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA0MFP_SPI_MOSI0   (0x1UL<<SYS_GPA_MFP_PA0MFP_Pos)           /*!< GPA_MFP PA0 setting for SPI_MOSI0   \hideinitializer */
N#define SYS_GPA_MFP_PA0MFP_MCLK        (0x2UL<<SYS_GPA_MFP_PA0MFP_Pos)           /*!< GPA_MFP PA0 setting for MCLK   \hideinitializer */
N
N//GPA_MFP_PA1MFP
N#define SYS_GPA_MFP_PA1MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA1MFP_Pos)           /*!< GPA_MFP PA1 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA1MFP_SPI_SCLK    (0x1UL<<SYS_GPA_MFP_PA1MFP_Pos)           /*!< GPA_MFP PA1 setting for SPI_SCLK   \hideinitializer */
N#define SYS_GPA_MFP_PA1MFP_I2C_SCL     (0x2UL<<SYS_GPA_MFP_PA1MFP_Pos)           /*!< GPA_MFP PA1 setting for I2C_SCL   \hideinitializer */
N
N//GPA_MFP_PA2MFP
N#define SYS_GPA_MFP_PA2MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA2MFP_Pos)           /*!< GPA_MFP PA2 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA2MFP_SPI_SSB0    (0x1UL<<SYS_GPA_MFP_PA2MFP_Pos)           /*!< GPA_MFP PA2 setting for SPI_SSB0   \hideinitializer */
N
N//GPA_MFP_PA3MFP
N#define SYS_GPA_MFP_PA3MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA3MFP_Pos)           /*!< GPA_MFP PA3 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA3MFP_SPI_MISO0   (0x1UL<<SYS_GPA_MFP_PA3MFP_Pos)           /*!< GPA_MFP PA3 setting for SPI_MISO0   \hideinitializer */
N#define SYS_GPA_MFP_PA3MFP_I2C_SDA     (0x2UL<<SYS_GPA_MFP_PA3MFP_Pos)           /*!< GPA_MFP PA3 setting for I2C_SDA   \hideinitializer */
N
N//GPA_MFP_PA4MFP
N#define SYS_GPA_MFP_PA4MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA4MFP_Pos)           /*!< GPA_MFP PA4 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA4MFP_I2S_FS      (0x1UL<<SYS_GPA_MFP_PA4MFP_Pos)           /*!< GPA_MFP PA4 setting for I2S_FS   \hideinitializer */
N
N//GPA_MFP_PA5MFP
N#define SYS_GPA_MFP_PA5MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA5MFP_Pos)           /*!< GPA_MFP PA5 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA5MFP_I2S_BCLK    (0x1UL<<SYS_GPA_MFP_PA5MFP_Pos)           /*!< GPA_MFP PA5 setting for I2S_BCLK   \hideinitializer */
N
N//GPA_MFP_PA6MFP
N#define SYS_GPA_MFP_PA6MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA6MFP_Pos)           /*!< GPA_MFP PA6 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA6MFP_I2S_SDI     (0x1UL<<SYS_GPA_MFP_PA6MFP_Pos)           /*!< GPA_MFP PA6 setting for I2S_SDI   \hideinitializer */
N
N//GPA_MFP_PA7MFP
N#define SYS_GPA_MFP_PA7MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA7MFP_Pos)           /*!< GPA_MFP PA7 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA7MFP_I2S_SDO     (0x1UL<<SYS_GPA_MFP_PA7MFP_Pos)           /*!< GPA_MFP PA7 setting for I2S_SDO   \hideinitializer */
N
N//GPA_MFP_PA8MFP
N#define SYS_GPA_MFP_PA8MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA8MFP_Pos)           /*!< GPA_MFP PA8 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA8MFP_UART_TX     (0x1UL<<SYS_GPA_MFP_PA8MFP_Pos)           /*!< GPA_MFP PA8 setting for UART_TX   \hideinitializer */
N#define SYS_GPA_MFP_PA8MFP_I2S_FS      (0x2UL<<SYS_GPA_MFP_PA8MFP_Pos)           /*!< GPA_MFP PA8 setting for I2S_FS   \hideinitializer */
N
N//GPA_MFP_PA9MFP
N#define SYS_GPA_MFP_PA9MFP_GPIO        (0x0UL<<SYS_GPA_MFP_PA9MFP_Pos)           /*!< GPA_MFP PA9 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA9MFP_UART_RX     (0x1UL<<SYS_GPA_MFP_PA9MFP_Pos)           /*!< GPA_MFP PA9 setting for UART_RX   \hideinitializer */
N#define SYS_GPA_MFP_PA9MFP_I2S_BCLK    (0x2UL<<SYS_GPA_MFP_PA9MFP_Pos)           /*!< GPA_MFP PA9 setting for I2S_BCLK   \hideinitializer */
N
N//GPA_MFP_PA10MFP
N#define SYS_GPA_MFP_PA10MFP_GPIO       (0x0UL<<SYS_GPA_MFP_PA10MFP_Pos)          /*!< GPA_MFP PA10 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA10MFP_I2C_SDA    (0x1UL<<SYS_GPA_MFP_PA10MFP_Pos)          /*!< GPA_MFP PA10 setting for I2C_SDA   \hideinitializer */
N#define SYS_GPA_MFP_PA10MFP_I2S_SDI    (0x2UL<<SYS_GPA_MFP_PA10MFP_Pos)          /*!< GPA_MFP PA10 setting for I2S_SDI   \hideinitializer */
N#define SYS_GPA_MFP_PA10MFP_UART_RTSn  (0x3UL<<SYS_GPA_MFP_PA10MFP_Pos)          /*!< GPA_MFP PA10 setting for UART_RTSn   \hideinitializer */
N
N//GPA_MFP_PA11MFP
N#define SYS_GPA_MFP_PA11MFP_GPIO       (0x0UL<<SYS_GPA_MFP_PA11MFP_Pos)          /*!< GPA_MFP PA11 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA11MFP_I2C_SCL    (0x1UL<<SYS_GPA_MFP_PA11MFP_Pos)          /*!< GPA_MFP PA11 setting for I2C_SCL   \hideinitializer */
N#define SYS_GPA_MFP_PA11MFP_I2S_SDO    (0x2UL<<SYS_GPA_MFP_PA11MFP_Pos)          /*!< GPA_MFP PA11 setting for I2S_SDO   \hideinitializer */
N#define SYS_GPA_MFP_PA11MFP_UART_CTSn  (0x3UL<<SYS_GPA_MFP_PA11MFP_Pos)          /*!< GPA_MFP PA11 setting for UART_CTSn   \hideinitializer */
N
N//GPA_MFP_PA12MFP
N#define SYS_GPA_MFP_PA12MFP_GPIO       (0x0UL<<SYS_GPA_MFP_PA12MFP_Pos)          /*!< GPA_MFP PA12 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA12MFP_PWM0CH0    (0x1UL<<SYS_GPA_MFP_PA12MFP_Pos)          /*!< GPA_MFP PA12 setting for PWM0CH0   \hideinitializer */
N#define SYS_GPA_MFP_PA12MFP_SPKP       (0x2UL<<SYS_GPA_MFP_PA12MFP_Pos)          /*!< GPA_MFP PA12 setting for SPKP   \hideinitializer */
N#define SYS_GPA_MFP_PA12MFP_I2S_FS     (0x3UL<<SYS_GPA_MFP_PA12MFP_Pos)          /*!< GPA_MFP PA12 setting for I2S_FS   \hideinitializer */
N
N//GPA_MFP_PA13MFP
N#define SYS_GPA_MFP_PA13MFP_GPIO       (0x0UL<<SYS_GPA_MFP_PA13MFP_Pos)          /*!< GPA_MFP PA13 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA13MFP_PWM0CH1    (0x1UL<<SYS_GPA_MFP_PA13MFP_Pos)          /*!< GPA_MFP PA13 setting for PWM0CH1   \hideinitializer */
N#define SYS_GPA_MFP_PA13MFP_SPKM       (0x2UL<<SYS_GPA_MFP_PA13MFP_Pos)          /*!< GPA_MFP PA13 setting for SPKM   \hideinitializer */
N#define SYS_GPA_MFP_PA13MFP_I2S_BCLK   (0x3UL<<SYS_GPA_MFP_PA13MFP_Pos)          /*!< GPA_MFP PA13 setting for I2S_BCLK   \hideinitializer */
N
N//GPA_MFP_PA14MFP
N#define SYS_GPA_MFP_PA14MFP_GPIO       (0x0UL<<SYS_GPA_MFP_PA14MFP_Pos)          /*!< GPA_MFP PA14 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA14MFP_TM0        (0x1UL<<SYS_GPA_MFP_PA14MFP_Pos)          /*!< GPA_MFP PA14 setting for TM0   \hideinitializer */
N#define SYS_GPA_MFP_PA14MFP_SDCLK      (0x2UL<<SYS_GPA_MFP_PA14MFP_Pos)          /*!< GPA_MFP PA14 setting for SDCLK   \hideinitializer */
N#define SYS_GPA_MFP_PA14MFP_SDCLKn     (0x3UL<<SYS_GPA_MFP_PA14MFP_Pos)          /*!< GPA_MFP PA14 setting for SDCLKn   \hideinitializer */
N
N//GPA_MFP_PA15MFP
N#define SYS_GPA_MFP_PA15MFP_GPIO       (0x0UL<<SYS_GPA_MFP_PA15MFP_Pos)          /*!< GPA_MFP PA15 setting for GPIO   \hideinitializer */
N#define SYS_GPA_MFP_PA15MFP_TM1        (0x1UL<<SYS_GPA_MFP_PA15MFP_Pos)          /*!< GPA_MFP PA15 setting for TM1   \hideinitializer */
N#define SYS_GPA_MFP_PA15MFP_SDIN       (0x2UL<<SYS_GPA_MFP_PA15MFP_Pos)          /*!< GPA_MFP PA15 setting for SDIN   \hideinitializer */
N
N//GPB_MFP_PB0MFP
N#define SYS_GPB_MFP_PB0MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB0MFP_Pos)           /*!< GPB_MFP PB0 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB0MFP_SPI_SSB1    (0x1UL<<SYS_GPB_MFP_PB0MFP_Pos)           /*!< GPB_MFP PB0 setting for SPI_SSB1   \hideinitializer */
N#define SYS_GPB_MFP_PB0MFP_CMP0        (0x2UL<<SYS_GPB_MFP_PB0MFP_Pos)           /*!< GPB_MFP PB0 setting for CMP0   \hideinitializer */
N#define SYS_GPB_MFP_PB0MFP_SPI_SSB0    (0x3UL<<SYS_GPB_MFP_PB0MFP_Pos)           /*!< GPB_MFP PB0 setting for SPI_SSB0   \hideinitializer */
N
N//GPB_MFP_PB1MFP
N#define SYS_GPB_MFP_PB1MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB1MFP_Pos)           /*!< GPB_MFP PB1 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB1MFP_MCLK        (0x1UL<<SYS_GPB_MFP_PB1MFP_Pos)           /*!< GPB_MFP PB1 setting for MCLK   \hideinitializer */
N#define SYS_GPB_MFP_PB1MFP_CMP1        (0x2UL<<SYS_GPB_MFP_PB1MFP_Pos)           /*!< GPB_MFP PB1 setting for CMP1   \hideinitializer */
N#define SYS_GPB_MFP_PB1MFP_SPI_SSB1    (0x3UL<<SYS_GPB_MFP_PB1MFP_Pos)           /*!< GPB_MFP PB1 setting for SPI_SSB1   \hideinitializer */
N
N//GPB_MFP_PB2MFP
N#define SYS_GPB_MFP_PB2MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB2MFP_Pos)           /*!< GPB_MFP PB2 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB2MFP_I2C_SCL     (0x1UL<<SYS_GPB_MFP_PB2MFP_Pos)           /*!< GPB_MFP PB2 setting for I2C_SCL   \hideinitializer */
N#define SYS_GPB_MFP_PB2MFP_CMP2        (0x2UL<<SYS_GPB_MFP_PB2MFP_Pos)           /*!< GPB_MFP PB2 setting for CMP2   \hideinitializer */
N#define SYS_GPB_MFP_PB2MFP_SPI_SCLK    (0x3UL<<SYS_GPB_MFP_PB2MFP_Pos)           /*!< GPB_MFP PB2 setting for SPI_SCLK   \hideinitializer */
N
N//GPB_MFP_PB3MFP
N#define SYS_GPB_MFP_PB3MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB3MFP_Pos)           /*!< GPB_MFP PB3 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB3MFP_I2C_SDA     (0x1UL<<SYS_GPB_MFP_PB3MFP_Pos)           /*!< GPB_MFP PB3 setting for I2C_SDA   \hideinitializer */
N#define SYS_GPB_MFP_PB3MFP_CMP3        (0x2UL<<SYS_GPB_MFP_PB3MFP_Pos)           /*!< GPB_MFP PB3 setting for CMP3   \hideinitializer */
N#define SYS_GPB_MFP_PB3MFP_SPI_MISO0   (0x3UL<<SYS_GPB_MFP_PB3MFP_Pos)           /*!< GPB_MFP PB3 setting for SPI_MISO0   \hideinitializer */
N
N//GPB_MFP_PB4MFP
N#define SYS_GPB_MFP_PB4MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB4MFP_Pos)           /*!< GPB_MFP PB4 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB4MFP_PWM0CH0_INV (0x1UL<<SYS_GPB_MFP_PB4MFP_Pos)           /*!< GPB_MFP PB4 setting for PWM0CH0_INV   \hideinitializer */
N#define SYS_GPB_MFP_PB4MFP_CMP4        (0x2UL<<SYS_GPB_MFP_PB4MFP_Pos)           /*!< GPB_MFP PB4 setting for CMP3   \hideinitializer */
N#define SYS_GPB_MFP_PB4MFP_SPI_MOSI0   (0x3UL<<SYS_GPB_MFP_PB4MFP_Pos)           /*!< GPB_MFP PB4 setting for SPI_MOSI0   \hideinitializer */
N
N//GPB_MFP_PB5MFP
N#define SYS_GPB_MFP_PB5MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB5MFP_Pos)           /*!< GPB_MFP PB5 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB5MFP_PWM0CH1_INV (0x1UL<<SYS_GPB_MFP_PB5MFP_Pos)           /*!< GPB_MFP PB5 setting for PWM0CH1_INV   \hideinitializer */
N#define SYS_GPB_MFP_PB5MFP_CMP5        (0x2UL<<SYS_GPB_MFP_PB5MFP_Pos)           /*!< GPB_MFP PB5 setting for CMP5   \hideinitializer */
N#define SYS_GPB_MFP_PB5MFP_SPI_MISO1   (0x3UL<<SYS_GPB_MFP_PB5MFP_Pos)           /*!< GPB_MFP PB5 setting for SPI_MISO1   \hideinitializer */
N
N//GPB_MFP_PB6MFP
N#define SYS_GPB_MFP_PB6MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB6MFP_Pos)           /*!< GPB_MFP PB6 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB6MFP_I2S_SDI     (0x1UL<<SYS_GPB_MFP_PB6MFP_Pos)           /*!< GPB_MFP PB6 setting for I2S_SDI   \hideinitializer */
N#define SYS_GPB_MFP_PB6MFP_CMP6        (0x2UL<<SYS_GPB_MFP_PB6MFP_Pos)           /*!< GPB_MFP PB6 setting for CMP6   \hideinitializer */
N#define SYS_GPB_MFP_PB6MFP_SPI_MOSI1   (0x3UL<<SYS_GPB_MFP_PB6MFP_Pos)           /*!< GPB_MFP PB6 setting for SPI_MOSI1   \hideinitializer */
N
N//GPB_MFP_PB7MFP
N#define SYS_GPB_MFP_PB7MFP_GPIO        (0x0UL<<SYS_GPB_MFP_PB7MFP_Pos)           /*!< GPB_MFP PB7 setting for GPIO   \hideinitializer */
N#define SYS_GPB_MFP_PB7MFP_I2S_SDO     (0x1UL<<SYS_GPB_MFP_PB7MFP_Pos)           /*!< GPB_MFP PB7 setting for I2S_SDO   \hideinitializer */
N#define SYS_GPB_MFP_PB7MFP_CMP7        (0x2UL<<SYS_GPB_MFP_PB7MFP_Pos)           /*!< GPB_MFP PB7 setting for CMP7   \hideinitializer */
N
N/*@}*/ /* end of group ISD9100_SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N#define SYS_IS_CPU_RST()                   (SYS->RSTSTS & SYS_RSTSTS_CPURF_Msk)   /*!< This macro get previous reset source is from CPU-Reset   \hideinitializer */
N#define SYS_IS_SYSTEM_RST()                (SYS->RSTSTS & SYS_RSTSTS_SYSRF_Msk)   /*!< This macro get previous reset source is from system reset   \hideinitializer */
N#define SYS_IS_WDT_RST()                   (SYS->RSTSTS & SYS_RSTSTS_WDTRF_Msk)   /*!< This macro get previous reset source is from window watch dog  reset   \hideinitializer */
N#define SYS_CLEAR_RST_SOURCE(u32RSTSTS)    (SYS->RSTSTS = u32RSTSTS )             /*!< This macro clears reset source   \hideinitializer */
N
N#define SYS_ENABLE_SCHMITT_GPIOA(u32Bit)   (SYS->PASMTEN | u32Bit)                /*!< This macro enable GPIOA(0-15) schmitt mode   \hideinitializer */
N#define SYS_DISABLE_SCHMITT_GPIOA(u32Bit)  (SYS->PASMTEN & (~u32Bit))             /*!< This macro disable GPIOA(0-15) schmitt mode   \hideinitializer */
N#define SYS_ENABLE_SCHMITT_GPIOB(u32Bit)   (SYS->PBSMTEN | u32Bit)                /*!< This macro enable GPIOB(0-7) schmitt mode   \hideinitializer */
N#define SYS_DISABLE_SCHMITT_GPIOB(u32Bit)  (SYS->PBSMTEN & (~u32Bit))             /*!< This macro disable GPIOB(0-7) schmitt mode   \hideinitializer */
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nvoid SYS_LockReg(void);
Nvoid SYS_Lock(uint8_t u8Lock);
Nvoid SYS_UnlockReg(void);
Nuint8_t SYS_Unlock(void);
Nuint32_t SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
N
N/*@}*/ /* end of group ISD9100_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_SYS_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9164 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "talarm.h"
L 1 "..\..\..\..\Library\StdDriver\inc\talarm.h" 1
N/**************************************************************************//**
N * @file     TALARM.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 14/07/03 15:06p $
N * @brief    ISD9100 TALARM driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __TALARM_H
N#define __TALARM_H
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_TALARM_Driver TALARM Driver
N  @{
N*/
N
N
N/** @addtogroup ISD9100_TALARM_EXPORTED_CONSTANTS TALARM Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TALMSEL constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TALARM_TALMVL_105C     (0x0)      /*!< Temperature Alarm Sense Level: 105C */
N#define TALARM_TALMVL_115C     (0x1)      /*!< Temperature Alarm Sense Level: 115C */
N#define TALARM_TALMVL_125C     (0x2)      /*!< Temperature Alarm Sense Level: 125C */
N#define TALARM_TALMVL_135C     (0x4)      /*!< Temperature Alarm Sense Level: 135C */ 
N#define TALARM_TALMVL_145C     (0x8)      /*!< Temperature Alarm Sense Level: 145C */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TALMCTL constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TALARM_TALMIEN_DISABLE  (0x0ul << BODTALM_TALMCTL_TALMIEN_Pos)          /*!< Disable TALARM Interrupt */ 
N#define TALARM_TALMIEN_ENABLE   (0x1ul << BODTALM_TALMCTL_TALMIEN_Pos)          /*!< Enable TALARM Interrupt */
N
N#define TALARM_TALMEN_DISABLE   (0x0ul << BODTALM_TALMCTL_TALMEN_Pos)           /*!< Disable TALARM Detection */
N#define TALARM_TALMEN_ENABLE    (0x1ul << BODTALM_TALMCTL_TALMEN_Pos)           /*!< Enable TALARM Detection */
N
N/*@}*/ /* end of group ISD9100_TALARM_EXPORTED_CONSTANTS */
N
N/** @addtogroup ISD9100_TALARM_EXPORTED_FUNCTIONS TALARM Exported Functions
N  @{
N*/
N
N/**
N  * @brief     This function will enable TALARM Interrupt.
N  * @param[in] TALM The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void TALARM_EnableInt(BODTALM_T *TALM)
Xstatic __inline void TALARM_EnableInt(BODTALM_T *TALM)
N{
N     TALM->TALMCTL |= BODTALM_TALMCTL_TALMIEN_Msk;    
X     TALM->TALMCTL |= (0x1ul << (2));    
N}
N
N/**
N  * @brief     This function will disable TALARM Interrupt.
N  * @param[in] TALM The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void TALARM_DisableInt(BODTALM_T *TALM)
Xstatic __inline void TALARM_DisableInt(BODTALM_T *TALM)
N{
N     TALM->TALMCTL &= (~BODTALM_TALMCTL_TALMIEN_Msk);    
X     TALM->TALMCTL &= (~(0x1ul << (2)));    
N}
N
N/**
N  * @brief     This function clears the TALARM interrupt flag.
N  * @param[in] TALM The base address of BODTALM module
N  * @return    None
N  */
N__STATIC_INLINE void TALARM_ClearIntFlag(BODTALM_T *TALM)
Xstatic __inline void TALARM_ClearIntFlag(BODTALM_T *TALM)
N{
N    TALM->TALMCTL |= BODTALM_TALMCTL_TALMIF_Msk;
X    TALM->TALMCTL |= (0x1ul << (3));
N}
N
N/**
N  * @brief     This function latched TALM interrupt occurred or not.
N  * @param[in] TALM The base address of BODTALM module
N  * @return    TALM interrupt occurred or not
N  * @retval    0 TALM interrupt did not occur
N  * @retval    1 TALM interrupt occurred
N  */
N__STATIC_INLINE uint32_t TALARM_GetIntFlag(BODTALM_T *TALM)
Xstatic __inline uint32_t TALARM_GetIntFlag(BODTALM_T *TALM)
N{
N    return ((TALM->TALMCTL&BODTALM_TALMCTL_TALMIF_Msk) ? 1 : 0 );
X    return ((TALM->TALMCTL&(0x1ul << (3))) ? 1 : 0 );
N}
N
N/**
N  * @brief     This function will monitored current state of the temperature alarm.
N  * @param[in] TALM The base address of BODTALM module
N  * @return    whether TALARM active or not.
N  * @retval    0 inactive
N  * @retval    1 active
N  */
N__STATIC_INLINE uint32_t TALARM_GetOutput(BODTALM_T *TALM)
Xstatic __inline uint32_t TALARM_GetOutput(BODTALM_T *TALM)
N{
N     return ((TALM->TALMCTL&BODTALM_TALMCTL_TALMOUT_Msk) ? 1 : 0);         	
X     return ((TALM->TALMCTL&(0x1ul << (1))) ? 1 : 0);         	
N}
N
Nvoid TALARM_Open(uint8_t u8TALMVL);
Nvoid TALARM_Close(void);
N
N/*@}*/ /* end of group ISD9100_TALARM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_TALARM_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TALARM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
N
N
N
L 9165 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "timer.h"
L 1 "..\..\..\..\Library\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/06/27 11:00a $
N * @brief    ISD9100 TIMER driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL)                          /*!< Timer working in one shot mode  \hideinitializer */
N#define TIMER_PERIODIC_MODE                 (1UL << TMR_CTL_OPMODE_Pos)    /*!< Timer working in periodic mode  \hideinitializer */
N#define TIMER_CONTINUOUS_MODE               (3UL << TMR_CTL_OPMODE_Pos)    /*!< Timer working in continuous mode  \hideinitializer */
N
N/*@}*/ /* end of group ISD9100_TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to set new Timer compared value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer compare value. Valid values are between 2 to 0xFFFFFF
N  * @return None
N  * \hideinitializer
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value) ((timer)->CMP = (u32Value))
N
N/**
N  * @brief This macro is used to set new Timer prescale value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer prescale value. Valid values are between 0 to 0xFF
N  * @return None
N  * @note Clock input is divided by (prescale + 1) before it is fed into timer
N  * \hideinitializer
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value) ((timer)->CTL = ((timer)->CTL & ~TMR_CTL_PSC_Msk) | (u32Value))
N
N/**
N  * @brief This macro is used to check if specify Timer is inactive or active
N  * @return timer is activate or inactivate
N  * @retval 0 Timer 24-bit up counter is inactive
N  * @retval 1 Timer 24-bit up counter is active
N  * \hideinitializer
N  */
N#define TIMER_IS_ACTIVE(timer) ((timer)->CTL & TMR_CTL_ACTSTS_Msk ? 1 : 0)
N
N/**
N  * @brief This function is used to start Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Start(TMR_T *timer)
Xstatic __inline void TIMER_Start(TMR_T *timer)
N{
N    timer->CTL |= TMR_CTL_CNTEN_Msk;
X    timer->CTL |= (0x1ul << (30));
N}
N
N/**
N  * @brief This function is used to stop Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Stop(TMR_T *timer)
Xstatic __inline void TIMER_Stop(TMR_T *timer)
N{
N    timer->CTL &= ~TMR_CTL_CNTEN_Msk;
X    timer->CTL &= ~(0x1ul << (30));
N}
N
N/**
N  * @brief This function is used to enable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableInt(TMR_T *timer)
Xstatic __inline void TIMER_EnableInt(TMR_T *timer)
N{
N    timer->CTL |= TMR_CTL_INTEN_Msk;
X    timer->CTL |= (0x1ul << (29));
N}
N
N/**
N  * @brief This function is used to disable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableInt(TMR_T *timer)
Xstatic __inline void TIMER_DisableInt(TMR_T *timer)
N{
N    timer->CTL &= ~TMR_CTL_INTEN_Msk;
X    timer->CTL &= ~(0x1ul << (29));
N}
N
N/**
N  * @brief This function indicates Timer time-out interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer time-out interrupt occurred or not
N  * @retval 0 Timer time-out interrupt did not occur
N  * @retval 1 Timer time-out interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetIntFlag(TMR_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TMR_T *timer)
N{
N    return(timer->INTSTS & TMR_INTSTS_TIF_Msk ? 1 : 0);
X    return(timer->INTSTS & (0x1ul << (0)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer time-out interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearIntFlag(TMR_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TMR_T *timer)
N{
N    timer->INTSTS = TMR_INTSTS_TIF_Msk;
X    timer->INTSTS = (0x1ul << (0));
N}
N/**
N  * @brief This function reports the current timer counter value.
N  * @param[in] timer The base address of Timer module
N  * @return Timer counter value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCounter(TMR_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TMR_T *timer)
N{
N    return timer->CNT;
N}
N
Nuint32_t TIMER_Open(TMR_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid     TIMER_Close(TMR_T *timer);
Nvoid     TIMER_Delay(TMR_T *timer, uint32_t u32Usec);
Nuint32_t TIMER_GetModuleClock(TMR_T *timer);
Nuint32_t TIMER_GetWorkingFreq(TMR_T *timer);
N
N
N/*@}*/ /* end of group ISD9100_TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_TIMER_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9166 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "uart.h"
L 1 "..\..\..\..\Library\StdDriver\inc\uart.h" 1
N/**************************************************************************//**
N * @file     uart.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/07/17 2:50p $
N * @brief    ISD9100 Series UART driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N
N#ifndef __UART_H__
N#define __UART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FIFO constants definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FIFO_RFITL_1BYTE        (0x0 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FIFO_RFITL_4BYTES       (0x1 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FIFO_RFITL_8BYTES       (0x2 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FIFO_RFITL_14BYTES      (0x3 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FIFO_RTSTRGLV_1BYTE     (0x0 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 1 bit */
N#define UART_FIFO_RTSTRGLV_4BYTES    (0x1 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 4 bits */
N#define UART_FIFO_RTSTRGLV_8BYTES    (0x2 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 8 bits */
N#define UART_FIFO_RTSTRGLV_14BYTES   (0x3 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_LINE constants definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5     (0) /*!< UART_LINE setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6     (1) /*!< UART_LINE setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7     (2) /*!< UART_LINE setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8     (3) /*!< UART_LINE setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for two stop bit when 6, 7, 8-bit word length */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG    (0x1 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is High Level Trigger   */
N#define UART_RTS_IS_LOW_LEV_TRG     (0x0 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is Low Level Trigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FUNCSEL constants definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNCSEL_UART  ((0x0 << UART_FUNCSEL_LINEN_Pos)|(0x0 << UART_FUNCSEL_IRDAEN_Pos))  /*!< UART_FUNCSEL setting to set UART Function  (Default) */
N#define UART_FUNCSEL_LINE  (0x1 << UART_FUNCSEL_LINEN_Pos)                                     /*!< UART_FUNCSEL setting to set Line Function           */
N#define UART_FUNCSEL_IrDA  (0x1 << UART_FUNCSEL_IRDAEN_Pos)                                    /*!< UART_FUNCSEL setting to set IrDA Function            */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_BAUDM1_Msk | UART_BAUD_BAUDM0_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N
N/*@}*/ /* end of group ISD9100_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief   Calculate UART baudrate mode0 divider
N *
N *    @param   u32SrcFreq      UART clock frequency
N *    @param   u32BaudRate     Baudrate of UART module
N *
N *    @return  UART baudrate mode0 divider
N *  \hideinitializer 
N *
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N *    @brief   Calculate UART baudrate mode2 divider
N *
N *    @param   u32SrcFreq     UART clock frequency
N *    @param   u32BaudRate    Baudrate of UART module
N *
N *    @return  UART baudrate mode2 divider
N * \hideinitializer 
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-2)
N
N
N/**
N *    @brief   Write Data to Tx data register
N *
N *    @param   uart    The base address of UART module.
N *    @param   u8Data  Data byte to transmit
N *
N *    @return  None
N * \hideinitializer 
N */
N#define UART_WRITE(uart, u8Data)    (uart->DAT = (u8Data))
N
N/**
N *    @brief   Read Rx data register
N *
N *    @param   uart   The base address of UART module.
N *
N *    @return  The oldest data byte in RX FIFO
N * \hideinitializer 
N */
N#define UART_READ(uart)    (uart->DAT)
N
N
N/**
N *    @brief    Get Tx empty register value.
N *
N *    @param    uart    The base address of UART module
N *
N *    @return   Tx empty register value.
N * \hideinitializer 
N */
N#define UART_GET_TX_EMPTY(uart)    (uart->FIFOSTS & UART_FIFOSTS_TXEMPTY_Msk)
N
N
N/**
N *    @brief    Get Rx empty register value.
N *
N *    @param    uart    The base address of UART module
N *
N *    @return   Rx empty register value.
N * \hideinitializer 
N */
N#define UART_GET_RX_EMPTY(uart)    (uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)
N
N/**
N *    @brief    Check specified uart port transmission is over.
N *
N *    @param    uart    The base address of UART module
N *
N *    @return   TE_Flag.
N * \hideinitializer 
N */
N#define UART_IS_TX_EMPTY(uart)    ((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos)
N
N
N/**
N *    @brief    Wait specified uart port transmission is over
N *
N *    @param    uart    The base address of UART module
N *
N *    @return   None
N *  \hideinitializer 
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!(((uart->FIFOSTS) & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos))
N
N/**
N *    @brief    Check RDA_IF is set or not
N *
N *    @param    uart    The base address of UART module
N *
N *    @return
N *            0 : The number of bytes in the RX FIFO is less than the RFITL
N *            1 : The number of bytes in the RX FIFO equals or larger than RFITL
N * \hideinitializer 
N */
N#define UART_IS_RX_READY(uart)    ((uart->INTSTS & UART_INTSTS_RDAIF_Msk)>>UART_INTSTS_RDAIF_Pos)
N
N
N/**
N *    @brief    Check TX FIFO is full or not
N *
N *    @param    uart    The base address of UART module
N *
N *    @return
N *            1 = TX FIFO is full
N *            0 = TX FIFO is not full
N * \hideinitializer 
N */
N#define UART_IS_TX_FULL(uart)    ((uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)>>UART_FIFOSTS_TXFULL_Pos)
N
N/**
N *    @brief    Check RX FIFO is full or not
N *
N *    @param    uart    The base address of UART module
N *
N *    @return
N *            1 = RX FIFO is full
N *            0 = RX FIFO is not full
N * \hideinitializer 
N *
N */
N#define UART_IS_RX_FULL(uart)    ((uart->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)>>UART_FIFOSTS_RXFULL_Pos)
N
N
N/**
N *    @brief    Get Tx full register value
N *
N *    @param    uart    The base address of UART module
N *
N *    @return   Tx full register value
N * \hideinitializer 
N */
N#define UART_GET_TX_FULL(uart)    (uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)
N
N
N/**
N *    @brief    Get Rx full register value
N *
N *    @param    uart    The base address of UART module
N *
N *    @return   Rx full register value
N * \hideinitializer 
N */
N#define UART_GET_RX_FULL(uart)    (uart->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)
N
N
N/**
N *    @brief    Enable specified interrupt
N *
N *    @param    uart          The base address of UART module
N *    @param    u32eIntSel    Interrupt type select
N *                               - UART_INTEN_TOCNTEN_Msk    : Rx Time Out interrupt
N *                               - UART_INTEN_WKCTSIEN_Msk   : Wakeup interrupt
N *                               - UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                               - UART_INTEN_RXTOIEN_Msk    : Rx time-out interrupt
N *                               - UART_INTEN_MODEMIEN_Msk   : Modem interrupt
N *                               - UART_INTEN_RLSIEN_Msk     : Rx Line status interrupt
N *                               - UART_INTEN_THREIEN_Msk    : Tx empty interrupt
N *                               - UART_INTEN_RDAIEN_Msk     : Rx ready interrupt
N *
N *    @return    None
N * \hideinitializer 
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    (uart->INTSTS |= (u32eIntSel))
N
N
N/**
N *    @brief    Disable specified interrupt
N *
N *    @param    uart         The base address of UART module
N *    @param    u32eIntSel   Interrupt type select
N *                               - UART_INTEN_TOCNTEN_Msk    : Rx Time Out interrupt
N *                               - UART_INTEN_WKCTSIEN_Msk   : Wakeup interrupt
N *                               - UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                               - UART_INTEN_RXTOIEN_Msk    : Rx time-out interrupt
N *                               - UART_INTEN_MODEMIEN_Msk   : Modem interrupt
N *                               - UART_INTEN_RLSIEN_Msk     : Rx Line status interrupt
N *                               - UART_INTEN_THREIEN_Msk    : Tx empty interrupt
N *                               - UART_INTEN_RDAIEN_Msk     : Rx ready interrupt
N *    @return    None
N * \hideinitializer 
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    (uart->INTEN &= ~ (u32eIntSel))
N
N
N/**
N *    @brief    Get specified interrupt flag/status
N *
N *    @param    uart              The base address of UART module
N *    @param    u32eIntTypeFlag   Interrupt type select
N *                               - UART_INTEN_TOCNTEN_Msk    : Rx Time Out interrupt
N *                               - UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                               - UART_INTEN_RXTOIEN_Msk    : Rx time-out interrupt
N *                               - UART_INTEN_MODEMIEN_Msk   : Modem interrupt
N *                               - UART_INTEN_RLSIEN_Msk     : Rx Line status interrupt
N *                               - UART_INTEN_THREIEN_Msk    : Tx empty interrupt
N *                               - UART_INTEN_RDAIEN_Msk     : Rx ready interrupt
N *
N *    @return
N *            0 = The specified interrupt is not happened.
N *            1 = The specified interrupt is happened.
N * \hideinitializer 
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    ((uart->INTSTS & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief    Set RTS pin is low
N *
N *    @param    uart    The base address of UART module
N *    @return   None
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
X    uart->MODEM |= (0x1ul << (9));
N    uart->MODEM &= UART_MODEM_RTS_Msk;
X    uart->MODEM &= (0x1ul << (1));
N}
N
N/**
N *    @brief    Set RTS pin is high
N *
N *    @param    uart    The base address of UART module
N *    @return   None
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk | UART_MODEM_RTS_Msk;
X    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
N}
N
N/**
N *    @brief    Clear RS-485 Address Byte Detection Flag
N *
N *    @param    uart    The base address of UART module
N *    @return   None
N * \hideinitializer 
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    (uart->FIFOSTS  |= UART_FIFOSTS_ADDRDETF_Msk)
N
N
N/**
N *    @brief    Get RS-485 Address Byte Detection Flag
N *
N *    @param    uart    The base address of UART module
N *    @return   RS-485  Address Byte Detection Flag
N * \hideinitializer 
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    ((uart->FIFOSTS  & UART_FIFOSTS_ADDRDETF_Msk) >> UART_FIFOSTS_ADDRDETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart );
Nvoid UART_DisableFlowCtrl(UART_T* uart );
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_EnableFlowCtrl(UART_T* uart );
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nuint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group ISD9100_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_UART_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
N
N
N
L 9167 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N#include "wdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 14/07/15 5:00p $
N * @brief    ISD9100 WDT driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup ISD9100_Device_Driver ISD9100 Device Driver
N  @{
N*/
N
N/** @addtogroup ISD9100_WDT_Driver WDT Driver
N  @{
N*/
N
N
N/** @addtogroup ISD9100_WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N	
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^4 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^6 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^8 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^10 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^12 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^14 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^16 * WDT clocks  \hideinitializer */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^18 * WDT clocks  \hideinitializer */
N
N/*@}*/ /* end of group ISD9100_WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ISD9100_WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro clear WDT time-out reset system flag.
N  * @return None
N  * \hideinitializer
N  */
N#define WDT_CLEAR_RESET_FLAG()			WDT_ClearResetFlag()
N
N/**
N  * @brief This macro clear WDT time-out interrupt flag.
N  * @return None
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG() 	WDT_ClearTimeOutIntFlag()
N
N/**
N  * @brief This macro indicate WDT time-out to reset system or not.
N  * @return WDT reset system or not
N  * @retval 0 WDT did not cause system reset
N  * @retval 1 WDT caused system reset
N  * \hideinitializer
N  */
N#define WDT_GET_RESET_FLAG() 			(WDT->CTL & WDT_CTL_RSTF_Msk ? 1 : 0)
N
N/**
N  * @brief This macro indicate WDT time-out interrupt occurred or not.
N  * @return WDT time-out interrupt occurred or not
N  * @retval 0 WDT time-out interrupt did not occur
N  * @retval 1 WDT time-out interrupt occurred
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG() 		(WDT->CTL & WDT_CTL_IF_Msk ? 1 : 0)
N
N/**
N  * @brief This macro is used to reset 18-bit WDT counter.
N  * @details If WDT is activated and enabled to reset system, software must reset WDT counter
N  *  before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  * \hideinitializer
N  */
N#define WDT_RESET_COUNTER()				WDT_ResetCounter()
N
Nvoid WDT_Open( uint32_t u32TimeoutInterval, uint32_t u32EnableReset );
Nvoid WDT_Close(void);
Nvoid WDT_EnableInt(void);
Nvoid WDT_DisableInt(void);
Nvoid WDT_ClearResetFlag(void);
Nvoid WDT_ClearTimeOutIntFlag(void);
Nvoid WDT_ResetCounter(void);
N
N/*@}*/ /* end of group ISD9100_WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ISD9100_WDT_Driver */
N
N/*@}*/ /* end of group ISD9100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 9168 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\ISD9100.h" 2
N
N
N#endif	// __ISD9100_H__
N
L 11 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\Platform.h" 2
N
N#define	__NUVOTON__									/* Nuvoton platform */
N
N#include "NVTTypes.h"								/* Nuvoton type definition */
L 1 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\NVTTypes.h" 1
N/****************************************************************
N *                                                              *
N * Copyright (c) Nuvoton Technology Corp. All rights reserved.  *
N *                                                              *
N ****************************************************************/
N
N#ifndef __NVTTYPES_H__
N#define __NVTTYPES_H__
N
N// To ADS, kl modified on 2009/09/30
N#if defined (__ARMCC_VERSION)
X#if 1L
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060002
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 13 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\NVTTypes.h" 2
N#endif
N// To ADS, kl modified on 2009/09/30
N
N#define CONST				const
N
N#define FALSE				0
N#define TRUE				1
N
N#ifndef __NVTTYPE_PVOID_DEFINED__
N#define __NVTTYPE_PVOID_DEFINED__
Ntypedef void *				PVOID;
N#endif	// #ifndef __NVTTYPE_PVOID_DEFINED__
N
N#ifndef __NVTTYPE_BOOL_DEFINED__
N#define __NVTTYPE_BOOL_DEFINED__
Ntypedef unsigned char		BOOL;
N#endif	// #ifndef __NVTTYPE_BOOL_DEFINED__
N
N#ifndef __NVTTYPE_PBOOL_DEFINED__
N#define __NVTTYPE_PBOOL_DEFINED__
Ntypedef unsigned char *		PBOOL;
N#endif	// #ifndef __NVTTYPE_PBOOL_DEFINED__
N
N#ifndef	__NVTTYPE_INT8__
N#define __NVTTYPE_INT8__
Ntypedef signed char			INT8;
N#endif	// #ifndef __NVTTYPE_INT8_DEFINED__
N
N#ifndef	__NVTTYPE_PINT8_DEFINED__
N#define __NVTTYPE_PINT8_DEFINED__
Ntypedef signed char *		PINT8;
N#endif	// #ifndef __NVTTYPE_PINT8_DEFINED__
N
N#ifndef	__NVTTYPE_UINT8_DEFINED__
N#define __NVTTYPE_UINT8_DEFINED__
Ntypedef unsigned char		UINT8;
N#endif	// #ifndef __NVTTYPE_UINT8_DEFINED__
N
N#ifndef	__NVTTYPE_PUINT8_DEFINED__
N#define __NVTTYPE_PUINT8_DEFINED__
Ntypedef unsigned char *		PUINT8;
N#endif	// #ifndef __NVTTYPE_PUINT8_DEFINED__
N
N#ifndef	__NVTTYPE_INT16_DEFINED__
N#define __NVTTYPE_INT16_DEFINED__
Ntypedef signed short		INT16;
N#endif	// #ifndef __NVTTYPE_INT16_DEFINED__
N
N#ifndef	__NVTTYPE_PINT16_DEFINED__
N#define __NVTTYPE_PINT16_DEFINED__
Ntypedef signed short *		PINT16;
N#endif	// #ifndef __NVTTYPE_PINT16_DEFINED__
N
N#ifndef	__NVTTYPE_UINT16_DEFINED__
N#define __NVTTYPE_UINT16_DEFINED__
Ntypedef unsigned short		UINT16;
N#endif	// #ifndef __NVTTYPE_UINT16_DEFINED__
N
N#ifndef	__NVTTYPE_PUINT16_DEFINED__
N#define __NVTTYPE_PUINT16_DEFINED__
Ntypedef unsigned short *	PUINT16;
N#endif	// #ifndef __NVTTYPE_PUINT16_DEFINED__
N
N#ifndef	__NVTTYPE_INT32_DEFINED__
N#define __NVTTYPE_INT32_DEFINED__
Ntypedef signed int			INT32;
N#endif	// #ifndef __NVTTYPE_INT32_DEFINED__
N
N#ifndef	__NVTTYPE_PINT32__
N#define __NVTTYPE_PINT32__
Ntypedef signed int *		PINT32;
N#endif	// #ifndef __NVTTYPE_PINT32__
N
N#ifndef	__NVTTYPE_UINT32_DEFINED__
N#define __NVTTYPE_UINT32_DEFINED__
Ntypedef unsigned int		UINT32;
N#endif	// #ifndef __NVTTYPE_UINT32_DEFINED__
N
N#ifndef	__NVTTYPE_PUINT32_DEFINED__
N#define __NVTTYPE_PUINT32_DEFINED__
Ntypedef unsigned int *		PUINT32;
N#endif	// #ifndef __NVTTYPE_PUINT32_DEFINED__
N
N#ifdef __GNUC__
S
S#ifndef	__NVTTYPE_INT64_DEFINED__
S#define __NVTTYPE_INT64_DEFINED__
Stypedef signed long long	INT64;
S#endif	// #ifndef __NVTTYPE_INT64_DEFINED__
S
S#ifndef	__NVTTYPE_PINT64_DEFINED__
S#define __NVTTYPE_PINT64_DEFINED__
Stypedef signed long long *	PINT64;
S#endif	// #ifndef __NVTTYPE_PINT64_DEFINED__
S
S#ifndef	__NVTTYPE_UINT64_DEFINED__
S#define __NVTTYPE_UINT64_DEFINED__
Stypedef unsigned long long	UINT64;
S#endif	// #ifndef __NVTTYPE_UINT64_DEFINED__
S
S#ifndef	__NVTTYPE_PUINT64_DEFINED__
S#define __NVTTYPE_PUINT64_DEFINED__
Stypedef unsigned long long *PUINT64;
S#endif	// #ifndef __NVTTYPE_PUINT64_DEFINED__
S
N#elif defined (__ARMCC_VERSION)
X#elif 1L
N
N#ifndef	__NVTTYPE_INT64_DEFINED__
N#define __NVTTYPE_INT64_DEFINED__
Ntypedef signed __int64		INT64;
N#endif	// #ifndef __NVTTYPE_INT64_DEFINED__
N
N#ifndef	__NVTTYPE_PINT64_DEFINED__
N#define __NVTTYPE_PINT64_DEFINED__
Ntypedef signed __int64 *	PINT64;
N#endif	// #ifndef __NVTTYPE_PINT64_DEFINED__
N
N#ifndef	__NVTTYPE_UINT64_DEFINED__
N#define __NVTTYPE_UINT64_DEFINED__
Ntypedef unsigned __int64	UINT64;
N#endif	// #ifndef __NVTTYPE_UINT64_DEFINED__
N
N#ifndef	__NVTTYPE_PUINT64_DEFINED__
N#define __NVTTYPE_PUINT64_DEFINED__
Ntypedef unsigned __int64	*PUINT64;
N#endif	// #ifndef __NVTTYPE_PUINT64_DEFINED__
N
N#endif	// __GNUC__
N
N#ifndef	__NVTTYPE_FLOAT_DEFINED__
N#define __NVTTYPE_FLOAT_DEFINED__
Ntypedef float				FLOAT;
N#endif	// #ifndef __NVTTYPE_FLOAT_DEFINED__
N
N#ifndef	__NVTTYPE_PFLOAT_DEFINED__
N#define __NVTTYPE_PFLOAT_DEFINED__
Ntypedef float *				PFLOAT;
N#endif	// #ifndef __NVTTYPE_PFLOAT_DEFINED__
N
N#ifndef	__NVTTYPE_DOUBLE_DEFINED__
N#define __NVTTYPE_DOUBLE_DEFINED__
Ntypedef double				DOUBLE;
N#endif	// #ifndef __NVTTYPE_DOUBLE_DEFINED__
N
N#ifndef	__NVTTYPE_PDOUBLE_DEFINED__
N#define __NVTTYPE_PDOUBLE_DEFINED__
Ntypedef double *			PDOUBLE;
N#endif	// #ifndef __NVTTYPE_PDOUBLE_DEFINED__
N
N#ifndef	__NVTTYPE_CHAR_DEFINED__
N#define __NVTTYPE_CHAR_DEFINED__
Ntypedef signed char			CHAR;
N#endif	// #ifndef __NVTTYPE_CHAR_DEFINED__
N
N#ifndef	__NVTTYPE_PCHAR_DEFINED__
N#define __NVTTYPE_PCHAR_DEFINED__
Ntypedef signed char *		PCHAR;
N#endif	// #ifndef __NVTTYPE_PCHAR_DEFINED__
N
N#ifndef	__NVTTYPE_PSTR_DEFINED__
N#define __NVTTYPE_PSTR_DEFINED__
Ntypedef signed char *		PSTR;
N#endif	// #ifndef __NVTTYPE_PSTR_DEFINED__
N
N#ifndef	__NVTTYPE_PCSTR_DEFINED__
N#define __NVTTYPE_PCSTR_DEFINED__
Ntypedef const signed char *	PCSTR;
N#endif	// #ifndef __NVTTYPE_PCSTR_DEFINED__
N
N#ifdef __GNUC__
S#ifndef	__NVTTYPE_WCHAR_DEFINED__
S#define __NVTTYPE_WCHAR_DEFINED__
Stypedef	UINT16				WCHAR;
S#endif	// #ifndef __NVTTYPE_WCHAR_DEFINED__
S
S#ifndef	__NVTTYPE_PWCHAR_DEFINED__
S#define __NVTTYPE_PWCHAR_DEFINED__
Stypedef	UINT16 *			PWCHAR;
S#endif	// #ifndef __NVTTYPE_PWCHAR_DEFINED__
S
S#ifndef	__NVTTYPE_PWSTR_DEFINED__
S#define __NVTTYPE_PWSTR_DEFINED__
Stypedef	UINT16 *			PWSTR;
S#endif	// #ifndef __NVTTYPE_PWSTR_DEFINED__
S
S#ifndef	__NVTTYPE_PCWSTR_DEFINED__
S#define __NVTTYPE_PCWSTR_DEFINED__
Stypedef	const UINT16 *		PCWSTR;
S#endif	// #ifndef __NVTTYPE_PCWSTR_DEFINED__
S
N#elif defined (__ARMCC_VERSION)
X#elif 1L
N#ifndef	__NVTTYPE_WCHAR_DEFINED__
N#define __NVTTYPE_WCHAR_DEFINED__
Ntypedef	wchar_t				WCHAR;
N#endif	// #ifndef __NVTTYPE_WCHAR_DEFINED__
N
N#ifndef	__NVTTYPE_PWCHAR_DEFINED__
N#define __NVTTYPE_PWCHAR_DEFINED__
Ntypedef	wchar_t *			PWCHAR;
N#endif	// #ifndef __NVTTYPE_PWCHAR_DEFINED__
N
N#ifndef	__NVTTYPE_PWSTR_DEFINED__
N#define __NVTTYPE_PWSTR_DEFINED__
Ntypedef	wchar_t *			PWSTR;
N#endif	// #ifndef __NVTTYPE_PWSTR_DEFINED__
N
N#ifndef	__NVTTYPE_PCWSTR_DEFINED__
N#define __NVTTYPE_PCWSTR_DEFINED__
Ntypedef	const wchar_t *		PCWSTR;
N#endif	// #ifndef __NVTTYPE_PCWSTR_DEFINED__
N
N#endif	// __GNUC__
N
N#ifndef	__NVTTYPE_SIZE_T_DEFINED__
N#define __NVTTYPE_SIZE_T_DEFINED__
Ntypedef UINT32				SIZE_T;
N#endif	// #ifndef __NVTTYPE_SIZE_T_DEFINED__
N
N#ifndef	__NVTTYPE_REG8_DEFINED__
N#define __NVTTYPE_REG8_DEFINED__
Ntypedef volatile UINT8		REG8;
N#endif	// #ifndef __NVTTYPE_REG8_DEFINED__
N
N#ifndef	__NVTTYPE_REG16_DEFINED__
N#define __NVTTYPE_REG16_DEFINED__
Ntypedef volatile UINT16		REG16;
N#endif	// #ifndef __NVTTYPE_REG16_DEFINED__
N
N#ifndef	__NVTTYPE_REG32_DEFINED__
N#define __NVTTYPE_REG32_DEFINED__
Ntypedef volatile UINT32		REG32;
N#endif	// #ifndef __NVTTYPE_REG32_DEFINED__
N
N#ifndef	__NVTTYPE_BYTE_DEFINED__
N#define __NVTTYPE_BYTE_DEFINED__
Ntypedef	unsigned char		BYTE;
N#endif	// #ifndef __NVTTYPE_BYTE_DEFINED__
N
Ntypedef UINT8				ERRCODE;
N
N#endif /* __NVTTYPES_H__ */
N
L 15 "..\..\..\..\Library\Device\Nuvoton\ISD9100\Include\Platform.h" 2
N
N#endif /* __PLATFORM_H__ */
L 12 "..\ConfigApp.h" 2
N#include "ConfigIP.h"
L 1 "..\ConfigIP.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                              */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __CONFIGIP_H__
N#define __CONFIGIP_H__	  	 
N
N#include "Platform.h"
N
N#if( !defined(__CHIP_SERIES__) )
X#if( !1L )
S#error "Please update all files in HW\Include\ from SDS version >= v3.50."
N#endif
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// PDMA Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
N/*  [31:24]						|		[20:19]					|		[15:12]					|		[11:8]						|		[7:6]									|		[5:4]						|		[3:2]						*/
N/*  Service selection |		Transfer Width	|		Wrap Int Select	|		Interrupt type		|		Destination behavior 	|		Source behavior	|		PDMA Mode 			*/
N/*----------------------------------------------------------------------------------------------------------------------------------------------------*/
N#define PDMA_WRAP_HALF					(0x4)
N#define PDMA_WRAP_END					(0x1)
N
N#define PDMA_SHOT_MODE					((0<<PDMA_DSCT_CTL_WAINTSEL_Pos)|(PDMA_INTENCH_TXOKIEN_Msk<<8))
N#define PDMA_WRAP_MODE					(((PDMA_WRAP_HALF|PDMA_WRAP_END)<<PDMA_DSCT_CTL_WAINTSEL_Pos)|(PDMA_INTENCH_WAINTEN_Msk<<8))
N
N#define PDMA_ADC_SEL					((PDMA_ADC<<24)|PDMA_WIDTH_16|PDMA_SHOT_MODE|PDMA_SAR_FIX|PDMA_DAR_INC|PDMA_APB_SRAM)
N#define PDMA_APU_SEL					((PDMA_DPWM<<24)|PDMA_WIDTH_16|PDMA_SHOT_MODE|PDMA_SAR_INC|PDMA_DAR_FIX|PDMA_SRAM_APB)
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// ADC Related Definitions  
N// -------------------------------------------------------------------------------------------------------------------------------
N#define ADC_MAX_RESOULTION				(32767)
N#define ADC_MIN_RESOULTION				(-32768)
N#define ADC_SAMPLE_RATE		  			(12000)
N#define ADC_PGA_GAIN					(600)    //def 600
N#define ADC_PDMA_CH						(0)		// PDMA supports 4 channels ,0~3.
N#define ADC_DOWNSAMPLE					(4)		// only 1, 2, 4
N												//---------------------------------------------------------------------------
N												//Select ADC downsampling scheme for MIC:
N												//  1-->No down sampling
N												//  2-->down x2 rate
N												//  4-->down x4 rate
N												//---------------------------------------------------------------------------
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// APU (DPWM) Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define APU_CLK_SOURCE					CLK_CLKSEL1_DPWMSEL_HIRC2X
N#define APU_CLK							(__HIRC<<(APU_CLK_SOURCE>>CLK_CLKSEL1_DPWMCKSEL_Pos))
N#define APU_MAX_RESOULTION				(32767)
N#define APU_MIN_RESOULTION				(-32768)
N#define APU_RAMP_STEP					(2)		// Increase or decrease value to do ramp down or do ramp up
N#define APU_PDMA_CH						(1)		// PDMA supports 4 channels ,0~3.
N#define APU_UPSAMPLE					(2)		// only 1 , 2,  4
N												//---------------------------------------------------------------------------
N												// Select APU upsampling scheme for speaker:
N												//  1-->No up sampling
N												//  2-->up x2 rate
N												//  4-->up x4 rate
N												//---------------------------------------------------------------------------
N												
N// -------------------------------------------------------------------------------------------------------------------------------
N// Timer0 Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define TIMER0_CLK_SOURCE 				CLK_CLKSEL1_TMR0SEL_HIRC
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// Timer1 Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define TIMER1_CLK_SOURCE 				CLK_CLKSEL1_TMR1SEL_LIRC
N#define TIMER1_FREQUENCY      			(100)
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// PWM0/1 Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define PWM01_CLK_SOURCE 				CLK_CLKSEL1_PWM0CH01SEL_HIRC
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// WDT Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define WDT_CLK_SOURCE 					CLK_CLKSEL1_WDTSEL_HIRC
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// SPIFLash Clock Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define SPI0_CLOCK						12000000
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// RTC Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define RTC_SYSTEM_TIME_YEAR			(2014)
N#define RTC_SYSTEM_TIME_MONTH			(12)
N#define RTC_SYSTEM_TIME_DAY				(1)
N#define RTC_SYSTEM_TIME_HOUR			(0)
N#define	RTC_SYSTEM_TIME_MINUTE			(0)
N#define RTC_SYSTEM_TIME_SECOND			(0)
N#define RTC_SYSTEM_TIME_DAYOFWEEK		(RTC_MONDAY)
N
N
N#endif
L 13 "..\ConfigApp.h" 2
N#include "SPIFlash.h"
L 1 "..\..\..\..\Library\Storage\inc\SPIFlash.h" 1
N/****************************************************************
N *                                                              *
N * Copyright (c) Nuvoton Technology Corp. All rights reserved.  *
N *                                                              *
N ****************************************************************/
N
N#ifndef __SPIFLASH_H__
N#define __SPIFLASH_H__
N
N// Include header file
N#include "Platform.h"
N#include "SysInfra.h"
L 1 "..\..\..\..\Library\Framework\inc\SysInfra.h" 1
N/****************************************************************
N *                                                              *
N * Copyright (c) Nuvoton Technology Corp. All rights reserved. *
N *                                                              *
N ****************************************************************/
N
N#ifndef __SYSINFRA_H__
N#define __SYSINFRA_H__
N
N// Include header file
N#include "Platform.h"
N#include "ModuleID.h"
L 1 "..\..\..\..\Library\Framework\inc\ModuleID.h" 1
N/****************************************************************
N *                                                              *
N *  Copyright (c) Nuvoton Technology Corp. All rights reserved. *
N *                                                              *
N ****************************************************************/
N
N#ifndef __MODULE_ID_H__
N#define __MODULE_ID_H__
N
N
Ntypedef enum
N{
N	// Module ID valid range: 0 ~ 255
N	
N	// Driver: Module ID					Module Name
N	MODULE_ID_DRVPROTECT		= 0,		// DrvProtect
N	MODULE_ID_DRVINT			= 1,		// DrvINT
N	MODULE_ID_DRVADC			= 2,		// DrvADC
N	MODULE_ID_DRVFMC			= 3,		// DrvFMC
N	MODULE_ID_DRVAIC			= 4,		// DrvAIC
N	MODULE_ID_DRVAPU			= 6,		// DrvAPU
N	MODULE_ID_DRVAUDIOADC		= 8,		// DrvAudioADC
N	MODULE_ID_DRVCACHE			= 10,		// DrvCache
N	MODULE_ID_DRVAES			= 11,		// DrvAES
N	MODULE_ID_DRVEBI			= 12,		// DrvEBI
N	MODULE_ID_DRVEDMA			= 13,		// DrvEDMA
N	MODULE_ID_DRVGDMA			= 14,		// DrvGDMA
N	MODULE_ID_DRVFSC			= 15,		// DrvFSC
N	MODULE_ID_DRVGE				= 16,		// DrvGE
N	MODULE_ID_DRVGPIO			= 18,		// DrvGPIO
N
N	MODULE_ID_DRVGPU			= 20,		// DrvGPU
N	MODULE_ID_DRVI2C			= 22,		// DrvI2C (S/W I2C for Non-UL; H/W I2C for UL)
N	MODULE_ID_DRVI2S			= 24,		// DrvI2S
N	MODULE_ID_DRVI2SM			= 26,		// DrvI2SM
N	MODULE_ID_DRVMPU			= 28,		// DrvMPU
N	MODULE_ID_DRVNAND			= 30,		// DrvNAND
N	MODULE_ID_DRVNAND512		= 31,		// DrvNAND512
N	MODULE_ID_DRVNOR			= 32,		// DrvNOR
N	MODULE_ID_DRVPWM			= 34,		// DrvPWM
N	MODULE_ID_DRVRTC			= 36,		// DrvRTC
N	MODULE_ID_DRVSDCARD			= 38,		// DrvSDCard
N	MODULE_ID_DRVSIO			= 39,		// DrvSerialIO
N
N	MODULE_ID_DRVSPI			= 40,		// DrvSPI
N	MODULE_ID_DRVSPIMS			= 41,		// DrvSPIMS
N	MODULE_ID_DRVSPIFLASH		= 42,		// DrvSPIFlash
N	MODULE_ID_DRVSPIM			= 43,		// DrvSPIM
N	MODULE_ID_DRVSYS			= 44,		// DrvSYS
N	MODULE_ID_DRVSPU			= 45,		// DrvSPU
N	MODULE_ID_DRVTIMER			= 46,		// DrvTimer
N	MODULE_ID_DRVUART			= 48,		// DrvUART
N	MODULE_ID_DRVUSB			= 50,		// DrvUSB
N	MODULE_ID_DRVUSBH			= 52,		// DrvUSBH
N	MODULE_ID_DRVVDMA			= 54,		// DrvVDMA
N	MODULE_ID_DRVVIDEOIN		= 56,		// DrvVideoIn
N	MODULE_ID_DRVVPOST			= 58,		// DrvVPOST
N
N	MODULE_ID_DRVVRAM			= 60,		// DrvVRAM
N	MODULE_ID_DRVW55U02			= 62,		// DrvW55U02
N	MODULE_ID_DRVI2CH			= 64,		// DrvI2CH (H/W I2C for Non-UL)
N	MODULE_ID_DRVWDT			= 66,		// DrvWDT
N	MODULE_ID_DRVJPEG			= 68,		// DrvJPEG
N	
N	MODULE_ID_DRVZEROG			= 70,		// DrvZeroG
N	MODULE_ID_DRVSI2C			= 71,		// DrvSI2C (S/W I2C for UL)
N	MODULE_ID_DRVRFWYS			= 72,		// DrvRFWYS
N	MODULE_ID_DRVBLT			= 73,		// DrvBLT
N	MODULE_ID_DRVSMB			= 74,		// DrvSMB (S/W System Manager Bus)
N	MODULE_ID_DRVSDRM			= 75,		// DrvSDRAM
N
N	// Audio: Module ID						Module Name
N	MODULE_ID_AACDEC			= 80,		// AACDecoder
N	MODULE_ID_AEC				= 81,		// AEC
N	MODULE_ID_BEATDET			= 82,		// BeatDetection
N	MODULE_ID_SNDEFF			= 83,		// SoundEffect
N	MODULE_ID_AUDIOSYN			= 84,		// AudioSynthesizer
N	MODULE_ID_G726ADPCM			= 85,		// G726ADPCM
N	MODULE_ID_IMAADPCM			= 86,		// IMAAdpcmCodec
N	MODULE_ID_NUSOUND			= 87,		// NuSound(Subband)
N	MODULE_ID_MP3DEC			= 88,		// MP3Decoder
N	MODULE_ID_NUONECODEC		= 89,		// NuOneCodec
N	MODULE_ID_PITCHCHANGE		= 90,		// PitchChanger	
N	MODULE_ID_NOISEFILTER		= 91,		// NoiseFilter
N	MODULE_ID_WAVFILEUTIL		= 92,		// WavFileUtil
N	MODULE_ID_BNDET				= 93,		// BNDetection
N	MODULE_ID_MIDISYN			= 94,		// MidiSynthesizer
N	MODULE_ID_VOICECHANGE		= 95,		// VoiceChanger
N	MODULE_ID_WMADEC			= 96,		// WMADecoder
N	MODULE_ID_WATERMARK			= 97,		// Watermark
N	MODULE_ID_WMADECDRM			= 98,		// WMADecoderWithDrm
N	MODULE_ID_AUDIOCTRL			= 100,		// AudioCtrl
N	MODULE_ID_EQ				= 106,		// Equalizer
N	MODULE_ID_OGGDEC			= 110,		// OggDecoder
N	MODULE_ID_MP3ENC			= 112,		// MP3Encoder
N	MODULE_ID_UADEC				= 114,		// UltraAudioDec
N	MODULE_ID_ULSPEECHDEC		= 115,		// UltraLowSpeechDec
N	MODULE_ID_USPEECHDEC		= 116,		// UltraSpeechDec
N	MODULE_ID_SPEECHRECOG		= 118,		// SpeechRecog
N	MODULE_ID_REVERB			= 119,		// ReverB
N
N	// File System: Module ID				Module Name
N	MODULE_ID_FS				= 120,		// FileSystem
N	
N	// Flash Lite: Module ID				Module Name
N	MODULE_ID_FL				= 128,		// FlashLite
N	
N	// Communication: Module ID				Module Name
N	MODULE_ID_KEYPAD			= 130,		// Keypad
N	MODULE_ID_IRCTRL			= 131,		// IRCTRL
N	MODULE_ID_LWIP				= 132,		// LwIP
N	MODULE_ID_SEMIHOST			= 133,		// SemiHost
N	MODULE_ID_WLANMGR			= 134,		// WLanMgr
N	MODULE_ID_VSCOMMU			= 135,		// VSCommu
N	MODULE_ID_HTTPD				= 136,		// HTTPD
N	MODULE_ID_SOFTUART			= 137,		// SoftUART
N	MODULE_ID_VIRTUALCOM		= 139,		// VirtualCOM
N
N	// Graphics: Module ID					Module Name
N	MODULE_ID_GFXRESLDR			= 140,		// GraphicsResLoader
N	MODULE_ID_GFXLIB			= 141,		// GraphicsLib
N	MODULE_ID_IMGPROC			= 142,		// ImageProcess
N	MODULE_ID_GIFDEC			= 143,		// GIFDecoder
N	MODULE_ID_JPEG				= 144,		// JPEGCodec
N	MODULE_ID_PNGDEC			= 146,		// PNGCodec
N	MODULE_ID_BARCODE2D			= 148,		// BarCode2D	
N	MODULE_ID_PTNRECOG			= 150,		// PtnRecog
N	MODULE_ID_MOTIONDET			= 152,		// MotionDection
N	
N	// Storage: Module ID					Module Name
N	MODULE_ID_STORIF			= 160,		// StorageInterface
N	MODULE_ID_SDCARD			= 161,		// SDCard
N	MODULE_ID_SYSNAND			= 162,		// SysNand
N	MODULE_ID_SPIFLASH			= 163,		// SPIFlash
N	MODULE_ID_WTRIF				= 164,		// WriterInterface
N	MODULE_ID_NORFLASH			= 165,		// NORFlash
N	MODULE_ID_SYSNANDLITE		= 166,		// SysNandLite
N	MODULE_ID_XTRAROM			= 167,		// XtraROM
N	MODULE_ID_NOR				= 169,		// NOR
N	MODULE_ID_W55F					= 156,		// W55F
N	MODULE_ID_SYSNAND512		= 157,		// SysNand512
N	MODULE_ID_SYSNANDLITE512	= 158,		// SysNandLite512
N	MODULE_ID_SYSNANDOTP		= 159,		// SysNandOTP
N	
N	// System: Module ID					Module Name
N	MODULE_ID_INTMGR			= 180,		// InterruptManager
N	MODULE_ID_BLKLDR			= 181,		// BlockLoader
N	MODULE_ID_MEMMGR			= 182,		// MemoryManager
N	MODULE_ID_EVTMGR			= 183,		// EventManager
N	MODULE_ID_PROF				= 184,		// Profiling
N	MODULE_ID_PROGLDR			= 186,		// ProgramLoader
N	MODULE_ID_SYSINFRA			= 188,		// SysInfra
N	MODULE_ID_TIMERCTRL			= 190,		// TimerCtrl
N	MODULE_ID_TIMEUTIL			= 192,		// TimeUtil
N	MODULE_ID_CONPROGLDR		= 194,		// ConsoleProgramLoader
N	MODULE_ID_IXML				= 185,		// IXML
N	
N	// USB: Module ID						Module Name
N	MODULE_ID_USBCOREH			= 78,		// USBCoreH
N	MODULE_ID_HID				= 220,		// HID
N	MODULE_ID_MASSSTOR			= 222,		// MassStor
N	MODULE_ID_MASSSTORHID		= 224,		// MassStorHID
N	MODULE_ID_MASSSTORLITE		= 226,		// MassStorLite
N	MODULE_ID_MTP				= 230,		// MTP
N	MODULE_ID_USBINFRA			= 232,		// USBInfra
N	MODULE_ID_UAC				= 234,		// UAC
N	MODULE_ID_UAVC				= 236,		// UAVC
N	MODULE_ID_UVC				= 238,		// UVC
N	MODULE_ID_MASSSTORH			= 252,		// MassStorH
N	MODULE_ID_HIDH				= 254,		// HIDH
N
N	// Security: Module ID					Module Name
N	MODULE_ID_MSDRMPD			= 228,		// MsDrmPd
N	
N	// Video: Module ID						Module Name
N	MODULE_ID_AVICODEC			= 240,		// AVICodec
N	MODULE_ID_MJPEG				= 242,		// MJpegCodec
N	MODULE_ID_WIVICORE			= 244,		// WiViCore
N	MODULE_ID_WIVI				= 246,		// WiViDec	
N	MODULE_ID_AVCTRL			= 248,		// AVControl
N	MODULE_ID_AVIUTIL			= 250,		// AVIUtility
N	
N	// Wireless Toy							Module Name
N	MODULE_ID_WTCHAN			= 168,		// WTChannel
N	MODULE_ID_WTCMDSERV			= 170,		// WTCMDService
N	MODULE_ID_WTDISPLAY			= 172,		// WTDisplay
N	MODULE_ID_WTMEDIA			= 174,		// WTMedia
N	MODULE_ID_WTSYS				= 176,		// WTSystem
N	MODULE_ID_WTTRANS			= 178,		// WTTransport
N	
N	// Wireless Toy - RF					Module Name
N	MODULE_ID_WTRFCHAN			= 171,		// WTRFChannel
N	MODULE_ID_WTRFCMDSERV		= 173,		// WTRFCMDService
N	MODULE_ID_WTRFMEDIA			= 175,		// WTRFMedia
N	MODULE_ID_WTRFSYS			= 177,		// WTRFSystem
N	MODULE_ID_WTRFTRANS			= 179		// WTRFTransport
N
N	// Module ID valid range: 0 ~ 255	
N} E_SYSINFRA_MODULE_ID;
N
N
N#endif /* __MODULE_ID_H__ */
L 13 "..\..\..\..\Library\Framework\inc\SysInfra.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N// #define Constant
N#define SYSINFRA_MAJOR_NUM		1
N#define SYSINFRA_MINOR_NUM		00
N#define SYSINFRA_BUILD_NUM		001
N
N// Define a module version composed of major number, minor number, and build number.
N#define _SYSINFRA_VERSION(MAJOR_NUM, MINOR_NUM, BUILD_NUM)          (((MAJOR_NUM) << 16) | ((MINOR_NUM) << 8) | (BUILD_NUM))
N
N// Define an error code composed of error bit, module ID, and error ID.
N#define _SYSINFRA_ERRCODE(IS_ERROR, MODULE_ID_VALUE, ERROR_ID)		((ERROR_ID) & 0xFF)
N
N// Define module version number.
N#define SYSINFRA_VERSION_NUM	_SYSINFRA_VERSION(SYSINFRA_MAJOR_NUM, SYSINFRA_MINOR_NUM, SYSINFRA_BUILD_NUM)
N
N#define E_SUCCESS			0
N#define S_OK				E_SUCCESS
N
N// APIs declaration
NUINT32 
NSysInfra_GetVersion (void);
N
NUINT32
NSysInfra_CountLeadingZero (
N	UINT32 u32Val
N);
N
Nstatic __inline UINT32
NSysInfra_CountLeadingOne (
N	UINT32 u32Val
N)
N{
N    return SysInfra_CountLeadingZero (~u32Val);
N}
N
NUINT32
NSysInfra_CountTrailingZero (
N	UINT32 u32Val
N);
N
Nstatic __inline UINT32
NSysInfra_CountTrailingOne (
N	UINT32 u32Val
N)
N{
N	return SysInfra_CountTrailingZero (~u32Val);
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // __SYSINFRA_H__
N
N
N
L 13 "..\..\..\..\Library\Storage\inc\SPIFlash.h" 2
N
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N// Version number
N#define SPIFLASH_MAJOR_NUM	5
N#define SPIFLASH_MINOR_NUM	0
N#define SPIFLASH_BUILD_NUM	0
N#define SPIFLASH_VERSION_NUM	_SYSINFRA_VERSION(SPIFLASH_MAJOR_NUM, SPIFLASH_MINOR_NUM, SPIFLASH_BUILD_NUM)
N
N// ------------------------------------------------------------------------------
N// Define the Error Code
N// ------------------------------------------------------------------------------
N// E_SPIFLASH_BUSY				Read/Write Data Busy
N#define E_SPIFLASH_BUSY         _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SPIFLASH, 1)
N
N// SPI Flash Status1
N#define SPIFLASH_SPR			0x80	// Status Register Protect
N#define SPIFLASH_R				0x40	// Reserved Bit
N#define SPIFLASH_BP3     		0x20	// Block Protect Bit 3
N#define SPIFLASH_BP2			0x10	// Block Protect Bit 2
N#define SPIFLASH_BP1			0x08	// Block Protect Bit 1
N#define SPIFLASH_BP0			0x04	// Block Protect Bit 0
N#define SPIFLASH_WEL			0x02	// Write Enable Latch
N#define SPIFLASH_BUSY			0x01	// BUSY
N#define SPIFLASH_BP				(SPIFLASH_BP3|SPIFLASH_BP2|SPIFLASH_BP1|SPIFLASH_BP0)
N
N// SPI Flash Command
N#define SPIFLASH_ZERO			0x00
N#define SPIFLASH_DUMMY			0xFF
N#define SPIFLASH_WRITE_ENABLE	0x06
N#define SPIFLASH_WRITE_DISABLE	0x04
N#define SPIFLASH_READ_STATUS	0x05
N#define SPIFLASH_WRITE_STATUS	0x01
N#define SPIFLASH_READ_DATA		0x03 // Using fast read to replace normal read
N#define SPIFLASH_FAST_READ		0x0B
N#define SPIFLASH_FAST_RD_DUAL	0x3B
N#define SPIFLASH_PAGE_PROGRAM	0x02
N#define SPIFLASH_QPAGE_PROGRAM  0x32
N#define SPIFLASH_64K_ERASE		0xD8
N#define SPIFLASH_4K_ERASE		0x20
N#define SPIFLASH_32K_ERASE		0x52
N#define SPIFLASH_SUSPEND_EP		0x75
N#define SPIFLASH_RESUME_EP		0x7A
N#define SPIFLASH_CHIP_ERASE		0xC7
N#define SPIFLASH_POWER_DOWN		0xB9
N#define SPIFLASH_RELEASE_PD_ID	0xAB
N#define SPIFLASH_DEVICE_ID		0x90
N#define SPIFLASH_JEDEC_ID		0x9F
N
N#define SPIFLASH_PAGE_SIZE	256
N
N#define SPIFLASH_FLAG_ERASE_64K			0x01
N#define SPIFLASH_FLAG_ERASE_4K			0x02
N#define SPIFLASH_FLAG_ERASE_32K			0x04
N#define SPIFLASH_FLAG_DUAL_SPI			0x08
N#define SPIFLASH_FLAG_QUAD_SPI			0x09
N#define SPIFLASH_FLAG_WINBOND			0x10
N#define SPIFLASH_FLAG_MXIC				0x20
N#define SPIFLASH_FLAG_ATMEL				0x40
N
Ntypedef struct
N{
N	SPI_T   *psSpiHandler;				// SPI access handler
N	UINT32  u32FlashSize;				// SPIFlash memory size
N	UINT8   u8SlaveDevice;              // SPIFlash is on device1/2
N	UINT8   u8Flag;
N} S_SPIFLASH_HANDLER;
N
Ntypedef enum
N{
N	eSTATUS_REG1 = 0x00,
N	eSTATUS_REG2 = 0x30
N} E_SPIFLASH_STATUS_REGISTER;
N
N// APIs declaration
N
N
N/*******************************************************************/
N/*             Write API declaration                               */
N/*******************************************************************/
Nvoid
NSPIFlash_Write(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32Addr,
N	PUINT8 pau8Data,
N	UINT32 u32DataLen
N);
N
Nvoid
NSPIFlash_WritePage(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32PageAddr,
N	PUINT8 pau8Data
N);
N
Nvoid
NSPIFlash_WriteStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32ByteAddr
N);
N
Nvoid
NSPIFlash_WriteEnd(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
NUINT32
NSPIFlash_WriteData(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32SPIAddr,
N	PUINT8 pau8Data,
N	UINT32 u32DataLen
N);
N
Nvoid
NSPIFlash_WriteDataAlign(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	PUINT8 pau8Data
N);
N
N/*******************************************************************/
N/*             Read API declaration                                */
N/*******************************************************************/
Nvoid
NSPIFlash_Read(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32ByteAddr,
N	PUINT8 pau8Data,
N	UINT32 u32DataLen
N);
N
Nvoid
NSPIFlash_BurstRead(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32ByteAddr,
N	PUINT8 pau8Data,
N	UINT32 u32DataLen
N);
N
Nvoid
NSPIFlash_ReadStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32ByteAddr
N);
N
Nvoid
NSPIFlash_ReadEnd(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
Nvoid
NSPIFlash_ReadData(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	PUINT8 pau8Data,
N	UINT32 u32DataLen
N);
N
Nvoid
NSPIFlash_ReadDataAlign(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	PUINT8 pau8Data,
N	UINT32 u32DataLen
N);
N
N/*******************************************************************/
N/*             Erase API declaration                               */
N/*******************************************************************/
Nvoid
NSPIFlash_Erase(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32CmdAddr,
N	UINT32 u32AddIncreament,
N	UINT16 u16EraseCount
N);
N
Nstatic __inline
Nvoid
NSPIFlash_Erase64K(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT8  u8IndexOf64K,
N	UINT16 u16EraseCount
N)
N{
N	SPIFlash_Erase(psSpiFlashHandler, ((UINT32)SPIFLASH_64K_ERASE<<24)|(u8IndexOf64K<<16), (1<<16), u16EraseCount );
X	SPIFlash_Erase(psSpiFlashHandler, ((UINT32)0xD8<<24)|(u8IndexOf64K<<16), (1<<16), u16EraseCount );
N}
N
Nstatic __inline
Nvoid
NSPIFlash_Erase4K(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT16 u16IndexOf4K,
N	UINT16 u16EraseCount
N)
N{
N	SPIFlash_Erase(psSpiFlashHandler, (SPIFLASH_4K_ERASE<<24)|(u16IndexOf4K<<12), (1<<12), u16EraseCount );
X	SPIFlash_Erase(psSpiFlashHandler, (0x20<<24)|(u16IndexOf4K<<12), (1<<12), u16EraseCount );
N}
N
Nstatic __inline
Nvoid
NSPIFlash_Erase32K(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT16 u16IndexOf32K,
N	UINT16 u16EraseCount
N)
N{
N	SPIFlash_Erase(psSpiFlashHandler, (SPIFLASH_32K_ERASE<<24)|(u16IndexOf32K<<15), (1<<15), u16EraseCount );
X	SPIFlash_Erase(psSpiFlashHandler, (0x52<<24)|(u16IndexOf32K<<15), (1<<15), u16EraseCount );
N}
N
Nvoid
NSPIFlash_EraseChip(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
N// none blocking releate APIs
Nvoid
NSPIFlash_EraseStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32CmdAddr
N);
N
Nstatic __inline
Nvoid
NSPIFlash_Erase64KStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT8  u8IndexOf64K
N)
N{
N	SPIFlash_EraseStart(psSpiFlashHandler, ((UINT32)SPIFLASH_64K_ERASE<<24)|(u8IndexOf64K<<16));
X	SPIFlash_EraseStart(psSpiFlashHandler, ((UINT32)0xD8<<24)|(u8IndexOf64K<<16));
N}
N
Nstatic __inline
Nvoid
NSPIFlash_Erase4KStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT16 u16IndexOf4K
N)
N{
N	SPIFlash_EraseStart(psSpiFlashHandler, (SPIFLASH_4K_ERASE<<24)|(u16IndexOf4K<<12));
X	SPIFlash_EraseStart(psSpiFlashHandler, (0x20<<24)|(u16IndexOf4K<<12));
N}
N
Nstatic __inline
Nvoid
NSPIFlash_Erase32KStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT16 u16IndexOf32K
N)
N{
N	SPIFlash_EraseStart(psSpiFlashHandler, (SPIFLASH_32K_ERASE<<24)|(u16IndexOf32K<<15) );
X	SPIFlash_EraseStart(psSpiFlashHandler, (0x52<<24)|(u16IndexOf32K<<15) );
N}
N
Nvoid
NSPIFlash_EraseChipStart(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
N/*******************************************************************/
N/*             Protection API declaration                          */
N/*******************************************************************/
Nvoid
NSPIFlash_ChipWriteEnable(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	BOOL bEnableWrite
N);
N
Nvoid
NSPIFlash_GlobalProtect(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	BOOL bEnableGlobalProtect
N);
N
N/*******************************************************************/
N/*             Miscellaneous API declaration                       */
N/*******************************************************************/
Nvoid
NSPIFlash_Open(
N	SPI_T *psSpiHandler,
N	UINT8 u8DrvSlaveDevice,
N	UINT32 u32SpiClk,
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
Nstatic __inline
Nvoid
NSPIFlash_Close(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N)
N{
N	SPI_Close(psSpiFlashHandler->psSpiHandler);
N}
N
Nstatic __inline
NUINT32
NSPIFlash_GetSPIClock(
N   S_SPIFLASH_HANDLER *psSpiFlashHandler
N)
N{
N	return SPI_GetBusClock(psSpiFlashHandler->psSpiHandler);
N}
N
Nvoid
NSPIFlash_SendRecOneData(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT32 u32Data,
N	UINT8  u8DataLen
N);
N
Nvoid
NSPIFlash_GetChipInfo(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
NUINT8
NSPIFlash_ReadStatusReg(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	E_SPIFLASH_STATUS_REGISTER eStatusReg
N);
N
Nvoid
NSPIFlash_WriteStatusReg(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	UINT8 u8Status
N);
N
Nvoid
NSPIFlash_PowerDown(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler,
N	BOOL	bEnable
N);
N
Nvoid
NSPIFlash_WaitReady(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
NBOOL
NSPIFlash_CheckBusy(
N	S_SPIFLASH_HANDLER *psSpiFlashHandler
N);
N
NUINT32
NSPIFlash_GetVersion(void);
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif	// __SPIFLASH_H__
N
L 14 "..\ConfigApp.h" 2
N// -------------------------------------------------------------------------------------------------------------------------------
N// ADC Enable Options 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define ADC_ENABLE	 				(1)			// 1:enable ADC, 0:disable ADC
N#define ADC_FILTER_ENABLE			(0)			// 0: disable, 1:enable SW NuADC low pass filter, 2:enable HW biquad filter,
N#define ADC_PDMA_ENABLE				(1)			// 1:enable HW PDMA to handle adc input data, 0: Software scheme
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// APU Enable Options 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define APU_ENABLE					(1)			// 1:enable APU, 0:disable APU	
N#define APU_FILTER_ENABLE			(2)			// 0: disable, 1:enable SW NuDAC low pass filter, 2:enable HW biquad filter,
N#define APU_PDMA_ENABLE 			(1)			// 1:enable HW PDMA to handle dpwm input data, 0: Software scheme	
N#define PLAYBACK_CHANNEL_COUNT		(1)			// define the max playback channel(1, 2, 3 )
N#define PLAYBACK_CHANNEL_NONE		0xff		// define the channel whill will not in playback
N#define PLAYBACK_VOLUME_CONTROL		(1)			// 1:enable volume control, 0:disable volume control	
N//#define PLAYBACK_SAME_SAMPLERATE	// Define playback channels are the same sample rate.	
N//#define AUDIOMIXER_DUPLICATE		// Define    to enable mixer to duplicate   samples to mix channels different sample rate							
N									// Undefine  to enable mixer to interpolate samples to mix channels different sample rate							
N										
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// PDMA Enable Options 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define PDMA_ENABLE					(APU_PDMA_ENABLE|ADC_PDMA_ENABLE)
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// SPIFLash Enable Options 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define SPIFLASH_SPI0_DEVICE1
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// Powerdown/Wakeup Enable Options 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define WAKEUP_GPIO_TRIGGER			(1)		// Use GPIO to wake up chip
N#define WAKEUP_RTC_TRIGGER			(0)		// Use RTC timer to wake up chip
N#define WAKEUP_WDT_TRIGGER			(0)		// Use watch dog to wake up chip
N
N#define WAKEUP_GPIO_TRG_PA			(0)		// GPIO trigger for GPIO A
N#define WAKEUP_GPIO_TRG_PB			(BIT3)	// GPIO trigger for GPIO B	
N
N#define WAKEUP_RTC_TRG_TIME_YEAR	(0)		// RTC wake-up time(year)
N#define	WAKEUP_RTC_TRG_TIME_MONTH	(0)		// RTC wake-up time(month)
N#define WAKEUP_RTC_TRG_TIME_DAY		(0)		// RTC wake-up time(day)
N#define WAKEUP_RTC_TRG_TIME_HOUR	(0)		// RTC wake-up time(hour)
N#define WAKEUP_RTC_TRG_TIME_MINUTE	(0)		// RTC wake-up time(minute)
N#define WAKEUP_RTC_TRG_TIME_SECOND	(0)		// RTC wake-up time(second)
N
N#define WAKEUP_WDT_TRG_TIMEOUT		(WDT_TIMEOUT_2POW4) 	// WDT wake-up time.
N
N// Any wake-up trigger enable will enable power-down process, or disable.
N#define POWERDOWN_ENABLE			(WAKEUP_GPIO_TRIGGER|WAKEUP_RTC_TRIGGER|WAKEUP_WDT_TRIGGER)				
N
N// -------------------------------------------------------------------------------------------------
N// Input and Output key configurations.
N// Reference "ConfigIOPin.h" for detail configurations.
N// -------------------------------------------------------------------------------------------------
N#define CONFIG_MATRIX_KEY			(0)		// 1: enable matrix key, 0: disable matrix key
N#define CONFIG_TRIGGER_KEY			(1)		// 1: enable trigger key, 0: disable trigger key
N#define CONFIG_OUTPUT_PIN			(1)		// 1: enable output key, 0: disable output key
N#define CONFIG_INPUT_STATE			(1)		// 1: enable input  state, 0: disable input  state
N#define CONFIG_OUTPUT_STATE			(0)		// 1: enable output state, 0: disable output state
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// UltraIO Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define ULTRAIO_FW_CURVE_ENABLE		(0)		// 1:enable UltrIO enable firmware pwm curve, 0:disable UltrIO enable firmware pwm curve
N#define ULTRAIO_HW_CURVE_ENABLE		(0)		// 1:enable UltrIO enable hardware pwm curve, 0:disable UltrIO enable hardware pwm curve
N#define ULTRAIO_FW_TMR				(1)		// 1:Set TIMER1 is used for FW pwm, 2:Set TIMER2 is used for FW pwm
N
N#define ULTRAIO_USE_STRUCTURE		(0)		// 1:setting info. load from config structure, 0:setting info. use ConfigUltraIO.h
N
N
N#if ((ADC_FILTER_ENABLE == 2) && (APU_FILTER_ENABLE == 2))
X#if (((0) == 2) && ((2) == 2))
S#error "HW biquad filter only supports alternative path for ADC or DPWM!"
N#endif 	
N//%{CodeGen_Block_End}
N
N#define CONFIG_TOUCH_KEY			(0)		// 1: enable touch key, 0: disable touch key
N
N#endif //#ifndef __CONFIGAPP_H__
N
L 10 "..\App.h" 2
N#include "Framework.h"
L 1 "..\..\..\..\Library\Framework\inc\Framework.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                              */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef _FRAMEWORK_H_
N#define _FRAMEWORK_H_
N
N#include "Platform.h"
N#include "ConfigApp.h"
N
N// Key configuration
N#if ((CONFIG_MATRIX_KEY>0) || (CONFIG_TRIGGER_KEY>0) || (CONFIG_TOUCH_KEY>0) )
X#if (((0)>0) || ((1)>0) || ((0)>0) )
N	#include "Keypad.h"
L 1 "..\..\..\..\Library\IO\inc\Keypad.h" 1
N/**************************************************************************//**
N * @file     Keypad.h
N * @version  V2.00
N * $Revision: 2 $
N * $Date: 14/09/16 02:05p $
N * @brief    Keypad(include Direct,Matrix and Touch Key) via GPIO interface to control. 
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __KEYPAD_H__
N#define __KEYPAD_H__
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup LIBRARY_IO Input/Output Library
N  @{
N*/
N
N/** @addtogroup LIBRARY_IO_KEYPAD Keypad Library
N  @{
N*/
N
N/** @addtogroup LIBRARY_IO_KEYPAD_EXPORTED_CONSTANTS Keypad Library Exported Constants
N  @{
N*/
N	
N#define KEYPAD_GPIOA	           (0)                  /*!< GPIOA defined for Keyoad Handler \hideinitializer */
N#define KEYPAD_GPIOB	           (1)                  /*!< GPIOB defined for Keyoad Handler \hideinitializer */
N
N#define KEYPAD_FALLING	           (0)                  /*!< Key falling state \hideinitializer */
N#define KEYPAD_RISING	           (1)                  /*!< Key rising state \hideinitializer */
N#define KEYPAD_PRESSING            (2)                  /*!< Key pressing state \hideinitializer */
N
Ntypedef void (*PFN_KEYPAD_CALLBACK)(uint32_t u32Param); /*!< Keypad callback function defined \hideinitializer */
N
N// Direct trigger event handler
Ntypedef struct 
N{
N	PFN_KEYPAD_CALLBACK	m_pfnTgr_Callback;		// callback function of event handler. NULL: end of handler array
N	uint32_t	        m_u32Param;			    // parameter that will be passed to handler
N	uint16_t            m_u16Pin;				// Pin bit mask	direct trigger input
N	uint8_t             m_u8Port;				// GPIO Port. 0: GPIOA, 1: GPIOB
N	uint8_t             m_u8Mode;				// 0: falling, 1: rising, 2: pressing
N} S_KEYPAD_TGR_HANDLER;
N
N// Key matrix event handler
Ntypedef struct 
N{
N	PFN_KEYPAD_CALLBACK	m_pfnKey_Callback;		// callback function of event handler. NULL: end of handler array
N	uint32_t            m_u32Param;				// parameter that will be passed to handler
N	uint16_t            m_u16Pin_I;             // Pin bit mask of key matrix input
N	uint16_t            m_u16Pin_O;			    // Pin bit mask of key matrix output
N	uint8_t             m_u8Port_I;             // input GPIO port. 0: GPIOA, 1: GPIOB
N	uint8_t	            m_u8Port_O;             // Output GPIO port. 0: GPIOA, 1: GPIOB
N	uint8_t             m_u8Mode;               // 0: falling, 1: rising, 2: pressing
N} S_KEYPAD_KEY_HANDLER;
N
Ntypedef struct 
N{
N	uint16_t 			m_u16Press;				// Pressing threshold.
N	uint16_t			m_u16Release;			// Release threshold.
N}S_KEYPAD_TOUCH_THRESHOLD;
N
N// Touch key event handler
Ntypedef struct 
N{
N	PFN_KEYPAD_CALLBACK	m_pfnTouch_Callback;	// callback function of event handler. NULL: end of handler array
N	uint32_t	        m_u32Param;			    // parameter that will be passed to handler
N	uint16_t            m_u16Pin;				// Pin bit touch key input
N	uint8_t             m_u8Mode;				// 0: falling, 1: rising, 2: pressing
N} S_KEYPAD_TOUCH_HANDLER;
N
N/*@}*/ /* end of group LIBRARY_IO_KEYPAD_EXPORTED_CONSTANTS */
N
N/** @addtogroup LIBRARY_IO_KEYPAD_EXPORTED_FUNCTIONS Keypad Exported Functions
N  @{
N*/
N
N/**
N  * @brief  1. Initial keypad.
N  *         2. Set Debounce and pressing events interval count.
N  *         3. Time unit is decided by application.
N  *         4. Application should initiated a timer to call ScanKeypad() periodically.
N  * @param  u16DebounceCount is the debounce count for change pin status.
N  * @param  u16PressingCount is the interval count between 2 pressing events.
N  * @return None
N  */
Nvoid Keypad_InitKeypad( uint16_t u16DebounceCount, uint16_t u16PressingCount );
N
N/**
N  * @brief  1. Initiate direct trigger pins.
N  *         2. Set trigger event handlers.
N  * @param  u16PinMaskA is the mask of PGIOA to be input pins.
N  * @param  u16PinMaskB is the mask of PGIOB to be input pins.
N  * @param  psTgrHandler is the direct trigger event handler array.
N  */
Nvoid Keypad_InitTgr(uint16_t u16PinMaskA,uint16_t u16PinMaskB,const S_KEYPAD_TGR_HANDLER* psTgrHandler);
N
N/**
N  * @brief  Reset static variable for trigger key.
N  */
Nvoid Keypad_ResetTgr(void);
N
N/**
N  * @brief  1.This function scan GPIOA or GPIOB pins for direct trigger operation.
N  *         2.It calls event handler if Debounce is timer up.
N  * @note   1.This API can be called anywhere to scan trigger status, 
N  *           and should be called timely to prevent status loss.
N  *         2.But should be careful to call it in ISR to prevent block other ISR 
N  *           if event handler will take too much CPU time
N  * @return 0: trigger event does not happen or event handler is called,
N  *         1: event happen but handler is not found.
N  */
Nuint8_t Keypad_ScanTgr(void);
N
N/**
N  * @brief  This API is called in timer interrupt to decrease Debounce counter periodically.
N  * @return 1: Decrease Debounce counter (in Debounce), 
N  *         0: not decrease Debounce counter (not in Debounce).
N  */
Nuint8_t Keypad_TgrDecDebounceCounter(void);
N
N/**
N  * @brief  Initial key matix pins, and event handlers.
N  * @param  u16InPinMaskA is the mask of GPIOA to be input pins of key matrix.
N  * @param  u16InPinMaskB is the mask of GPIOB to be input pins of key matrix.
N  * @param  u16OutPinMaskA is the mask of GPIOA to be output pins of key matrix.
N  * @param  u16OutPinMaskB is the mask of GPIOB to be output pins of key matrix.
N  * @param  psKeyHandler is the matrix key event handler array.
N  * @param  pu16KeyPinValueBuf is to provided an array to be pin value buffer by application.
N  *         Array size is "output pin number".
N  *         This buffer must exist as keypad scaning.
N  */
Nvoid Keypad_InitKey(uint16_t u16InPinMaskA,uint16_t u16InPinMaskB,uint16_t u16OutPinMaskA,uint16_t u16OutPinMaskB,
N                    const S_KEYPAD_KEY_HANDLER* psKeyHandler,uint16_t* pu16KeyPinValueBuf);
N
N/**
N  * @brief  Reset static variable for matrix key.
N  */
Nvoid Keypad_ResetKey(void);
N
N/**
N  * @brief  1.This function scan GPIOA or GPIOB pins for matrix key operation.
N  *         2.It calls event handler if Debounce is timer up.
N  * @note   1.This API can be called anywhere to scan key matrix status, 
N  *           and should be called timely to prevent status loss.
N  *         2.But should be careful to call it in ISR to prevent block other ISR 
N  *           if event handler will take too much CPU time
N  * @return 0: key event does not happen or event handler is called,
N  *         1: event happen but handler is not found.
N  */
Nuint8_t Keypad_ScanKey(void);
N
N/**
N  * @brief  This API is called in timer interrupt to decrease Debounce counter periodically.
N  * @return 1: Decrease Debounce counter (in Debounce), 
N  *         0: not decrease Debounce counter (not in Debounce).
N  */
Nuint8_t Keypad_KeyDecDebounceCounter(void);
N
N/**
N  * @brief  Initial touch key pins, and event handlers.
N  * @param  u16Pin is the mask of capture pin index to be input pins of key touch.
N  * @param  psTouchHandler is the touch key event handler array.
N  * @param  pu16TouchPinValueBuf is to provided an array to be event value buffer by application.
N  */
Nvoid Keypad_InitTouch( uint16_t u16Pin, 
N					   const S_KEYPAD_TOUCH_THRESHOLD* psThreshold, 
N					   const S_KEYPAD_TOUCH_HANDLER* psTouchHandler, 
N					   uint16_t* pu16TouchPinValueBuf );
N
N/**
N  * @brief  This function calls event handler if Debounce is timer up.
N  * @note   1.This API can be called anywhere to scan key touch status, 
N  *           and should be called timely to prevent status loss.
N  *         2.But should be careful to call it in ISR to prevent block other ISR 
N  *           if event handler will take too much CPU time
N  * @return 0: key event does not happen or event handler is called,
N  *         1: event happen but handler is not found.
N  */
Nuint8_t Keypad_ScanTouch(void);
N
N/**
N  * @brief  1.This function scan capture pins for touch key operation.
N			2.It tags "capture flag" for activing "Keypad_ScanTouch".
N  * @note   This API should put into irq handler(ex. CAPS_IRQHandler)
N  *         and should be called timely to prevent status loss.
N  */
Nvoid Keypad_TouchCapSense(void);
N
N/**
N  * @brief  This API is counting press counter for pressing status.
N  */
Nvoid Keypad_KeyTouchPressCounter(void);
N
N/*@}*/ /* end of group LIBRARY_IO_KEYPAD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group LIBRARY_IO_KEYPAD */
N
N/*@}*/ /* end of group LIBRARY_IO */
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif
L 15 "..\..\..\..\Library\Framework\inc\Framework.h" 2
N
N	extern void InputKey_Initiate(void);
N	#define KEYPAD_INITIATE()			InputKey_Initiate()
N#else
S	#define KEYPAD_INITIATE()	
N#endif	//((_CONFIG_MATRIX_KEY_>0) || (_CONFIG_INPUT_KEY_>0))
N
N#if (CONFIG_MATRIX_KEY>0)
X#if ((0)>0)
S	#define MATRIX_KEY_CHECK() 		Keypad_ScanKey()
S	#define MATRIX_KEY_DEBOUNCE()	Keypad_KeyDecDebounceCounter()
S	#define MATRIX_KEY_RESET()		Keypad_ResetKey()
N#else
N	#define MATRIX_KEY_CHECK()
N	#define MATRIX_KEY_DEBOUNCE()
N	#define MATRIX_KEY_RESET()
N#endif
N
N#if (CONFIG_TRIGGER_KEY>0)
X#if ((1)>0)
N	#define TRIGGER_KEY_CHECK() 		Keypad_ScanTgr()
N	#define TRIGGER_KEY_DEBOUNCE()	Keypad_TgrDecDebounceCounter()
N	#define TRIGGER_KEY_RESET()			Keypad_ResetTgr()	
N#else
S	#define TRIGGER_KEY_CHECK()
S	#define TRIGGER_KEY_DEBOUNCE()
S	#define TRIGGER_KEY_RESET()
N#endif
N
N#if ( defined(CONFIG_TOUCH_KEY) && CONFIG_TOUCH_KEY>0 )
X#if ( 1L && (0)>0 )
S	#define TOUCH_KEY_CHECK() 		Keypad_ScanTouch()
S	#define TOUCH_KEY_CAP()			Keypad_TouchCapSense()
S	#define TOUCH_KEY_PRESS_COUNT()	Keypad_KeyTouchPressCounter();		
N#else
N	#define TOUCH_KEY_CHECK()
N	#define TOUCH_KEY_CAP()
N	#define TOUCH_KEY_PRESS_COUNT()
N#endif
N
N// Output pin configuration
N#if (CONFIG_OUTPUT_PIN>0)	
X#if ((1)>0)	
N	extern void OutputPin_Initiate(void);	   
N	#define OUTPUTPIN_INITIATE() 				OutputPin_Initiate()
N#else
S	#define OUTPUTPIN_INITIATE()
N#endif  //(_CONFIG_OUTPUT_PIN_>0)
N
N// Input state configuration
N#if (CONFIG_INPUT_STATE > 0 )
X#if ((1) > 0 )
N	#include "InState.h"
L 1 "..\InState.h" 1
N/*------------------------------------------------------------------------------------------------*/
N/*                                                                                                */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                     */
N/*                                                                                                */
N/*------------------------------------------------------------------------------------------------*/
N
N#ifndef _INSTATE_H_
N#define _INSTATE_H_
N
N//%{CodeGen_Block_Start}
Nextern void InputKey_Change(UINT32 u32InStateIndex);
N
Nenum E_INSTATE
N{
N	E_Default = 0,	//1
N
N	E_INSTATE_END
N};
N
N#define Enable_Default	InputKey_Change(E_Default)
N
N//%{CodeGen_Block_End}
N#endif //_INSTATE_H_
L 63 "..\..\..\..\Library\Framework\inc\Framework.h" 2
N#endif
N
N// Output state configuration
N#if (CONFIG_OUTPUT_STATE > 0 )
X#if ((0) > 0 )
S	#include "IO/OutState.h"
N#endif
N
N// ----------------------------------------------------------------------------------------------
N// UltraIO configurations
N#if ( ULTRAIO_FW_CURVE_ENABLE || ULTRAIO_HW_CURVE_ENABLE )
X#if ( (0) || (0) )
S	#include "UltraIO.h"
S	#define ULTRAIO_INITIATE() 									UltraIO_Initiate() 
S	#define ULTRAIO_START() 									UltraIO_Start() 
S	#define ULTRAIO_STOP() 										UltraIO_Stop() 
S	#define ULTRAIO_EVENTHANDLER(u32CmdIndex, u32SubIndex)		UltraIO_EventHandler(u32CmdIndex, u32SubIndex)
N#else
N	#define ULTRAIO_INITIATE() 	
N	#define ULTRAIO_START()
N	#define ULTRAIO_STOP()	
N	#define ULTRAIO_EVENTHANDLER(u32CmdIndex, u32SubIndex)
N#endif
N 
N#if ( ULTRAIO_FW_CURVE_ENABLE ) 
X#if ( (0) ) 
S	#include "UltraIO.h"
S	#if ( ULTRAIO_FW_TMR == 2 )
S	#define ULTRAIO_OUTCURVETMR0()	
S	#define ULTRAIO_OUTCURVETMR1()
S	#define ULTRAIO_OUTCURVETMR2()		UltraIO_OuputCurve()
S	#elif (ULTRAIO_FW_TMR == 1)
S	#define ULTRAIO_OUTCURVETMR0()	
S	#define ULTRAIO_OUTCURVETMR1()		UltraIO_OuputCurve()
S	#define ULTRAIO_OUTCURVETMR2()
S	#elif (ULTRAIO_FW_TMR == 0)
S	#define ULTRAIO_OUTCURVETMR0()		UltraIO_OuputCurve()
S	#define ULTRAIO_OUTCURVETMR1()		
S	#define ULTRAIO_OUTCURVETMR2()
S	#endif
N#else 
N	#define ULTRAIO_OUTCURVETMR0()
N	#define ULTRAIO_OUTCURVETMR1()
N	#define ULTRAIO_OUTCURVETMR2()
N#endif
N
N// ----------------------------------------------------------------------------------------------
N
N// ----------------------------------------------------------------------------------------------
N// ADC configuration
N#if ( ADC_ENABLE )
X#if ( (1) )
N	extern void MIC_Open(void);
N	extern void MIC_Close(void);
N	#define MIC_INITIATE()		MIC_Open()
N	#define MIC_UNINITIATE()	MIC_Close()
N#else
S	#define MIC_INITIATE()
S	#define MIC_UNINITIATE()	
N#endif
N// ----------------------------------------------------------------------------------------------
N
N// ----------------------------------------------------------------------------------------------
N// APU configuration
N#if ( APU_ENABLE )
X#if ( (1) )
N	extern void SPK_Open(void);
N	extern void SPK_Close(void);
N	#define SPK_INITIATE()		SPK_Open()
N	#define SPK_UNINITIATE()	SPK_Close()
N#else
S	#define SPK_INITIATE()
S	#define SPK_UNINITIATE()	
N#endif
N// ----------------------------------------------------------------------------------------------
N
N// ----------------------------------------------------------------------------------------------
N// PDMA configuration
N#if ( PDMA_ENABLE )
X#if ( ((1)|(1)) )
N	#include "PdmaCtrl.h"
L 1 "..\..\..\..\Library\Framework\inc\PdmaCtrl.h" 1
N#ifndef _PDMACTRL_H_
N#define _PDMACTRL_H_
N
N#include "Platform.h"
N
N
Nvoid PdmaCtrl_Init(void);
N
Nvoid PdmaCtrl_Open(
N	UINT32 u32Ch,
N	UINT32 u32ServiceSel
N);
N
Nvoid PdmaCtrl_Start(
N	UINT32 u32Ch,
N	UINT32 *p32SrcAdd,
N	UINT32 *p32DesAdd,
N	UINT16 u16Count
N);
N
Nvoid PdmaCtrl_Stop(UINT32 u32Ch);
N
Nvoid PdmaCtrl_Close(UINT32 u32Ch);
N
Nvoid PdmaCtrl_UnInit(void);
N#endif
N
N
L 138 "..\..\..\..\Library\Framework\inc\Framework.h" 2
N	extern void PdmaCtrl_Init(void);
N	extern void PdmaCtrl_UnInit(void);
N	#define PDMA_INITIATE()		PdmaCtrl_Init()
N	#define PDMA_UNINITIATE()	PdmaCtrl_UnInit()
N#else
S	#define PDMA_INITIATE()
S	#define PDMA_UNINITIATE()	
N#endif
N
N// ----------------------------------------------------------------------------------------------
N
N// ----------------------------------------------------------------------------------------------
N#endif //_FRAMEWORK_H_
L 11 "..\App.h" 2
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// g_u8AppCtrl Bit Field Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define APPCTRL_NO_ACTION				0
N//#define APPCTRL_PLAY					BIT0 
N//#define APPCTRL_PLAY_STOP				BIT1
N//#define APPCTRL_RECORD					BIT2
N
N#define APPCTRL_PLAY					       BIT3
N#define APPCTRL_PLAY_STOP			 BIT1
N#define APPCTRL_RECORD					 BIT2
N
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// Application Related Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#include "NuOneExApp/NuOneExApp_Decode.h"
L 1 "..\NuOneExApp/NuOneExApp_Decode.h" 1
N#ifndef _CONFIGNUONEEXAPP_DECODE_H_
N#define _CONFIGNUONEEXAPP_DECODE_H_
N
N#include "ConfigApp.h"
N#include "NuOneEx.h"
L 1 "..\..\..\..\Library\Audio\inc\NuOneEx.h" 1
N/****************************************************************
N *                                                              *
N * Copyright (c) Nuvoton Technology Corp. All rights reserved.  *
N *                                                              *
N ****************************************************************/
N
N#ifndef __NUONEEX_H__
N#define __NUONEEX_H__
N   
N#include "Platform.h"
N#include "AudioCommon.h"
L 1 "..\..\..\..\Library\Audio\inc\AudioCommon.h" 1
N/****************************************************************
N *                                                              *
N * Copyright (c) Nuvoton Technology Corp. All rights reserved.  *
N *                                                              *
N ****************************************************************/
N#ifndef _AUDIOCOMMON_H_
N#define _AUDIOCOMMON_H_
N
N/******************************************************************************************
N	.ROM File Layout
N	+------------------------------+
N	| S_ROM_HEADER                 |
N	+------------------------------+ <------------------------------------------ S_ROM_HEADER.u32AudioStartAddr
N	| S_ROM_AUDIO_CHUNK_INFO       | -+
N	+------------------------------+  |
N	| S_ROM_AUDIO_CHUNK_INFO       |  +-> Audio Chunck Infomation Table: size = S_ROM_HEADER.u32TotalAudioNum*sizeof(S_ROM_AUDIO_CHUNK_INFO)
N	+------------------------------+  |   
N	| ...                          | -+
N	+------------------------------+ <------------------------------------------ Address: sizeof(S_ROM_HEADER)+ S_ROM_HEADER.u32TotalAudioNum*sizeof(S_ROM_AUDIO_CHUNK_INFO)
N	| S_ROM_SENTENCE_LIST_ADDR     | -+
N	+------------------------------+  |
N	| S_ROM_SENTENCE_LIST_ADDR     |  |
N	+------------------------------+  +-> Sentence List Information Table
N	| S_ROM_SENTENCE_LIST_ADDR     |  |
N	+------------------------------+  |
N	| ...                          | -+
N	+------------------------------+ <------------------------------------------ Address: S_ROM_HEADER.u32SentenceStartAddr
N	| S_ROM_SENTENCE_INFO          | -+
N	+------------------------------+  |
N	| S_ROM_SENTENCE_INFO          |  |
N	+------------------------------+  +-> Sentence Infomation Table
N	| 0xffff(End of Sentence List) |  |
N	+------------------------------+  |
N	| S_ROM_SENTENCE_INFO          |  |
N	+------------------------------+  |
N	| 0xffff(End of Sentence List) |  |
N	+------------------------------+  |
N	| S_ROM_SENTENCE_INFO          |  |
N	+------------------------------+  |
N	| ...                          |  |
N	+------------------------------+  |
N	| 0xffff(End of Sentence List) | -+
N	+------------------------------+ 
N	| Audio Chunck                 |
N	+------------------------------+
N	| Audio Chunck                 |
N	+------------------------------+
N	| ...                          |
N	+------------------------------+
N	| Audio Chunck                 |
N	+------------------------------+
N ******************************************************************************************/
N
N/******************************************************************************************
N	Audio Chunck Layout
N	(Also Audio File Layout)
N	+-----------------------------+
N	| S_AUDIO_CHUNK_HEADER        |
N	+-----------------------------+ -+
N	|                             |  |
N	|                             |  |
N	|                             |  |
N	|    Encoded Data             |  +-> size = S_AUDIO_CHUNK_HEADER.u32TotalSize
N	|                             |  |
N	|                             |  |
N	|                             |  |
N	|                             |  |
N	+-----------------------------+ -+
N ******************************************************************************************/
N
N/******************************************************************************************
N * Audio data format definitions
N ******************************************************************************************/
N//#define AUDIO_FMT_NUONE  		(0x0030)		// old NuOne
N//#define AUDIO_FMT_NUONE_E		(0x0031)		// old NuOne with event
N#define AUDIO_FMT_PCM16 		(0x0005)		// P16 with event
N#define AUDIO_FMT_MDPCM4 		(0x0007)		// MDM4 with event
N#define AUDIO_FMT_SILENCE		(0x000B)		// Silence
N#define AUDIO_FMT_LP8			(0x000E)		// LP8 with event
N#define AUDIO_FMT_NUSOUND		(0x002F)		// NuSound with event
N#define AUDIO_FMT_NUONE			(0x0040)		// NuOne without event
N#define AUDIO_FMT_NUONE_E 		(0x0041) 		// NuOne with event
N#define AUDIO_FMT_NULITE		(0x0050)		// NuLite without event
N#define AUDIO_FMT_NULITE_E		(0x0051)		// NuLite with event
N#define AUDIO_FMT_NUVOX			(0x0060)		// NuVox without event
N#define AUDIO_FMT_NUVOX_E		(0x0061)		// NuVox with event
N#define AUDIO_FMT_NUVOX53		(0x0070) 		// NuVox53 without event
N#define AUDIO_FMT_IMFMIDI		(0x0800)		// IMF-MIDI with event
N#define AUDIO_FMT_IMAADPCM		(0x0080)                // IMA ADPCM without event
N#define AUDIO_FMT_IMAADPCM_E	(0x0081)                // IMA ADPCM with event
N
N/******************************************************************************************
N * Description:
N * 	To describe each auido chunk header, except midi.
N ******************************************************************************************/ 
Ntypedef struct
N{  
N	UINT16	u16FormatType;						// Audio data format. 
N	UINT16	u16SmplRate;						// Audio sampling rate.	
N	UINT32	u32TotalSize;						// Audio total size not including this structure; unit is byte
N	union
N	{
N		UINT32	u32LoopAddr; 					// Store loop address if decode find loop event; it's unit is byte. 
N		UINT32	u32BitPerFrame;						// NuXXX codec bit rate setting information.
N	};
N}S_AUDIOCHUNK_HEADER;
N#define AUDIOCHUNK_HEADER_SIZE			sizeof(S_AUDIOCHUNK_HEADER)
N
Ntypedef struct
N{
N	UINT32 	u32TotalAudioNum;
N	UINT32 	u32TotalSentenceNum;
N	UINT32 	u32AudioStartAddr;
N	UINT32 	u32SentenceStartAddr;
N}S_ROM_HEADER;
N#define ROM_HEADER_SIZE				sizeof(S_ROM_HEADER)
N
Ntypedef struct
N{
N	UINT32	u32AudioChunkAddr;
N	UINT32	u32AudioChunkSize;
N}S_ROM_AUDIO_CHUNK_INFO;
N#define ROM_AUDIO_CHINK_INFO_SIZE	sizeof(S_ROM_AUDIO_CHUNK_INFO)
N
Ntypedef struct
N{
N	UINT16	u16FormatType;						// Audio data format. 
N	UINT16	u16SmplRate;						// Audio sampling rate.	
N	UINT32	u32AudioChunkAddr;					// Audio trunck start address
N	union
N	{
N		UINT32	u32AudioChunkSize;				// Audio trunck size   if u16FromatType != AUDIO_FMT_SILENCE 
N		UINT32	u32SilenceSampleCount;			// Silence sample count if u16FromatType == AUDIO_FMT_SILENCE
N	};
N	UINT16	u16Volume;
N	UINT16	u16Repeat;
N	UINT8	u8Channel;
N}S_ROM_SENTENCE_INFO;
N#define ROM_SENTENCE_INFO_SIZE				17
N#define ROM_SENTENCE_INFO_FORMAT_END		0xffff
N#define ROM_SENTENCE_INFO_FORMAT_FIELD_SIZE	2
N
N#define AUDIO_GET_STORAGE_INDEX(ID)	(((ID)&0xc00)>>12)
N#define AUDIO_GET_ID(ID)			((ID)&0x3ff)
N
Ntypedef struct
N{
N	UINT32	u32StartAddr;
N}S_ROM_SENTENCE_LIST_ADDR;
N
Ntypedef UINT32 (*PFN_AUDIO_DATAREQUEST)(void * pDesAddr, UINT32 u32Position, UINT32 u32ByteNum);
Ntypedef UINT32 (*PFN_AUDIO_USREVENT)(UINT16 u16EventIndex, UINT16 u16EventSubIndex);
N
Ntypedef UINT32 (*PFN_AUDIO_DECODEINITIATE)( UINT8 *pu8DecodeWorkBuf, UINT8 *pu8DecodeTempBuf,UINT32 u32StartAddr,
N	PFN_AUDIO_DATAREQUEST pfnReadDataCallback );
Ntypedef INT32 (*PFN_AUDIO_DECODEPROCESS)( UINT8 *pu8DecodeWorkBuf, UINT8 *pu8DecodeTempBuf, INT16 *pi16DecodedPcmBuf,
N	PFN_AUDIO_DATAREQUEST pfnReadDataCallback, PFN_AUDIO_USREVENT PFN_AUDIO_USREVENT);
N
Ntypedef BOOL (*PFN_AUDIO_DECODEISEND)(UINT8 *pu8DecodeWorkBuf);
N
N
N// Storage reading, User event, Wave table callback 
Ntypedef struct sAudioCallBack
N{
N	PFN_AUDIO_DATAREQUEST		pfnReadDataCallback;
N	PFN_AUDIO_DATAREQUEST		pfnWriteDataCallback;
N	PFN_AUDIO_USREVENT			pfnUserEventCallback;
N	PFN_AUDIO_DATAREQUEST		pfnReadMidiWavTableCallback;
N}S_AUDIO_CALLBACK;
N
N#endif
L 12 "..\..\..\..\Library\Audio\inc\NuOneEx.h" 2
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N// Version Definition
N#define NUONEEX_MAJOR_NUM   3
N#define NUONEEX_MINOR_NUM   30
N#define NUONEEX_BUILD_NUM   1
N//#define NUONEEX_VERSION_NUM   _SYSINFRA_VERSION(NUONEEX_MAJOR_NUM, NUONEEX_MINOR_NUM, NUONEEX_BUILD_NUM)
N
N// Constant Definition
N#define NUONEEX_DECODE_SAMPLE_PER_FRAME	     320 	// counts per frame after decoding
N#define NUONEEX_DECODE_WORK_BUF_SIZE		(198*2+4+2) // bytes
N#define NUONEEX_DECODE_TEMP_BUF_SIZE		(506*2)	// bytes
N
N#define NUONEEX_ENCODE_SAMPLE_PER_FRAME      320	// counts of PCMs per frame before encodeing
N#define NUONEEX_ENCODE_WORK_BUF_SIZE		(326*2+4)	// bytes
N#define NUONEEX_ENCODE_TEMP_BUF_SIZE		(551*2)	// bytes
N//#define NUONEEX_ENCODE_DATA_BUF_SIZE		120		// bytes
N
N
N#define NUONEEX_ENCODE_BIT_PER_FRAME(bps)	((NUONEEX_ENCODE_SAMPLE_PER_FRAME*bps)/10)	// total bits of one encoded frame
N#define NUONEEX_ENCODE_BYTE_PER_FRAME(bps)	 (NUONEEX_ENCODE_BIT_PER_FRAME(bps)>>3)	// total bytes of one encoded frame
N
Nenum eNuOneExEncodeBPS		// Bit Per Sample after encoding
N{
N	E_NUONEEX_ENCODE_BPS_05 = NUONEEX_ENCODE_BIT_PER_FRAME( 5),				// 0.5 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_05 = ((320*5)/10),				
N	E_NUONEEX_ENCODE_BPS_06 = NUONEEX_ENCODE_BIT_PER_FRAME( 6),				// 0.6 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_06 = ((320*6)/10),				
N	E_NUONEEX_ENCODE_BPS_07 = NUONEEX_ENCODE_BIT_PER_FRAME( 7),				// 0.7 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_07 = ((320*7)/10),				
N	E_NUONEEX_ENCODE_BPS_08 = NUONEEX_ENCODE_BIT_PER_FRAME( 8),				// 0.8 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_08 = ((320*8)/10),				
N	E_NUONEEX_ENCODE_BPS_09 = NUONEEX_ENCODE_BIT_PER_FRAME( 9),				// 0.9 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_09 = ((320*9)/10),				
N	E_NUONEEX_ENCODE_BPS_10 = NUONEEX_ENCODE_BIT_PER_FRAME(10),				// 1.0 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_10 = ((320*10)/10),				
N	E_NUONEEX_ENCODE_BPS_11 = NUONEEX_ENCODE_BIT_PER_FRAME(11),				// 1.1 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_11 = ((320*11)/10),				
N	E_NUONEEX_ENCODE_BPS_12 = NUONEEX_ENCODE_BIT_PER_FRAME(12),				// 1.2 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_12 = ((320*12)/10),				
N	E_NUONEEX_ENCODE_BPS_13 = NUONEEX_ENCODE_BIT_PER_FRAME(13),				// 1.3 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_13 = ((320*13)/10),				
N	E_NUONEEX_ENCODE_BPS_14 = NUONEEX_ENCODE_BIT_PER_FRAME(14),				// 1.4 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_14 = ((320*14)/10),				
N	E_NUONEEX_ENCODE_BPS_15 = NUONEEX_ENCODE_BIT_PER_FRAME(15),				// 1.5 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_15 = ((320*15)/10),				
N	E_NUONEEX_ENCODE_BPS_16 = NUONEEX_ENCODE_BIT_PER_FRAME(16),				// 1.6 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_16 = ((320*16)/10),				
N	E_NUONEEX_ENCODE_BPS_17 = NUONEEX_ENCODE_BIT_PER_FRAME(17),				// 1.7 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_17 = ((320*17)/10),				
N	E_NUONEEX_ENCODE_BPS_18 = NUONEEX_ENCODE_BIT_PER_FRAME(18),				// 1.8 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_18 = ((320*18)/10),				
N	E_NUONEEX_ENCODE_BPS_19 = NUONEEX_ENCODE_BIT_PER_FRAME(19),				// 1.9 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_19 = ((320*19)/10),				
N	E_NUONEEX_ENCODE_BPS_20 = NUONEEX_ENCODE_BIT_PER_FRAME(20),				// 2.0 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_20 = ((320*20)/10),				
N	E_NUONEEX_ENCODE_BPS_21 = NUONEEX_ENCODE_BIT_PER_FRAME(21),				// 2.1 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_21 = ((320*21)/10),				
N	E_NUONEEX_ENCODE_BPS_22 = NUONEEX_ENCODE_BIT_PER_FRAME(22),				// 2.2 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_22 = ((320*22)/10),				
N	E_NUONEEX_ENCODE_BPS_23 = NUONEEX_ENCODE_BIT_PER_FRAME(23),				// 2.3 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_23 = ((320*23)/10),				
N	E_NUONEEX_ENCODE_BPS_24 = NUONEEX_ENCODE_BIT_PER_FRAME(24),				// 2.4 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_24 = ((320*24)/10),				
N	E_NUONEEX_ENCODE_BPS_25 = NUONEEX_ENCODE_BIT_PER_FRAME(25),				// 2.5 bit per sample after encoding
X	E_NUONEEX_ENCODE_BPS_25 = ((320*25)/10),				
N};
N
Nenum eNuOneExEncodeDataSize	// The bytes of one encoded frame
N{
N	E_NUONEEX_ENCODE_BPS_05_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME( 5),	// The bytes of one encoded frame at 0.5 bit per sample
X	E_NUONEEX_ENCODE_BPS_05_DATASIZE = (((320*5)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_06_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME( 6),	// The bytes of one encoded frame at 0.6 bit per sample
X	E_NUONEEX_ENCODE_BPS_06_DATASIZE = (((320*6)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_07_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME( 7),	// The bytes of one encoded frame at 0.7 bit per sample
X	E_NUONEEX_ENCODE_BPS_07_DATASIZE = (((320*7)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_08_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME( 8),	// The bytes of one encoded frame at 0.8 bit per sample
X	E_NUONEEX_ENCODE_BPS_08_DATASIZE = (((320*8)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_09_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME( 9),	// The bytes of one encoded frame at 0.9 bit per sample
X	E_NUONEEX_ENCODE_BPS_09_DATASIZE = (((320*9)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_10_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(10),	// The bytes of one encoded frame at 1.0 bit per sample
X	E_NUONEEX_ENCODE_BPS_10_DATASIZE = (((320*10)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_11_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(11),	// The bytes of one encoded frame at 1.1 bit per sample
X	E_NUONEEX_ENCODE_BPS_11_DATASIZE = (((320*11)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_12_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(12),	// The bytes of one encoded frame at 1.2 bit per sample
X	E_NUONEEX_ENCODE_BPS_12_DATASIZE = (((320*12)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_13_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(13),	// The bytes of one encoded frame at 1.3 bit per sample
X	E_NUONEEX_ENCODE_BPS_13_DATASIZE = (((320*13)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_14_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(14),	// The bytes of one encoded frame at 1.4 bit per sample
X	E_NUONEEX_ENCODE_BPS_14_DATASIZE = (((320*14)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_15_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(15),	// The bytes of one encoded frame at 1.5 bit per sample
X	E_NUONEEX_ENCODE_BPS_15_DATASIZE = (((320*15)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_16_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(16),	// The bytes of one encoded frame at 1.6 bit per sample
X	E_NUONEEX_ENCODE_BPS_16_DATASIZE = (((320*16)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_17_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(17),	// The bytes of one encoded frame at 1.7 bit per sample
X	E_NUONEEX_ENCODE_BPS_17_DATASIZE = (((320*17)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_18_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(18),	// The bytes of one encoded frame at 1.8 bit per sample
X	E_NUONEEX_ENCODE_BPS_18_DATASIZE = (((320*18)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_19_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(19),	// The bytes of one encoded frame at 1.9 bit per sample
X	E_NUONEEX_ENCODE_BPS_19_DATASIZE = (((320*19)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_20_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(20),	// The bytes of one encoded frame at 2.0 bit per sample
X	E_NUONEEX_ENCODE_BPS_20_DATASIZE = (((320*20)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_21_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(21),	// The bytes of one encoded frame at 2.1 bit per sample
X	E_NUONEEX_ENCODE_BPS_21_DATASIZE = (((320*21)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_22_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(22),	// The bytes of one encoded frame at 2.2 bit per sample
X	E_NUONEEX_ENCODE_BPS_22_DATASIZE = (((320*22)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_23_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(23),	// The bytes of one encoded frame at 2.3 bit per sample
X	E_NUONEEX_ENCODE_BPS_23_DATASIZE = (((320*23)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_24_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(24),	// The bytes of one encoded frame at 2.4 bit per sample
X	E_NUONEEX_ENCODE_BPS_24_DATASIZE = (((320*24)/10)>>3),	
N	E_NUONEEX_ENCODE_BPS_25_DATASIZE = NUONEEX_ENCODE_BYTE_PER_FRAME(25),	// The bytes of one encoded frame at 2.5 bit per sample
X	E_NUONEEX_ENCODE_BPS_25_DATASIZE = (((320*25)/10)>>3),	
N};
N
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		NuOneEx decoder initiate.
N//
N// Parameter
N//		pu8WorkBuf	[in]
N//			Buffer size is NUONEEX_DECODE_WORK_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode internal information and can not be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		pu8TempBuf [in]
N//			Buffer size is NUONEEX_DECODE_TEMP_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode temporary information and can be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		u32StartAddr [in]
N//			The adddress of the first NuOneEx data.
N//			For SPI flash, it is the SPI address.
N//			For file with file system, it is the offset from a file.
N//		pfnReadDataCallback [in]
N//			Function to read NuOneEx data.
N//
N// Return Value
N//		Sampling rate. If this value is 0, it represents decode failed in initiating.
N// -----------------------------------------------------------------------------------------------------------------------
NUINT32 NuOneEx_DecodeInitiate(
N	UINT8 *pu8DecodeWorkBuf,
N	UINT8 *pu8DecodeTempBuf,
N	UINT32 u32StartAddr,
N	PFN_AUDIO_DATAREQUEST pfnReadDataCallback
N);
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		NuOneEx decode data to PCM buffer. Programmer needs to make sure pi16DecodedPcmBuf buffer has enough space to save decoded data,
N//		or decoded buffer will be overflow.
N//
N// Parameter
N//		pu8WorkBuf	[in]
N//			Buffer size is NUONEEX_DECODE_WORK_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode internal information and can not be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		pu8TempBuf [in]
N//			Buffer size is NUONEEX_DECODE_TEMP_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode temporary information and can be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		pi16DecodedPcmBuf [out]
N//			Buffer size is NUONEEX_DECODE_SAMPLE_PER_FRAME*2 bytes.
N//			This buffer is used to keep decoded PCM data.
N//		pfnReadDataCallback [in]
N//			Function to read NuOneEx data.
N//		pfnUserEventCallback [in]
N//			Function to handle user event.
N//
N// Return Value
N//		Decoded PCM count. If this value is 0, it represent no PCM decoded.
N// -----------------------------------------------------------------------------------------------------------------------
NINT32 NuOneEx_DecodeProcess(
N	UINT8 *pu8DecodeWorkBuf,
N	UINT8 *pu8DecodeTempBuf,
N	PINT16 pi16DecodedPcmBuf,
N	PFN_AUDIO_DATAREQUEST pfnReadDataCallback,
N	PFN_AUDIO_USREVENT pfnUserEventCallback
N);
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		Check NuOneEx decode data finish or not.
N//
N// Parameter
N//		pu8WorkBuf	[in]
N//			Buffer size is NUONEEX_DECODE_WORK_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode internal information and can not be used with others.
N//			The buffer address must be 4 bytes alignment.
N//
N// Return Value
N//		TRUE: Decode process is end. 
N//		FALSE: Decode process is not end.
N// -----------------------------------------------------------------------------------------------------------------------
NBOOL NuOneEx_DecodeIsEnd(
N	UINT8 *pu8DecodeWorkBuf
N);
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		NuOneEx encoder initiate.
N//
N// Parameter
N//		pu8EncodeWorkBuf [in]
N//			Buffer size is NUONEEX_ENCODE_WORK_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode internal information and can not be shared with others.
N//		pu8EncodeTempBuf [in]
N//			Buffer size is NUONEEX_ENCODE_TEMP_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode temporary information and can be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		pPAudioChunkHeader [in]
N//			Audio Chunk header, it is defined in AudioCommon.h.
N//		eBpsID [in]
N//			ID of bit per sample after encoding, it is defined in eNuOneExEncodeBPS enumeration.
N//		u16SampleRate [in]
N//			Audio sampling rate.
N//
N// Return Value
N//		None.
N// -----------------------------------------------------------------------------------------------------------------------
Nvoid NuOneEx_EncodeInitiate(
N	UINT8 *pu8EncodeWorkBuf,
N	UINT8 *pu8EncodeTempBuf,
N	S_AUDIOCHUNK_HEADER *pAudioChunkHeader,
N	enum eNuOneExEncodeBPS eBpsID,
N	UINT16 u16SampleRate
N);
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		NuOneEx encode frame data to pi8EncodeDataBuf. Programmer make sure encoded buffer size is consistent with bit rate selection.
N//		Function will return non-zero encoded size, unit is byte, if encode successfully.
N//
N// Parameter
N//		pu8EncodeWorkBuf [in]
N//			Buffer size is NUONEEX_ENCODE_WORK_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode internal information and can not be shared with others.
N//			The buffer address must be 4 bytes alignment.
N//		pu8EncodeTempBuf [in]
N//			Buffer size is NUONEEX_ENCODE_TEMP_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode temporary information and can be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		pi16PcmBuf [out]
N//			Buffer size is NUONEEX_ENCODE_SAMPLE_PER_FRAME*2 bytes.
N//			This buffer is used to keep PCM data for encoding
N//		pi8EncodeDataBuf [in]
N//			Buffer size is E_NUONEEX_ENCODE_BPS_xx_DATASIZE bytes, where xx is the bit rate for encoding.
N//			This buffer is used to keep encoded data read from storage.
N//
N// Return Value
N//		The length of encoded data.
N// -----------------------------------------------------------------------------------------------------------------------
NUINT32 NuOneEx_EncodeProcess(
N	UINT8 *pu8EncodeWorkBuf,
N	UINT8 *pu8EncodeTempBuf,
N	PINT16 pi16PcmBuf,
N	PINT8  pi8EncodeDataBuf
N);
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		This function will update encoded data length, u32EncodeDataSize, into pAudioChunkHeader data structure after encoding.
N//		Programmer needs to write this data structure to first 12 bytes in storage.
N//
N// Parameter
N//		pu8EncodeWorkBuf [in]
N//			Buffer size is NUONEEX_ENCODE_WORK_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode internal information and can not be shared with others.
N//			The buffer address must be 4 bytes alignment.
N//		pu8EncodeTempBuf [in]
N//			Buffer size is NUONEEX_ENCODE_TEMP_BUF_SIZE bytes.
N//			This buffer is used to keep NuOneEx decode temporary information and can be used with others.
N//			The buffer address must be 4 bytes alignment.
N//		pAudioChunkHeader [out]
N//			Audio Chunk header will be updated with correct encoded data size.
N//		u32EncodeDataSize [in]
N//			Correct data size after finish encoding.
N// Return Value
N//		None.
N// -----------------------------------------------------------------------------------------------------------------------
Nvoid NuOneEx_EncodeEnd(
N	UINT8 *pu8EncodeWorkBuf,
N	UINT8 *pu8EncodeTempBuf,
N	S_AUDIOCHUNK_HEADER *pAudioChunkHeader,	
N	UINT32 u32EncodeDataSize
N);
N
N// -----------------------------------------------------------------------------------------------------------------------
N// Description
N//		Return the current version number of library.
N//
N// Parmeter
N//		None.
N//
N// Return Value
N//		Version number :
N//			bit 23:16: major number
N//			bit 15:8:  minor number
N//			bit 7:0:   build number
N// -----------------------------------------------------------------------------------------------------------------------
NUINT32 NuOneEx_GetVersion(void);
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif	//#ifndef __NUONEEX_H__
L 6 "..\NuOneExApp/NuOneExApp_Decode.h" 2
N#include "BufCtrl.h"
L 1 "..\..\..\..\Library\Framework\inc\BufCtrl.h" 1
N#ifndef _BUFCTRL_H_
N#define _BUFCTRL_H_
N
N#include "Platform.h"
N
N#define S_BUF_CTRL_FLAG_BUF			0
N#define S_BUF_CTRL_FLAG_CALLBACK	1
N#define S_BUF_CTRL_FLAG_INACTIVE	2
N#define S_BUF_CTRL_FLAG_MUTE		4
N#define S_BUF_CTRL_FLAG_PAUSE		8
N	
N#define BUF_CTRL_IS_ACTIVE(psBufCtrl)				(((psBufCtrl)->u8Flag & S_BUF_CTRL_FLAG_INACTIVE)==0)
N#define BUF_CTRL_IS_INACTIVE(psBufCtrl)				(((psBufCtrl)->u8Flag & S_BUF_CTRL_FLAG_INACTIVE) != 0)	
N#define BUF_CTRL_IS_MUTE_OR_INACTIVE(psBufCtrl)		(((psBufCtrl)->u8Flag & (S_BUF_CTRL_FLAG_INACTIVE|S_BUF_CTRL_FLAG_MUTE))!=0)
N#define BUF_CTRL_IS_PAUSE_OR_INACTIVE(psBufCtrl)	(((psBufCtrl)->u8Flag & (S_BUF_CTRL_FLAG_INACTIVE|S_BUF_CTRL_FLAG_PAUSE))!=0)
N#define BUF_CTRL_IS_PAUSE(psBufCtrl)				(((psBufCtrl)->u8Flag & S_BUF_CTRL_FLAG_PAUSE)!=0)
N#define BUF_CTRL_IS_MUTE(psBufCtrl)					(((psBufCtrl)->u8Flag & S_BUF_CTRL_FLAG_MUTE)!=0)
N#define BUF_CTRL_ISNOT_CALLBACK(psBufCtrl)			(((psBufCtrl)->u8Flag & S_BUF_CTRL_FLAG_CALLBACK)==0)
N#define BUF_CTRL_SET_ACTIVE(psBufCtrl)				((psBufCtrl)->u8Flag &= (~S_BUF_CTRL_FLAG_INACTIVE))
N#define BUF_CTRL_SET_INACTIVE(psBufCtrl)			((psBufCtrl)->u8Flag |= S_BUF_CTRL_FLAG_INACTIVE)
N#define BUF_CTRL_SET_CALLBACK(psBufCtrl) 			((psBufCtrl)->u8Flag |= S_BUF_CTRL_FLAG_CALLBACK)
N
N#define BUF_CTRL_SET_MUTE(psBufCtrl)				((psBufCtrl)->u8Flag |= S_BUF_CTRL_FLAG_MUTE)
N#define BUF_CTRL_SET_UNMUTE(psBufCtrl)				((psBufCtrl)->u8Flag &= (~S_BUF_CTRL_FLAG_MUTE))
N#define BUF_CTRL_SET_PAUSE(psBufCtrl)				((psBufCtrl)->u8Flag|=S_BUF_CTRL_FLAG_PAUSE)
N#define BUF_CTRL_SET_RESUME(psBufCtrl)				((psBufCtrl)->u8Flag&=(~S_BUF_CTRL_FLAG_PAUSE))
N
Ntypedef struct sBufCtrl
N{
N	UINT8 u8Flag;		// should not change this "u8Flag" order, to be the same order as S_CALLBACK_CTRL
N	
N	UINT16 u16BufCount;					// buffer total count
N	INT16  *pi16Buf;					// buffer pointer.(Ring buffer)
N	UINT16 u16BufReadIdx;				// buffer read index.
N	UINT16 u16BufWriteIdx;				// buffer write index.
N	
N	UINT16 u16SampleRate;				// Playback sample rate
N	UINT16 u16FrameSize;				// frame size that output samples by processing
N	UINT16 u16ReSamplingCalculation;	// Meta data for re-sampling calculation
N}S_BUF_CTRL;
N
N
Ntypedef UINT8 (*PFN_DATA_REQUEST_CALLBACK)(void *pParam, INT16 i16DataBufCount, INT16 ai16DataBuf[]);
Ntypedef struct sCallbackCtrl
N{
N	UINT8 u8Flag;		// should not change this "u8Flag" order, to be the same order as S_BUF_CTRL
N	
N	PFN_DATA_REQUEST_CALLBACK  pfnFunc;
N	UINT8 *pu8Param;
N} S_BUF_CTRL_CALLBACK;
N
N
Nvoid BufCtrl_ReadWithCount(S_BUF_CTRL *psSrc, UINT16 u16ConsumeCount, INT16 *pi16Des);
Nvoid BufCtrl_WriteWithCount(S_BUF_CTRL *psDes, UINT16 u16WriteCount, INT16 *pi16Src);
N
N#endif
L 7 "..\NuOneExApp/NuOneExApp_Decode.h" 2
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// Configuration: Output PCM Ring Buffer
N// -------------------------------------------------------------------------------------------------------------------------------
N#define NUONEEXAPP_OUT_FRAME_NUM	  		2																// It can be : 2, 4, 6, ....
N#define NUONEEXAPP_OUT_SAMPLES_PER_FRAME	NUONEEX_DECODE_SAMPLE_PER_FRAME								// Samples per frame.
N#define NUONEEXAPP_OUT_BUF_SIZE 			(NUONEEXAPP_OUT_FRAME_NUM*NUONEEXAPP_OUT_SAMPLES_PER_FRAME)	// Output ring buffer size.
N 							
N#if ( NUONEEXAPP_OUT_BUF_SIZE%8 )
X#if ( (2*320)%8 )
S	#error "NUONEEXAPP_OUT_BUF_SIZE must be multiple of '8'."	
N#endif		
N
N#define NUONEEXAPP_CTRL_DUPLICATE_TO_BUF	1
N#define NUONEEXAPP_CTRL_DUPLICATE_TO_FUNC	2
Ntypedef BOOL (*PFN_NUONEEXAPP_DUPLICATE_FUNC)(UINT16 u16WriteCount, INT16 *pi16Src);
N
N// NuOneEx decode application handler
Ntypedef struct
N{
N	// Work buffer for NuOneEx decode library to keep private data during decoding.
N	// (NUONEEX_DECODE_WORK_BUF_SIZE+3)/4 : Force to do 4 byte alignment
N	UINT32 au32DecodeWorkBuf[(NUONEEX_DECODE_WORK_BUF_SIZE+3)/4];
X	UINT32 au32DecodeWorkBuf[((198*2+4+2)+3)/4];
N	
N	// Pointer of temporary buffer array.
N	// Temporary buffer is provided for NuOneEx decode library. 
N	UINT8 *pau8TempBuf;
N
N	// The output buffer control provides these operations:
N	//	1. stores decoded PCMs
N	//	2. the read  index which represents the first decoded PCM data in the ring buffer
N	//	3. the write index which represents the first free space in the ring buffer
N	//	4. the frame size  which represents the count of decoded PCMs at each time
N	S_BUF_CTRL	sOutBufCtrl;
N	
N	// Duplicate data into buffer/callback function
N	union
N	{
N		S_BUF_CTRL *psDuplicateOutBufCtrl;
N		PFN_NUONEEXAPP_DUPLICATE_FUNC pfnDuplicateFunc;
N	};
N	
N	// The buffer to store decoded PCM and referenced by "sOutBufCtrl".
N	INT16 i16OutBuf[NUONEEXAPP_OUT_BUF_SIZE];
X	INT16 i16OutBuf[(2*320)];
N
N	// The index of read callback and event function to g_asAppCallBack[] array in AppCallback.c.
N	// At NuOneEx decoder needs data,       it will call the read  callback funciton to get NuOneEx data.
N	// At NuOneEx decoder discovers events, it will call the event callback funciton to handle event.
N	UINT8 u8CallbackIndex;
N	
N	// The audio play channel to play the decoded data.
N	UINT8 u8PlaybackChannel;
N	
N	// Duplicate control flag(To buffer/callback function)
N	UINT8 u8CtrlFlag;
N	
N} S_NUONEEX_APP_DECODE;
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Initiate for NuOneEx decode application.
N//
N//	Parameter
N//  	psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N//  	pau8TempBuf [in] :
N//		Temporary buffer for NuXXX series decode application.
N//		Temporary buffer could be re-used by user after decode per frame.
N//
N//		u32CallbackIndex [in] :
N//			The index of read callback and event function to g_asAppCallBack[] array in AppCallback.c.
N//			At NuOneEx decoder needs data,       it will call the read  callback funciton to get NuOneEx data.
N//			At NuOneEx decoder discovers events, it will call the event callback funciton to handle event.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid 
NNuOneExApp_DecodeInitiate(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode, 
N	UINT8 *pau8TempBuf, 
N	UINT32 u32CallbackIndex
N	);
N	
N//---------------------------------------------------------------------------------------------------------
N//	Description:                                                                                           
N//		Initiate to play the NuOneEx file represented by audio file ID.
N//		The NuOneEx file will be discovered in audio rom file according the inputed audio ID.
N//		
N//		This function will decode first frame of NuOneEx data to output buffer after discovered the NuOneEx file.
N//
N//		Due to this function does not enable APU to play processed PCMs.
N//		Must call Playback_StartPlay() to start APU playing if necessary!
N//
N// 	Argument:
N//		psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N//		u32AudioID [in] :
N//			Index of audio file in audio ROM file.  
N//
N//		u32RomStartAddr [in] :
N//			The start address of audio ROM file in sorage.
N//
N//		u8PlaybackChannel [in] : 
N//			Assign the audio play channel to play the decoded data.
N//
N//	Return:
N// 		FALSE : 
N//			Codec format in ROM file dis-match. 
N//			Or start address of audio chunk is incorrect.
N//		TRUE : 
N//			Start play audio in ROM file.
N//---------------------------------------------------------------------------------------------------------
NBOOL 
NNuOneExApp_DecodeStartPlayByID(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode, 
N	UINT32 u32AudioID,
N	UINT32 u32RomStartAddr,
N	UINT8 u8PlaybackChannel
N);
N	
N//---------------------------------------------------------------------------------------------------------
N//	Description:                                                                                           
N//		Initiate to play the NuOneEx file represented by storage address.
N//		The NuOneEx file will be discovered in storage according to the inputed start address.
N//		
N//		This function will decode first frame of NuOneEx data to output buffer after discovered the NuOneEx file.
N//
N//		Due to this function does not enable APU to play processed PCMs.
N//		Must call Playback_StartPlay() to start APU playing if necessary!
N//
N// 	Argument:
N//		psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N//		u32NuOneExStorageStartAddr [in] :
N//			Start address to load NuOneEx encode data in the storage. 
N//			Porgrammer can call	AudioRom_GetAudioChunkInfo(in AudioRom.c) to parse ROM file and get address.
N//
N//		u8PlaybackChannel [in] : 
N//			Assign the audio play channel to play the decoded data.
N//
N//	Return:
N// 		FALSE : 
N//			Codec format in ROM file dis-match.
N//			Or start address of audio chunk is incorrect.
N//		TRUE : 
N//			Start play audio in ROM file.
N//---------------------------------------------------------------------------------------------------------
NBOOL 
NNuOneExApp_DecodeStartPlayByAddr(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode, 
N	UINT32 u32NuOneExStorageStartAddr,
N	UINT8 u8PlaybackChannel
N);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description:                                                                                           
N//		Stop to decode audio data and remove from audio play channel.
N//
N//		Due to this function does not close APU to play PCMs. 
N//		Must call Playback_StopPlay() to close APU playing if necessary!
N//
N// 	Argument:
N//		psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N//	Return:
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid 
NNuOneExApp_DecodeStopPlay(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode
N);
N
N//---------------------------------------------------------------------------------------------------------
N// 	Description:     
N//		Decode NuOneEx and produce PCMs to output ring buffer.
N//		Can check the function return value to know it is running out of audio data or decoding stopped. 
N//
N// 	Argument:
N//		psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N// 	Return:
N// 		FALSE : 
N//			Running out of audio data or decoding stopped.
N//		TRUE :  
N//			Decoding is going on.
N//---------------------------------------------------------------------------------------------------------
NBOOL 
NNuOneExApp_DecodeProcess(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode
N	);
N
N//---------------------------------------------------------------------------------------------------------
N// 	Description:     
N//		Force inline function.
N//		Duplicate output data into assign buffer.
N//
N// 	Argument:
N//		psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N//		psOutBufCtrl [in] :
N//			Assign buffer to save output data.
N//
N// 	Return:
N// 		None
N//---------------------------------------------------------------------------------------------------------
N__STATIC_INLINE void
Xstatic __inline void
NNuOneExApp_DuplicateOutputToBuf(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode,
N	S_BUF_CTRL *psOutBufCtrl
N) 
N{
N	psNuOneExAppDecode->u8CtrlFlag = (psNuOneExAppDecode->u8CtrlFlag&(~NUONEEXAPP_CTRL_DUPLICATE_TO_FUNC))|NUONEEXAPP_CTRL_DUPLICATE_TO_BUF;
X	psNuOneExAppDecode->u8CtrlFlag = (psNuOneExAppDecode->u8CtrlFlag&(~2))|1;
N	psNuOneExAppDecode->psDuplicateOutBufCtrl = psOutBufCtrl;
N	psOutBufCtrl->u16SampleRate = psNuOneExAppDecode->sOutBufCtrl.u16SampleRate;
N}
N
N//---------------------------------------------------------------------------------------------------------
N// 	Description:     
N//		Force inline function.
N//		Duplicate output data into callback function to provide application processing.
N//
N// 	Argument:
N//		psNuOneExAppDecode [in] :
N//			Pointer of NuOneEx decode application handler.
N//
N//		pfnDuplicateFunc [in] :
N//			Assign callback to process output data.
N//
N// 	Return:
N// 		None
N//---------------------------------------------------------------------------------------------------------
N__STATIC_INLINE void
Xstatic __inline void
NNuOneExApp_DuplicateOutputToFunc(
N	S_NUONEEX_APP_DECODE *psNuOneExAppDecode,
N	PFN_NUONEEXAPP_DUPLICATE_FUNC pfnDuplicateFunc
N) 
N{
N	psNuOneExAppDecode->u8CtrlFlag = (psNuOneExAppDecode->u8CtrlFlag&(~NUONEEXAPP_CTRL_DUPLICATE_TO_BUF))|NUONEEXAPP_CTRL_DUPLICATE_TO_FUNC;
X	psNuOneExAppDecode->u8CtrlFlag = (psNuOneExAppDecode->u8CtrlFlag&(~1))|2;
N	psNuOneExAppDecode->pfnDuplicateFunc = pfnDuplicateFunc;
N}
N
N#endif
L 29 "..\App.h" 2
N#include "NuOneExApp/NuOneExApp_Encode.h"
L 1 "..\NuOneExApp/NuOneExApp_Encode.h" 1
N#ifndef _CONFIGNUONEEXAPP_ENCODE_H_
N#define _CONFIGNUONEEXAPP_ENCODE_H_
N
N#include "ConfigApp.h"
N#include "NuOneEx.h"
N#include "BufCtrl.h"
N
N// -------------------------------------------------------------------------------------------------------------------------------
N// PCM Ring Buffer Definitions 
N// -------------------------------------------------------------------------------------------------------------------------------
N#define NUONEEXAPP_IN_FRAME_NUM	  			2		// it can be : 2, 3, 4, 5, ....
N#define NUONEEXAPP_IN_SAMPLES_PER_FRAME		NUONEEX_DECODE_SAMPLE_PER_FRAME
N#define NUONEEXAPP_IN_BUF_SIZE 				(NUONEEXAPP_IN_FRAME_NUM*NUONEEXAPP_IN_SAMPLES_PER_FRAME)
N 							
N#if ( NUONEEXAPP_ENCODE_ADC_BUF_SIZE%8 )
S	#error "NUONEEXAPP_IN_BUF_SIZE must be multiple of '8'."	
N#endif						
N
N#define NUONEEXAPP_ENCODE_MAX_BITRATE		E_NUONEEX_ENCODE_BPS_20				// NuOne bit rate selection
N#define NUONEEXAPP_ENCODE_BUF_COUNT			2									// must >= 2
N#define NUONEEXAPP_ENCODE_BUF_TOTAL_SIZE	((NUONEEXAPP_ENCODE_MAX_BITRATE>>3)*NUONEEXAPP_ENCODE_BUF_COUNT)
N 							
N#if ( NUONEEXAPP_ENCODE_BUF_TOTAL_SIZE%8 )
X#if ( ((E_NUONEEX_ENCODE_BPS_20>>3)*2)%8 )
S	#error "NUONEEXAPP_ENCODE_BUF_TOTAL_SIZE must be multiple of '8'."	
N#endif		
N
Ntypedef struct
N{
N	// Work buffer for NuOneEx decode library to keep private data during decoding.
N	// (NUONEEX_ENCODE_WORK_BUF_SIZE+3)/4 : Force to do 4 byte alignment
N	UINT32 au32WorkBuf[(NUONEEX_ENCODE_WORK_BUF_SIZE+3)/4];
X	UINT32 au32WorkBuf[((326*2+4)+3)/4];
N	
N	// Frame buffer for keeping encoded data after NuOneEx encoding 
N	// (NUONEEXAPP_ENCODE_BUF_TOTAL_SIZE+3)/4 : Force to do 4 byte alignment
N	UINT32 au32EncodeBuf[(NUONEEXAPP_ENCODE_BUF_TOTAL_SIZE+3)/4];
X	UINT32 au32EncodeBuf[(((E_NUONEEX_ENCODE_BPS_20>>3)*2)+3)/4];
N	
N	// Input buffer to save PCM samples
N	INT16 i16InBuf[NUONEEXAPP_IN_BUF_SIZE];
X	INT16 i16InBuf[(2*320)];
N	
N	// Pointer of temporary buffer array.
N	// Temporary buffer is provided for NuOneEx encode library.
N	UINT8 *pau8TempBuf;
N	
N	// The encoded buffer control structure provides these operations:
N	// 1. stores encoded data.
N	// 2. the read index which represents the first encoded data in the ring buffer
N	// 3. the write index which represents the first free space in the ring buffer
N	// 4. the frame size which represents the count of encoded data at each time
N	S_BUF_CTRL	sEncodeBufCtrl;
N	
N	// The PCM input buffer control structure provides these operations:
N	// 1. stores PCM data.
N	// 2. the read index which represents the first PCM data for encoding in the ring buffer
N	// 3. the write index which represents the first free space in the ring buffer
N	// 4. the frame size which represents the count of input PCM at each time
N	S_BUF_CTRL	sInBufCtrl;
N	
N} S_NUONEEX_APP_ENCODE;
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Initiate buffer controlling for NuOneEx encode application
N//
N//	Parameter
N//  	psNuOneExAppEncode[in] :
N//			Pointer of NuOneEx encode application handler.
N//  	pu8EncodeTempBuf[in]
N//		Temporary buffer for NuXXX series codec application.
N//		Temporary buffer could be re-used by user after encoding one frame.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid NuOneExApp_EncodeInitiate(S_NUONEEX_APP_ENCODE *psNuOneExAppEncode, UINT8 *pu8EncodeTempBuf);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description:                                                                                           
N//		Initiate NuOneEx encode required variables and header information.
N//		
N//		Due to this function does not enable ADC to record input PCMs.
N//		Must call Record_StartRec() to start ADC recording if necessary!	
N//
N// 	Argument:
N//		psNuOneExAppEncode[in] :
N//			Pointer of NuOneEx encode application handler.
N//		psAudioChunkHeader[in] :
N//			Structure pointer of audio chunk header for recording information. 
N//			Encoded information:
N//			enocded format, sample rate, encoded total size and bit rate.
N// 		u16SampleRate[in] :
N//			Sample rate of input data to provide NuOneEx encoder.
N// 		eBitPerSample[in] :
N//			Bit per sample of input data to provide NuOneEx encoder.
N//
N//	Return:
N//		FALSE : 
N//			Bit rate is larger than NUONEEXAPP_ENCODE_MAX_BITRATE or sample rate is zero.
N//		TRUE :
N//			Initiate NuOneEx encoder successfully.
N//---------------------------------------------------------------------------------------------------------
NBOOL NuOneExApp_EncodeStart(S_NUONEEX_APP_ENCODE *psNuOneExAppEncode, S_AUDIOCHUNK_HEADER *psAudioChunkHeader, UINT16 u16SampleRate, enum eNuOneExEncodeBPS eBitPerSample);
N
N//---------------------------------------------------------------------------------------------------------
N// 	Description:     
N//		Encode data from ADC input buffer and put into encoded buffer.
N//		Can check the function return value to know it is running out of audio data or encoding stopped. 
N//
N//		Due to this function does not write any encoded data to storage.
N//		Must SPIFlashUtil_WriteEncodeData to flush encoded data and write to storage.
N//
N// 	Argument:
N//		psNuOneExAppEncode[in] :
N//			Pointer of NuOneEx encode application handler.
N//
N// 	Return:
N// 		FALSE : 
N//			Active flag of input buffer for ADC is not triggered.
N//		TRUE :  
N//			Encoding is going on.
N//---------------------------------------------------------------------------------------------------------
NBOOL NuOneExApp_EncodeProcess(S_NUONEEX_APP_ENCODE *psNuOneExAppEncode);
N
N//---------------------------------------------------------------------------------------------------------
N// 	Description:     
N//		Stop to ecode PCM data from ADC.
N//		
N//		Due to this function does not close ADC for encoding. 
N//		Must call Record_StopRec() to close ADC playing!	
N//		
N//		Besides, programmer needs to call SPIFlashUtil_EndWriteEncodeData function
N//		to update header information after completely encoding.
N//
N// 	Argument:
N//		psNuOneExAppEncode[in] :
N//			Pointer of NuOneEx encode application handler.
N//
N// 	Return:
N// 		None.
N//---------------------------------------------------------------------------------------------------------
Nvoid NuOneExApp_EncodeEnd(S_NUONEEX_APP_ENCODE *psNuOneExAppEncode);
N
N#endif
L 30 "..\App.h" 2
N#include "PlaybackRecord.h"
L 1 "..\..\..\..\Library\Framework\inc\PlaybackRecord.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                              */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#ifndef __PLAYBACKRECORD_H__
N#define __PLAYBACKRECORD_H__
N
N#include "Platform.h"
N#include "BufCtrl.h"
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N// Finesse of DB calibrate value
N#define PLAYBACK_VOLUME_FINE_SHIFT	(10)
N
N// Definition for "g_u32Playback_Volume_DB_Table" reference(Do not modify)
N#define PLAYBACK_VOLUME_MUTE		(0)
N#define PLAYBACK_VOLUME_NEG35_DB	(0.0178*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG30_DB	(0.0316*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG25_DB	(0.0562*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG20_DB	(0.1000*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG15_DB	(0.1778*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG10_DB	(0.3162*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG6_DB		(0.5012*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_NEG3_DB		(0.7079*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_0_DB		(1*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_3_DB		(1.4125*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_6_DB		(1.9953*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N#define PLAYBACK_VOLUME_10_DB		(3.1623*(1<<PLAYBACK_VOLUME_FINE_SHIFT))
N
N#define PLAYBACK_DECLARE_VOLUME_DB_TABLE()			\
Nuint32_t const g_u32Playback_Volume_DB_Table[] =  	\
N{ 													\
N	PLAYBACK_VOLUME_MUTE,							\
N	PLAYBACK_VOLUME_NEG35_DB,						\
N	PLAYBACK_VOLUME_NEG30_DB,						\
N	PLAYBACK_VOLUME_NEG25_DB,						\
N	PLAYBACK_VOLUME_NEG20_DB,						\
N	PLAYBACK_VOLUME_NEG15_DB,						\
N	PLAYBACK_VOLUME_NEG10_DB,						\
N	PLAYBACK_VOLUME_NEG6_DB,						\
N	PLAYBACK_VOLUME_NEG3_DB,						\
N	PLAYBACK_VOLUME_0_DB,							\
N	PLAYBACK_VOLUME_3_DB,							\
N	PLAYBACK_VOLUME_6_DB,							\
N	PLAYBACK_VOLUME_10_DB							\
N};
X#define PLAYBACK_DECLARE_VOLUME_DB_TABLE()			uint32_t const g_u32Playback_Volume_DB_Table[] =  	{ 														PLAYBACK_VOLUME_MUTE,								PLAYBACK_VOLUME_NEG35_DB,							PLAYBACK_VOLUME_NEG30_DB,							PLAYBACK_VOLUME_NEG25_DB,							PLAYBACK_VOLUME_NEG20_DB,							PLAYBACK_VOLUME_NEG15_DB,							PLAYBACK_VOLUME_NEG10_DB,							PLAYBACK_VOLUME_NEG6_DB,							PLAYBACK_VOLUME_NEG3_DB,							PLAYBACK_VOLUME_0_DB,								PLAYBACK_VOLUME_3_DB,								PLAYBACK_VOLUME_6_DB,								PLAYBACK_VOLUME_10_DB							};
N	
N
N
N// ---------------------------------------------------------------------------------------------------------
N// Function: Playback_StartPlay
N//
N// Description:
N//	Enable APU to play audio data
N//
N// Argument:
N//	psDacBufCtrl:
N//					the poiner o buffer control(S_BUF_CTRL*) which contain PCMs data for playback or
N//					the pointer callback function(S_BUF_CTRL_CALLBACK*) which provides PCMs data for playback
N//	u32SampleRate:	the playback sample rate
N//
N// Return:
N//	TRUE:	sucessful
N// ---------------------------------------------------------------------------------------------------------	
Nvoid Playback_StartPlay(void);
N
N// ---------------------------------------------------------------------------------------------------------
N// Function: Playback_StopPlay
N//
N// Description:
N//	Stop APU to play audio data and wait for APU do stop.
N//
N// Argument:
N//
N// Return:
N//
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_StopPlay(void);
N
Nvoid Record_StopRec(void);
N
Nvoid 
NRecord_SetInBufCallback(
N	S_BUF_CTRL_CALLBACK *psAdcBufCtrl,
N	PFN_DATA_REQUEST_CALLBACK pfnSetIntputData,
N	void* pWorkBuf
N);
N
Nvoid 
NRecord_SetInBufRecord(
N	S_BUF_CTRL* psInBufCtrl,
N	UINT16 u16BufSize,
N	INT16* pi16Buf,
N	UINT16 u16FrameSize,
N	UINT16 u16SampleRate
N);
N
N// ---------------------------------------------------------------------------------------------------------
N// Function: Playback_SetOutputBuf
N//
N// Description:
N//	Set parameters to output buffer structure.
N//
N// Argument:
N//	psOutBufCtrl: structure pointer of parameter for output buffer
N//	u16BufSize: output buffer size.
N//	pi16Buf: adddress pointer of output buffer.
N//	u16FrameSize: frame size by processing
N//	u16SampleRate: APU output sample rate
N//
N// Return:
N//	None
N// ---------------------------------------------------------------------------------------------------------
Nvoid
NPlayback_SetOutputBuf(
N	S_BUF_CTRL* psOutBufCtrl,
N	UINT16 u16BufSize,
N	INT16* pi16Buf,
N	UINT16 u16FrameSize,
N	UINT16 u16SampleRate
N);
N
N// ---------------------------------------------------------------------------------------------------------
N// Function: Playback_NeedUpdateOutputBuf
N//
N// Description:
N//	According to free space to make decisions for output buffer updated .
N//
N// Argument:
N//	psOutBufCtrl: structure pointer of parameter for output buffer.
N//
N// Return:
N//	TRUE: free space  
N//	FALSE: no space
N// ---------------------------------------------------------------------------------------------------------
NBOOL
NPlayback_NeedUpdateOutputBuf(
N	S_BUF_CTRL* psOutBufCtrl
N);
N
N// ---------------------------------------------------------------------------------------------------------
N// Function: Playback_UpdateOutputBuf
N//
N// Description:
N//	Update write index of output buffer and avoid output buffer overflow.
N//
N// Argument:
N//	psOutBufCtrl: structure pointer of parameter for output buffer
N//
N// Return:
N//	None
N// ---------------------------------------------------------------------------------------------------------
Nvoid
NPlayback_UpdateOutputBuf(
N	S_BUF_CTRL* psOutBufCtrl
N);
N
Nvoid 
NPlayback_Initiate(
N	void
N	);
N
Nvoid 
NPlayback_Add(
N	UINT8 u8Channel,
N	S_BUF_CTRL *psBufCtrl
N);
N
Nvoid
NPlayback_Remove(
N	UINT8 u8Channel
N	);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Audio playback control to pause/resume one channel play.
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  bEnable : TRUE:Pause channel play, FALSE:Resume channel play. 
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_PauseCtrl(uint8_t u8Channel,BOOL bEnable);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Audio playback control to mute/unmute one channel play.
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  bEnable : TRUE:Mute channel play, FALSE:UnMute channel play. 
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_MuteCtrl(uint8_t u8Channel,BOOL bEnable);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	1. Audio playback control to set play volume DB value.
N//  2. DB value is defined in file "PlaybackRecord.h".
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  u32DBValue : Config DB Value(Defined in "PlaybackRecord.h", ex. PLAYBACK_VOLUME_DB_MUTE, PLAYBACK_VOLUME_DB_NEG3)
N// 
N// Return:
N//	TRUE : Success.
N//  FALSE : DB value isn't in "g_u32AudioVolume_DB_Table" table.
N// ---------------------------------------------------------------------------------------------------------
NBOOL Playback_SetVolumeDB(uint8_t u8Channel,uint32_t u32DBValue);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	1. Audio playback control to adjust current DB step.
N//  2. Adjust step is relative current DB index to increase(positive) or decrease(nagative). 
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  i8AdjustDBStep : Adjust DB step.(Positive:Loud,Nagative:Quiet)
N//  u16StepIntervalBytes : Interval bytes between DB step.
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_AdjustVolumeDBStep(uint8_t u8Channel, int8_t i8AdjustDBStep, uint16_t u16StepIntervalBytes);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Config volume is equal to current volume.
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//
N// Return:
N//	TRUE : Is equal.
N//  FALSE : Not equal.
N// ---------------------------------------------------------------------------------------------------------
NBOOL Playback_IsTargetVolume(uint8_t u8Channel);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Audio playback control to effect the "fade out volume".
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  u16StepIntervalBytes : Interval bytes between DB step.(smooth variable)
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_VolumeFadeOut(uint8_t u8ChannelIndex,uint16_t u16StepIntervalBytes);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Audio playback control to effect the "fade in volume".
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  u16StepIntervalBytes : Interval bytes between DB step.(smooth variable)
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_VolumeFadeIn(uint8_t u8ChannelIndex,uint16_t u16StepIntervalBytes);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Process one PCM byte data. 
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N//  
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_ProcessVolume(uint8_t u8Channel,int16_t* pi16Data);
N
N// ---------------------------------------------------------------------------------------------------------
N// Description:
N//	Audio playback control to reset one channel volume to default DB index value.
N//  (Note. This API is needed to config "PLAYBACK_VOLUME_CONTROL = 1" in "ConfigApp.h")
N//
N// Argument:
N//	u8Channel : Control channel.
N// ---------------------------------------------------------------------------------------------------------
Nvoid Playback_ResetChannelVolume(uint8_t u8Channel);
N
Nvoid Record_Add(
N	S_BUF_CTRL *psAdcBufCtrl,
N	UINT32 u32SampleRate
N);
N
Nvoid Record_StartRec(void);
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif //#ifndef __PLAYBACKRECORD_H__
L 31 "..\App.h" 2
N#include "BufCtrl.h"
N#include "SpiFlashMap.h"
L 1 "..\SpiFlashMap.h" 1
N#ifndef _SPIFLASHMAP_H_
N#define _SPIFLASHMAP_H_
N
N#define SPIFLASH_BLOCK_SIZE					(4096)
N
N#define AUDIOROM_STORAGE_START_ADDR	(1024*1024)
N
N#endif
L 33 "..\App.h" 2
N#include "ConfigIO.h"
L 1 "..\ConfigIO.h" 1
N/**************************************************************************//**
N * @file     ConfigIO.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/09/25 11:00a $
N * @brief    Header file of IO configuration.
N *           This file could be generated by NuKeilIDE tool. 
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N
N#ifndef _CONFIGIO_H_
N#define _CONFIGIO_H_
N
N#include "Platform.h"
N
N//%{CodeGen_Block_Start}
N#define KEY_DEBOUNCE_TIME		(0.0500)	// unit:s
N#define KEY_PRESS_TIME			(1.0000)	// unit:s
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of Matrix Keys
N//------------------------------------------------------------------------------------------------//
N// Keypad Matrix Mapping
N//
N//	(0 x 0)
N
N#define MATRIX_INPUT_PINS_COUNT			(0)	// in:0, out:0
N#define MATRIX_OUTPUT_PINS_COUNT		(0)
N#define MATRIX_KEY_COUNT				(MATRIX_INPUT_PINS_COUNT*MATRIX_OUTPUT_PINS_COUNT)
N
N#define MATRIX_PORTA_INPUT_PINS_MASK	(0)
N#define MATRIX_PORTA_OUTPUT_PINS_MASK	(0)	// BIT1~BITn
N
N#define MATRIX_PORTB_INPUT_PINS_MASK	(0)
N#define MATRIX_PORTB_OUTPUT_PINS_MASK	(0)	// BIT1~BITn
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of Input Keys
N//------------------------------------------------------------------------------------------------//
N#define TRIGGER_KEY_COUNT	(6)
N
N#define TG1_PIN_MASK		BIT0
N#define TG2_PIN_MASK		BIT1
N#define TG3_PIN_MASK		BIT2
N#define TG4_PIN_MASK		BIT3
N#define TG5_PIN_MASK		BIT6
N#define TG6_PIN_MASK		BIT7
N
N//TRIGGER_PORT
N#define TRIGGER_PORTA_PINS_MASK		(0)
N#define TRIGGER_PORTB_PINS_MASK		(TG1_PIN_MASK|TG2_PIN_MASK|TG3_PIN_MASK|TG4_PIN_MASK| \
N		TG5_PIN_MASK|TG6_PIN_MASK)
X#define TRIGGER_PORTB_PINS_MASK		(TG1_PIN_MASK|TG2_PIN_MASK|TG3_PIN_MASK|TG4_PIN_MASK| 		TG5_PIN_MASK|TG6_PIN_MASK)
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of Output Keys
N//------------------------------------------------------------------------------------------------//
N#define OUT_KEY_COUNT		(6)
N
N//OUT1
N#define OUT1_PORT				PA
N#define OUT1_PIN_MASK			BIT12
N//OUT2
N#define OUT2_PORT				PA
N#define OUT2_PIN_MASK			BIT13
N//OUT3
N#define OUT3_PORT				PA
N#define OUT3_PIN_MASK			BIT14
N//OUT4
N#define OUT4_PORT				PA
N#define OUT4_PIN_MASK			BIT15
N//OUT5
N#define OUT5_PORT				PB
N#define OUT5_PIN_MASK			BIT4
N//OUT6
N#define OUT6_PORT				PB
N#define OUT6_PIN_MASK			BIT5
N//OUTPUT_PORT
N#define OUTPUT_PORTA_PINS_MASK		(OUT1_PIN_MASK|OUT2_PIN_MASK|OUT3_PIN_MASK|OUT4_PIN_MASK)
N#define OUTPUT_PORTB_PINS_MASK		(OUT5_PIN_MASK|OUT6_PIN_MASK)
N
Nextern void OutputPin_Set(GPIO_T *pPort, UINT16 u16PinMask, UINT8 u8Value);
N
N#define	OUT1(b)		OutputPin_Set(OUT1_PORT,OUT1_PIN_MASK,b)
N#define	OUT2(b)		OutputPin_Set(OUT2_PORT,OUT2_PIN_MASK,b)
N#define	OUT3(b)		OutputPin_Set(OUT3_PORT,OUT3_PIN_MASK,b)
N#define	OUT4(b)		OutputPin_Set(OUT4_PORT,OUT4_PIN_MASK,b)
N#define	OUT5(b)		OutputPin_Set(OUT5_PORT,OUT5_PIN_MASK,b)
N#define	OUT6(b)		OutputPin_Set(OUT6_PORT,OUT6_PIN_MASK,b)
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of KEY (key matrix) Handlers
N//------------------------------------------------------------------------------------------------//
N#define KEYR		0x10000000
N#define KEYF		0x20000000
N#define KEYP		0x40000000
N
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of TG Handlers
N//------------------------------------------------------------------------------------------------//
N#define TGR			0x10000000
N#define TGF			0x20000000
N#define TGP			0x40000000
N
N//TG1
N#define TG1 		(1)
N#define TG1R		(TG1|TGR)
N#define TG1F		(TG1|TGF)
N#define TG1P		(TG1|TGP)
N//TG2
N#define TG2 		(2)
N#define TG2R		(TG2|TGR)
N#define TG2F		(TG2|TGF)
N#define TG2P		(TG2|TGP)
N//TG3
N#define TG3 		(3)
N#define TG3R		(TG3|TGR)
N#define TG3F		(TG3|TGF)
N#define TG3P		(TG3|TGP)
N//TG4
N#define TG4 		(4)
N#define TG4R		(TG4|TGR)
N#define TG4F		(TG4|TGF)
N#define TG4P		(TG4|TGP)
N//TG5
N#define TG5 		(5)
N#define TG5R		(TG5|TGR)
N#define TG5F		(TG5|TGF)
N#define TG5P		(TG5|TGP)
N//TG6
N#define TG6 		(6)
N#define TG6R		(TG6|TGR)
N#define TG6F		(TG6|TGF)
N#define TG6P		(TG6|TGP)
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of In-Out keys
N//------------------------------------------------------------------------------------------------//
Nextern void Default_KeyHandler(UINT32 u32Param);
N
N
N#define DECLARE_MATRIX_KEY() \
NS_KEYPAD_KEY_HANDLER const g_asMatrixKeyHandler[] =  \
N{  \
N	{0, 0, 0, 0, 0, 0, 0}  \
N	}; \
N	const UINT8 g_au8MatrixKeyStateIndex[] = {0};
X#define DECLARE_MATRIX_KEY() S_KEYPAD_KEY_HANDLER const g_asMatrixKeyHandler[] =  {  	{0, 0, 0, 0, 0, 0, 0}  	}; 	const UINT8 g_au8MatrixKeyStateIndex[] = {0};
N
N#if (MATRIX_OUTPUT_PINS_COUNT>0)	// not create if MATRIX_KEY_COUNT==0
X#if ((0)>0)	
S#define DECLARE_MATRIX_KEY_BUF()	UINT16 g_u16aKeyPinValueBuf[MATRIX_OUTPUT_PINS_COUNT];
N#else
N#define DECLARE_MATRIX_KEY_BUF()
N#endif
N
N//------------------------------------------------------------------------------------------------//
N
N#define	DECLARE_TRIGGER_KEY() \
NS_KEYPAD_TGR_HANDLER const g_asTriggerKeyHandler[] =  \
N{ \
N	{Default_KeyHandler, TG1F, BIT0, KEYPAD_GPIOB, KEYPAD_FALLING}, \
N	{Default_KeyHandler, TG1R, BIT0, KEYPAD_GPIOB, KEYPAD_RISING}, \
N	{Default_KeyHandler, TG1P, BIT0, KEYPAD_GPIOB, KEYPAD_PRESSING}, \
N	{Default_KeyHandler, TG2F, BIT1, KEYPAD_GPIOB, KEYPAD_FALLING}, \
N	{Default_KeyHandler, TG2R, BIT1, KEYPAD_GPIOB, KEYPAD_RISING}, \
N	{Default_KeyHandler, TG2P, BIT1, KEYPAD_GPIOB, KEYPAD_PRESSING}, \
N	{Default_KeyHandler, TG3F, BIT2, KEYPAD_GPIOB, KEYPAD_FALLING}, \
N	{Default_KeyHandler, TG3R, BIT2, KEYPAD_GPIOB, KEYPAD_RISING}, \
N	{Default_KeyHandler, TG3P, BIT2, KEYPAD_GPIOB, KEYPAD_PRESSING}, \
N	{Default_KeyHandler, TG4F, BIT3, KEYPAD_GPIOB, KEYPAD_FALLING}, \
N	{Default_KeyHandler, TG4R, BIT3, KEYPAD_GPIOB, KEYPAD_RISING}, \
N	{Default_KeyHandler, TG4P, BIT3, KEYPAD_GPIOB, KEYPAD_PRESSING}, \
N	{Default_KeyHandler, TG5F, BIT6, KEYPAD_GPIOB, KEYPAD_FALLING}, \
N	{Default_KeyHandler, TG5R, BIT6, KEYPAD_GPIOB, KEYPAD_RISING}, \
N	{Default_KeyHandler, TG5P, BIT6, KEYPAD_GPIOB, KEYPAD_PRESSING}, \
N	{Default_KeyHandler, TG6F, BIT7, KEYPAD_GPIOB, KEYPAD_FALLING}, \
N	{Default_KeyHandler, TG6R, BIT7, KEYPAD_GPIOB, KEYPAD_RISING}, \
N	{Default_KeyHandler, TG6P, BIT7, KEYPAD_GPIOB, KEYPAD_PRESSING}, \
N	{0, 0, 0, 0, 0}  \
N	}; \
N	const UINT8 g_au8TriggerKeyStateIndex[] = {3,6};
X#define	DECLARE_TRIGGER_KEY() S_KEYPAD_TGR_HANDLER const g_asTriggerKeyHandler[] =  { 	{Default_KeyHandler, TG1F, BIT0, KEYPAD_GPIOB, KEYPAD_FALLING}, 	{Default_KeyHandler, TG1R, BIT0, KEYPAD_GPIOB, KEYPAD_RISING}, 	{Default_KeyHandler, TG1P, BIT0, KEYPAD_GPIOB, KEYPAD_PRESSING}, 	{Default_KeyHandler, TG2F, BIT1, KEYPAD_GPIOB, KEYPAD_FALLING}, 	{Default_KeyHandler, TG2R, BIT1, KEYPAD_GPIOB, KEYPAD_RISING}, 	{Default_KeyHandler, TG2P, BIT1, KEYPAD_GPIOB, KEYPAD_PRESSING}, 	{Default_KeyHandler, TG3F, BIT2, KEYPAD_GPIOB, KEYPAD_FALLING}, 	{Default_KeyHandler, TG3R, BIT2, KEYPAD_GPIOB, KEYPAD_RISING}, 	{Default_KeyHandler, TG3P, BIT2, KEYPAD_GPIOB, KEYPAD_PRESSING}, 	{Default_KeyHandler, TG4F, BIT3, KEYPAD_GPIOB, KEYPAD_FALLING}, 	{Default_KeyHandler, TG4R, BIT3, KEYPAD_GPIOB, KEYPAD_RISING}, 	{Default_KeyHandler, TG4P, BIT3, KEYPAD_GPIOB, KEYPAD_PRESSING}, 	{Default_KeyHandler, TG5F, BIT6, KEYPAD_GPIOB, KEYPAD_FALLING}, 	{Default_KeyHandler, TG5R, BIT6, KEYPAD_GPIOB, KEYPAD_RISING}, 	{Default_KeyHandler, TG5P, BIT6, KEYPAD_GPIOB, KEYPAD_PRESSING}, 	{Default_KeyHandler, TG6F, BIT7, KEYPAD_GPIOB, KEYPAD_FALLING}, 	{Default_KeyHandler, TG6R, BIT7, KEYPAD_GPIOB, KEYPAD_RISING}, 	{Default_KeyHandler, TG6P, BIT7, KEYPAD_GPIOB, KEYPAD_PRESSING}, 	{0, 0, 0, 0, 0}  	}; 	const UINT8 g_au8TriggerKeyStateIndex[] = {3,6};
N
N
N//%{CodeGen_Block_End}
N
Nextern void Default_KeyHandler(UINT32 u32Param);
N
N//------------------------------------------------------------------------------------------------//
N// Configurations of Touch Keys
N//------------------------------------------------------------------------------------------------//
N#define TOUCHR		0x10000000
N#define TOUCHF		0x20000000
N#define TOUCHP		0x40000000
N
N// TOUCH1
N#define TOUCH1 		(1)
N#define TOUCH1R		(TOUCH1|TOUCHR)
N#define TOUCH1F		(TOUCH1|TOUCHF)
N#define TOUCH1P		(TOUCH1|TOUCHP)
N// TOUCH2
N#define TOUCH2 		(2)
N#define TOUCH2R		(TOUCH2|TOUCHR)
N#define TOUCH2F		(TOUCH2|TOUCHF)
N#define TOUCH2P		(TOUCH2|TOUCHP)
N// TOUCH3
N#define TOUCH3 		(3)
N#define TOUCH3R		(TOUCH3|TOUCHR)
N#define TOUCH3F		(TOUCH3|TOUCHF)
N#define TOUCH3P		(TOUCH3|TOUCHP)
N// TOUCH4
N#define TOUCH4 		(4)
N#define TOUCH4R		(TOUCH4|TOUCHR)
N#define TOUCH4F		(TOUCH4|TOUCHF)
N#define TOUCH4P		(TOUCH4|TOUCHP)
N// TOUCH5
N#define TOUCH5 		(5)
N#define TOUCH5R		(TOUCH5|TOUCHR)
N#define TOUCH5F		(TOUCH5|TOUCHF)
N#define TOUCH5P		(TOUCH5|TOUCHP)
N// TOUCH6
N#define TOUCH6 		(6)
N#define TOUCH6R		(TOUCH6|TOUCHR)
N#define TOUCH6F		(TOUCH6|TOUCHF)
N#define TOUCH6P		(TOUCH6|TOUCHP)
N	
N#define TOUCH_KEY_COUNT			(0)
N
N#define TOUCH_CLR_CAP_MASK		(SYS_GPB_MFP_PB0MFP_Msk|SYS_GPB_MFP_PB1MFP_Msk|SYS_GPB_MFP_PB2MFP_Msk|SYS_GPB_MFP_PB3MFP_Msk|SYS_GPB_MFP_PB6MFP_Msk|SYS_GPB_MFP_PB7MFP_Msk)
N#define TOUCH_CFG_CAP_MASK		(SYS_GPB_MFP_PB0MFP_CMP0|SYS_GPB_MFP_PB1MFP_CMP1|SYS_GPB_MFP_PB2MFP_CMP2|SYS_GPB_MFP_PB3MFP_CMP3|SYS_GPB_MFP_PB6MFP_CMP6|SYS_GPB_MFP_PB7MFP_CMP7)
N	
N#define TOUCH_KEY_PINS_MASK		(BIT0|BIT1|BIT2|BIT3|BIT6|BIT7)
N	
N#define TOUCH_KEY_HANDLE_COUNT	(18)
N	
N#if( TOUCH_KEY_COUNT > 0 )
X#if( (0) > 0 )
S#define DECLARE_TOUCH_KEY() 								\
SS_KEYPAD_TOUCH_HANDLER const g_asTouchKeyHandler[] =  		\
S{  															\
S	{Default_KeyHandler, TOUCH1F, BIT0, KEYPAD_FALLING},	\
S	{Default_KeyHandler, TOUCH1R, BIT0, KEYPAD_RISING},		\
S	{Default_KeyHandler, TOUCH1P, BIT0, KEYPAD_PRESSING},	\
S	{Default_KeyHandler, TOUCH2F, BIT1, KEYPAD_FALLING},	\
S	{Default_KeyHandler, TOUCH2R, BIT1, KEYPAD_RISING},		\
S	{Default_KeyHandler, TOUCH2P, BIT1, KEYPAD_PRESSING},	\
S	{Default_KeyHandler, TOUCH3F, BIT2, KEYPAD_FALLING},	\
S	{Default_KeyHandler, TOUCH3R, BIT2, KEYPAD_RISING},		\
S	{Default_KeyHandler, TOUCH3P, BIT2, KEYPAD_PRESSING},	\
S	{Default_KeyHandler, TOUCH4F, BIT3, KEYPAD_FALLING},	\
S	{Default_KeyHandler, TOUCH4R, BIT3, KEYPAD_RISING},		\
S	{Default_KeyHandler, TOUCH4P, BIT3, KEYPAD_PRESSING},	\
S	{Default_KeyHandler, TOUCH5F, BIT6, KEYPAD_FALLING},	\
S	{Default_KeyHandler, TOUCH5R, BIT6, KEYPAD_RISING},		\
S	{Default_KeyHandler, TOUCH5P, BIT6, KEYPAD_PRESSING},	\
S	{Default_KeyHandler, TOUCH6F, BIT7, KEYPAD_FALLING},	\
S	{Default_KeyHandler, TOUCH6R, BIT7, KEYPAD_RISING},		\
S	{Default_KeyHandler, TOUCH6P, BIT7, KEYPAD_PRESSING},	\
S	{0,0,0,0}												\
S	}; 														\
S	const UINT8 g_au8TouchKeyStateIndex[] = {0};
X#define DECLARE_TOUCH_KEY() 								S_KEYPAD_TOUCH_HANDLER const g_asTouchKeyHandler[] =  		{  																{Default_KeyHandler, TOUCH1F, BIT0, KEYPAD_FALLING},		{Default_KeyHandler, TOUCH1R, BIT0, KEYPAD_RISING},			{Default_KeyHandler, TOUCH1P, BIT0, KEYPAD_PRESSING},		{Default_KeyHandler, TOUCH2F, BIT1, KEYPAD_FALLING},		{Default_KeyHandler, TOUCH2R, BIT1, KEYPAD_RISING},			{Default_KeyHandler, TOUCH2P, BIT1, KEYPAD_PRESSING},		{Default_KeyHandler, TOUCH3F, BIT2, KEYPAD_FALLING},		{Default_KeyHandler, TOUCH3R, BIT2, KEYPAD_RISING},			{Default_KeyHandler, TOUCH3P, BIT2, KEYPAD_PRESSING},		{Default_KeyHandler, TOUCH4F, BIT3, KEYPAD_FALLING},		{Default_KeyHandler, TOUCH4R, BIT3, KEYPAD_RISING},			{Default_KeyHandler, TOUCH4P, BIT3, KEYPAD_PRESSING},		{Default_KeyHandler, TOUCH5F, BIT6, KEYPAD_FALLING},		{Default_KeyHandler, TOUCH5R, BIT6, KEYPAD_RISING},			{Default_KeyHandler, TOUCH5P, BIT6, KEYPAD_PRESSING},		{Default_KeyHandler, TOUCH6F, BIT7, KEYPAD_FALLING},		{Default_KeyHandler, TOUCH6R, BIT7, KEYPAD_RISING},			{Default_KeyHandler, TOUCH6P, BIT7, KEYPAD_PRESSING},		{0,0,0,0}													}; 															const UINT8 g_au8TouchKeyStateIndex[] = {0};
N#else
N#define DECLARE_TOUCH_KEY() 		
N#endif
N	
N#if ( TOUCH_KEY_HANDLE_COUNT > 0 && TOUCH_KEY_COUNT > 0 )   
X#if ( (18) > 0 && (0) > 0 )   
S#define DECLARE_TOUCH_KEY_BUF()	UINT16 g_u16aTouchPinValueBuf[TOUCH_KEY_HANDLE_COUNT]; 
N#else
N#define DECLARE_TOUCH_KEY_BUF()
N#endif
N
N#if ( TOUCH_KEY_COUNT > 0 )
X#if ( (0) > 0 )
S#define DECLARE_TOUCH_THRESHOLD()							\
SS_KEYPAD_TOUCH_THRESHOLD const KEYPAD_TOUCH_THRESHOLD[]= 	\
S{															\
S	{ 800, 350}, { 1200, 200}, { 750, 300}, { 800, 350},	\
S	{ 800, 350}, { 750, 300}, { 800, 350}, { 1200, 200}		\
S};
X#define DECLARE_TOUCH_THRESHOLD()							S_KEYPAD_TOUCH_THRESHOLD const KEYPAD_TOUCH_THRESHOLD[]= 	{																{ 800, 350}, { 1200, 200}, { 750, 300}, { 800, 350},		{ 800, 350}, { 750, 300}, { 800, 350}, { 1200, 200}		};
N#else
N#define DECLARE_TOUCH_THRESHOLD()
N#endif
N	
N#endif
L 34 "..\App.h" 2
N
Ntypedef struct
N{
N	union
N	{
N		S_NUONEEX_APP_DECODE sNuOneExAppDecode;
N		S_NUONEEX_APP_ENCODE sNuOneExAppEncode;
N	};
N	union
N	{
N		UINT32 u32NuOneDecodeTempBuf[(NUONEEX_DECODE_TEMP_BUF_SIZE+3)/4];
X		UINT32 u32NuOneDecodeTempBuf[((506*2)+3)/4];
N		UINT32 u32NuOneEncodeTempBuf[(NUONEEX_ENCODE_TEMP_BUF_SIZE+3)/4];
X		UINT32 u32NuOneEncodeTempBuf[((551*2)+3)/4];
N	}uTempBuf;
N
N} S_APP;
N
N#endif //#ifndef _APP_H_
N
L 27 "..\AppFunctions.c" 2
N#include "MicSpk.h"
L 1 "..\..\..\..\Library\Framework\inc\MicSpk.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) Nuvoton Technology Corp. All rights reserved.                                              */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __MICSPK_H__
N#define __MICSPK_H__
N
N#include "Platform.h"
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N	
N//---------------------------------------------------------------------------
N// Function: MIC_Open
N//
N// Description:
N// 		Configure ADC pins and mode for MIC recording function
N//
N// Argument:
N// 		none
N//
N// Return:
N//		None.
N//---------------------------------------------------------------------------
Nvoid MIC_Open(void);
N	
N//---------------------------------------------------------------------------
N// Function: MIC_Start
N//
N// Description:
N//		Start ADC to recording from MIC
N//
N// Argument:
N// 		none
N//
N// Return:
N//		none.
N//---------------------------------------------------------------------------
Nvoid MIC_Start(void);
N
N//---------------------------------------------------------------------------
N// Function: MIC_Stop
N//
N// Description:
N//		Start ADC to recording from MIC
N//
N// Argument:
N// 		none
N//
N// Return:
N//		none.
N//---------------------------------------------------------------------------
Nvoid MIC_Stop(void);
N
N//---------------------------------------------------------------------------
N// Function: MIC_Close
N//
N// Description:
N//		Close ADC to record from MIC
N//
N// Argument:
N// 		none
N//
N// Return:
N//		none.
N//---------------------------------------------------------------------------
Nvoid MIC_Close(void);
N	
N//---------------------------------------------------------------------------
N// Function: MIC_ChangeSR
N//
N// Description:
N//		Change the sample rate of MIC recording
N//
N// Argument:
N//		u32SampleRate: wanted sample rate
N//
N// Return:
N//		none 
N//---------------------------------------------------------------------------
Nvoid MIC_ChangeSR(UINT32 u32SampleRate);
N
N
N//---------------------------------------------------------------------------
N// Function: SPK_Open
N//
N// Description:
N// 		Configure APU mode for speaker 
N//
N// Argument:
N// 		none
N//
N// Return:
N//		None.
N//---------------------------------------------------------------------------
Nvoid SPK_Open(void);
N
N//---------------------------------------------------------------------------
N// Function: SPK_Close
N//
N// Description:
N// 		Close APU operation for speaker 
N//
N// Argument:
N// 		none
N//
N// Return:
N//		None.
N//---------------------------------------------------------------------------
Nvoid SPK_Close(void);
N
Nvoid SPK_Start(void);
Nvoid SPK_Stop(void);
N
N//---------------------------------------------------------------------------
N// Function: SPK_ChangeSR
N//
N// Description:
N//		Change the sample rate of Speaker
N//
N// Argument:
N//		u32SampleRate: wanted sample rate
N//
N// Return:
N//		none 
N//---------------------------------------------------------------------------
Nvoid SPK_ChangeSR(UINT32 u32Channel, UINT32 u32SampleRate);
N
N//---------------------------------------------------------------------------
N// Function: SPK_Pause
N//
N// Description:
N// 		Pause APU operation to output to speaker 
N//
N// Argument:
N// 		none
N//
N// Return:
N//		None.
N//---------------------------------------------------------------------------
Nvoid SPK_Pause(UINT32 u32Channel);
N
N//---------------------------------------------------------------------------
N// Description:
N// 		Resume APU operation to output to speaker 
N//
N// Argument:
N// 		none
N//
N// Return:
N//		None.
N//---------------------------------------------------------------------------
Nvoid SPK_Resume(UINT32 u32Channel);
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif //__MICSPK_H__
L 28 "..\AppFunctions.c" 2
N#include "SPIFlashUtil.h"
L 1 "..\..\..\..\Library\Framework\inc\SPIFlashUtil.h" 1
N#ifndef _SPIFLASHUTIL_H_
N#define _SPIFLASHUTIL_H_
N#include "Platform.h"
N#include "BufCtrl.h"
N#include "AudioCommon.h"
N#include "SPIFlash.h"
N
Ntypedef BOOL (*PFN_SPIFLASHUTIL_WRITE_CALLBACK)( void );
N// -------------------------------------------------------------------------------------------------------------------
N// Funcitons to write encoded data as a encode audio file to SPI flash with 4K page earsing capibility
N// The function calling sequences are:
N//
N// SPIFlahUtil_StartWriteEncodeData()
N//		|
N//		+---------------------------+
N//		V                           |
N// SPIFlashUtil_WriteEncodeData()---+
N//		|
N//		V
N// SPIFlashUtil_EndWriteEncodeData()
N//
N
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Initiate 4k page partial write and write header to SPI flash before writing encoded data
N//
N//	Parameter
N//		psAudioChunkHeader[in] :
N//			Address of audio file header which must be written first before start writing encode data
N//
N//  	u32StorageStartAddr[in] :
N//		The storage start address of the audio file header.
N//
N//  	pfnSpiFlashWriteCallbck[in] :
N//			The function to be execute at checking SPI flash is ready.
N//			This can let other function be be executed before writing data to SPI flash.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid SPIFlahUtil_StartWriteEncodeData(S_AUDIOCHUNK_HEADER *psAudioChunkHeader, 
N	UINT32 u32StorageStartAddr, PFN_SPIFLASHUTIL_WRITE_CALLBACK pfnSpiFlashWriteCallbck);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Write encoded data to SPI flash.
N//
N//		The writing function will check the buffer control.
N//		If there are data, this funtion will write to SPI flash.
N//		This function will not wait SPI flash from busy to ready, in order to save the waiting busy time!
N//
N//	Parameter
N//  	psEncodeBufCtrl[in] :
N//			Address of buffer control which record buffer read and write status.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid SPIFlashUtil_WriteEncodeData(S_BUF_CTRL *psEncodeBufCtrl);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Wait for last encoded data written to SPIFlash and
N//		update the header written in calling "SPIFlashUtil_StartWriteEncodeData()"
N//
N//	Parameter
N//		None
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid SPIFlashUtil_EndWriteEncodeData(void);
N// -------------------------------------------------------------------------------------------------------------------
N
N
N// -------------------------------------------------------------------------------------------------------------------
N// Funcitons to write data to SPI flash with 4K page earsing capibility
N// The function calling sequences are:
N//
N// SPIFlashUtil_4KPagePartialWriteInitiate()
N//		|
N//		V
N// SPIFlashUtil_4KPagePartialWriteStart()
N//		|
N//		+-------------------------------------------------+
N//		|                                                 |
N//		+--------------------------------------------+    |
N//		V                                            |    |
N// SPIFlashUtil_4KPagePartialWriting(): return TRUE -+    |
N//		|               |                                 |
N//      |            return TRUE                          |
N//		|               |                                 |
N//		|               +---------------------------------+
N//		|
N//		V
N// SPIFlashUtil_4KPagePartialWritWaitComplete()
N//
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Initiate the 4k page partial write without waiting completed.
N//		The 1st 4k page will     be erased if the start address is     4K alignment.
N//		The 1st 4k page will not be erased if the start address is not 4K alignment.
N//
N//	Parameter
N//  	u32StorageStartAddr[in] :
N//		The storage start address of the write data.
N//
N//  	pfnSpiFlashWriteCallbck[in] :
N//			The function to be execute at checking SPI flash is ready.
N//			This can let other function be be executed before writing data to SPI flash.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid SPIFlashUtil_4KPagePartialWriteInitiate(UINT32 u32Start4kPageAddr, PFN_SPIFLASHUTIL_WRITE_CALLBACK pfnSpiFlashWriteCallbck);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Prepare and start write data to SPI flash without waiting completed.
N//
N//		This funciton will keep address of  data and the size of data.
N//		The data will be writting to SPI flash at calling SPIFlashUtil_4KPagePartialWriting().
N//		Before the SPIFlashUtil_4KPagePartialWriting() return FALSE, the data can not be changed.
N//
N//	Parameter
N//  	pau8Data[in] :
N//			pointer of write data.
N//			The data will be writting to SPI flash at calling SPIFlashUtil_4KPagePartialWriting().
N//			Before the SPIFlashUtil_4KPagePartialWriting() return FALSE, the data should not be changed.
N//
N//  	u32DataSize[in] :
N//			the size of write data.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid SPIFlashUtil_4KPagePartialWriteStart(UINT8 *pau8Data, UINT32 u32DataSize);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Check previous written completed and write data to SPI flash without waiting completed.
N//		This function must be called until it return FALSE.
N//		
N//		At this funciton return FALSE, there are 2 condition to go on:
N//		1. End written:			call "SPIFlashUtil_4KPagePartialWritWaitComplete()" 
N//		2. Continue to write:	call "SPIFlashUtil_4KPagePartialWriteStart())"
N//
N//	Parameter
N//		none
N//
N//	Return Value
N//		TRUE:
N//			the SPI flash is in busy or there are data must be written
N//		FALSE:
N//			write data completed but SPI flash maybe in the busy state
N//---------------------------------------------------------------------------------------------------------
NBOOL SPIFlashUtil_4KPagePartialWriting(void);
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Wait SPI flash to complete writing the last data sent in the last SPIFlashUtil_4KPagePartialWriting() call.
N//		
N//		Becasue SPIFlashUtil_4KPagePartialWriting() send the last write data to SPI flash but not wait SPI flash to be
N//		ready. Therfore 
N//		
N//		At this funciton return FALSE, there are 2 condition to go on:
N//		1. End written:			call "SPIFlashUtil_4KPagePartialWritWaitComplete()" 
N//		2. Continue to write:	call "SPIFlashUtil_4KPagePartialWriteStart())"
N//
N//	Parameter
N//		none
N//
N//	Return Value
N//		TRUE:
N//			there are data writting and the SPI flash is in busy
N//		FALSE:
N//			write data completed but SPI flash maybe in the busy state
N//---------------------------------------------------------------------------------------------------------
N#define SPIFlashUtil_4KPagePartialWritWaitComplete()	while( SPIFlashUtil_4KPagePartialWriting() == TRUE )
N	
N
N//---------------------------------------------------------------------------------------------------------
N//	Description
N//		Write data and wait SPI flash to be ready.
N//
N//	Parameter
N//  	pau8Data[in] :
N//			pointer of write data.
N//			The data will be writting to SPI flash at calling SPIFlashUtil_4KPagePartialWriting().
N//			Before the SPIFlashUtil_4KPagePartialWriting() return FALSE, the data should not be changed.
N//
N//  	u32DataSize[in] :
N//			the size of write data.
N//
N//	Return Value
N//		None
N//---------------------------------------------------------------------------------------------------------
Nvoid SPIFlashUtil_4KPagePartialWriteWithWait(UINT8 *pau8WriteData, UINT32 u32WriteDataCount);
N
N
N#endif
L 29 "..\AppFunctions.c" 2
N# include "stdio.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 192842 $
N * Checkin $Date: 2015-04-28 10:58:32 +0100 (Tue, 28 Apr 2015) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060002
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 30 "..\AppFunctions.c" 2
N
Nextern UINT8 SPIFlash_Initiate(void);
N
Nextern void PowerDown_Enter(void);
N
Nextern void PowerDown(void);
N
Nextern void PowerDown_Exit(void);
N
Nextern S_APP g_sApp;
N
Nextern volatile UINT8 g_adcVR2volume;
N
Nextern volatile BOOL playEndStatus;
N
Nextern volatile BOOL recEndStatus;
N
Nextern volatile UINT8 g_u8AppCtrl;
N
Nextern UINT32 g_u32SPIFlashRecAddr;	// Current recoding address in SPIFlash.
N
Nextern S_SPIFLASH_HANDLER g_sSpiFlash; 
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_Initiate
N//
N// Description:
N//	Initiate application.
N//
N// Argument:
N//
N// Return:
N//
N//---------------------------------------------------------------------------------------------------------
Nvoid App_Initiate(void)
N{
N	g_u8AppCtrl = APPCTRL_NO_ACTION;
X	g_u8AppCtrl = 0;
N	
N	// Initiate the audio playback.
N	Playback_Initiate();
N	
N	// Configure the UltraIO curve output funciton's interrupt priority.
N	// Lower this priority if other interrupt services should be higher than UltraIO curve output function!
N	#if ( ULTRAIO_FW_CURVE_ENABLE )
X	#if ( (0) )
S	NVIC_SetPriority(ULTRAIO_TMR_IRQ, 1);
N	#endif	
N	
N	// Light stand by(PB8) led for initial ready().
N	OUT3(0);
X	OutputPin_Set(((GPIO_T *) (((( uint32_t)0x50000000) + 0x04000) )),0x00004000,0);
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_StartPlay
N//
N// Description:                                                                                           
N//	Start audio playback.
N//
N// Return:
N// 	FALSE: fail
N//	TRUE:  success
N//---------------------------------------------------------------------------------------------------------
NBOOL App_StartPlay(void)
N{	
N	//this parameter is to prevent faulty when playing
N	playEndStatus = FALSE;
X	playEndStatus = 0;
N	
N	// Initiate NuOneEx audio decode lib with callback functions stored in g_asAppCallBack[0].
N	NuOneExApp_DecodeInitiate(&g_sApp.sNuOneExAppDecode, (UINT8 *)&g_sApp.uTempBuf, 0);
N	
N	// Start NuOneEx decode lib to decode NuOneEx file stored from "sAudioChunkInfo.u32AudioChunkAddr"
N	// And decode the first frame of PCMs.
N	if ( NuOneExApp_DecodeStartPlayByAddr(&g_sApp.sNuOneExAppDecode, AUDIOROM_STORAGE_START_ADDR, 0) == 0)
X	if ( NuOneExApp_DecodeStartPlayByAddr(&g_sApp.sNuOneExAppDecode, (1024*1024), 0) == 0)
N		return FALSE;
X		return 0;
N	
N	// Light playback led(PB4) for display status.
N	OUT5(1);
X	OutputPin_Set(((GPIO_T *) (((( uint32_t)0x50000000) + 0x04000) + 0x00040)),0x00000010,1);
N	
N	// Start Ultraio Timer & HW pwm for UltraIO curve output
N	ULTRAIO_START();
X	;
N	
N	// Start to playback audio. 
N	Playback_StartPlay();
N
N	return TRUE;
X	return 1;
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Description:                                                                                            
N//	Stop audio playback.                                                                             
N//
N// Return:
N// 	FALSE: fail
N//	TRUE:  success
N//---------------------------------------------------------------------------------------------------------
NBOOL App_StopPlay(void)
N{
N	// Stop speaker.
N	Playback_StopPlay();
N	
N	// Stop Ultraio Timer & HW pwm.
N	ULTRAIO_STOP();
X	;
N
N	OUT5(0);
X	OutputPin_Set(((GPIO_T *) (((( uint32_t)0x50000000) + 0x04000) + 0x00040)),0x00000010,0);
N	CLK_SysTickDelay(200000);  // Delay us
N	OUT5(1);	
X	OutputPin_Set(((GPIO_T *) (((( uint32_t)0x50000000) + 0x04000) + 0x00040)),0x00000010,1);	
N
N	//this parameter is to prevent faulty when playing
N	playEndStatus = TRUE;
X	playEndStatus = 1;
N	
N	return TRUE;
X	return 1;
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_StartRec
N//
N// Description:                                                                                           
N//	Record PCM data from MIC.
N//
N// Return:
N// 	FALSE: fail
N//	TRUE:  success
N//---------------------------------------------------------------------------------------------------------
NBOOL App_StartRec(void)
N{	
N	S_AUDIOCHUNK_HEADER sAudioChunkHeader;
N
N	// Initiate NuOneEx audio encode lib with temp buffer provided for lib.
N	NuOneExApp_EncodeInitiate(&g_sApp.sNuOneExAppEncode, (UINT8 *)&g_sApp.uTempBuf);
N	
N	// Start to encode NuOneEx data with sample rate, bit per frame and saved data information into audio chunk header.
N	if (NuOneExApp_EncodeStart(&g_sApp.sNuOneExAppEncode, &sAudioChunkHeader, ADC_SAMPLE_RATE, E_NUONEEX_ENCODE_BPS_10) == FALSE)
X	if (NuOneExApp_EncodeStart(&g_sApp.sNuOneExAppEncode, &sAudioChunkHeader, (12000), E_NUONEEX_ENCODE_BPS_10) == 0)
N		return FALSE;
X		return 0;
N	
N	// SPIFlash utility function provide encode data write into SPIFlash.
N	// detail info please refer "SPIFlashUtil.h"
N	SPIFlahUtil_StartWriteEncodeData(&sAudioChunkHeader, AUDIOROM_STORAGE_START_ADDR, NULL);
X	SPIFlahUtil_StartWriteEncodeData(&sAudioChunkHeader, (1024*1024), 0);
N	
N	// Light record led for display status.
N	OUT5(0);
X	OutputPin_Set(((GPIO_T *) (((( uint32_t)0x50000000) + 0x04000) + 0x00040)),0x00000010,0);
N	
N	//this parameter is to prevent faulty when recording
N	recEndStatus = FALSE;
X	recEndStatus = 0;
N	
N	// Start to record PCM data into buffer for produc NuOneEx encode data.
N	Record_StartRec();
N	
N	return TRUE;
X	return 1;
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Description:                                                                                            
N//	Stop to record PCM data.                                                                             
N//
N// Return:
N// 	FALSE: fail
N//	TRUE:  success
N//---------------------------------------------------------------------------------------------------------
Nvoid App_StopRec(void)
N{
N	// Stop mic.
N	Record_StopRec();
N	
N	// Stop to NuOneEx encode process.
N	NuOneExApp_EncodeEnd(&g_sApp.sNuOneExAppEncode);
N	
N	// Write audio chunk header(encode data length) into SPIFlash.
N	SPIFlashUtil_EndWriteEncodeData();
N
N	OUT5(1);	
X	OutputPin_Set(((GPIO_T *) (((( uint32_t)0x50000000) + 0x04000) + 0x00040)),0x00000010,1);	
N
N	//this parameter is to prevent faulty when recording
N	recEndStatus = TRUE;		
X	recEndStatus = 1;		
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_ProcessPlay
N//
N// Description:                                                                                            
N//   Produce PCM data for audio playback
N//
N// Return:
N//	FALSE: No PCM produced for audio playback
N//	TRUE:  Have PCMs produced for audio playback                                      
N//---------------------------------------------------------------------------------------------------------
NBOOL App_ProcessPlay(void)
N{
N	UINT8 u8ActiveProcessCount = 0;
N	
N	// Continue decode NuOneEx data to produce PCMs for audio playback.
N	if ( NuOneExApp_DecodeProcess(&g_sApp.sNuOneExAppDecode) == TRUE )
X	if ( NuOneExApp_DecodeProcess(&g_sApp.sNuOneExAppDecode) == 1 )
N		u8ActiveProcessCount ++;
N
N	if ( u8ActiveProcessCount )
N		return TRUE;
X		return 1;
N
N	return FALSE;
X	return 0;
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_ProcessRec
N//
N// Description:                                                                                            
N//   Record PCM data for providing Beat-detect.
N//
N// Return:
N//	FALSE: No PCM produced for audio playback
N//	TRUE:  Have PCMs produced for audio playback                                      
N//---------------------------------------------------------------------------------------------------------
NBOOL App_ProcessRec(void)
N{
N	// Write NuOneEx encode data into SPIFlash.
N	SPIFlashUtil_WriteEncodeData(&g_sApp.sNuOneExAppEncode.sEncodeBufCtrl);
N
N	// Check current record address is out size of SPIFlash.
N	if (g_u32SPIFlashRecAddr >= g_sSpiFlash.u32FlashSize)
N		return FALSE;	
X		return 0;	
N
N	// Keep encode PCM buffer data to NuOneEx lib.
N	NuOneExApp_EncodeProcess(&g_sApp.sNuOneExAppEncode);
N	
N	return TRUE;
X	return 1;
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_PowerDown
N//
N// Description:                                                                                            
N//   Process flow of power-down for application. Include,
N//   1. App_PowerDownProcess:Pre-process befor entering power-down.
N//   2. PowerDown:Power down base process(PowerDown.c).
N//   3. App_WakeUpProcess:Post-process after exiting power-down.
N//   User could disable or enable this flow from flag(POWERDOWN_ENABLE) in ConfigApp.h.
N//---------------------------------------------------------------------------------------------------------
Nvoid App_PowerDown(void)
N{
N	App_StopPlay();
N	App_StopRec();
N	
N	#if(POWERDOWN_ENABLE)
X	#if(((1)|(0)|(0)))
N	PowerDown_Enter();
N	PowerDown();
N	PowerDown_Exit();
N	#endif
N}
N
N//---------------------------------------------------------------------------------------------------------
N// Function: App_ReadVR
N//
N// Description:                                                                                            
N//   ADC read potentiometer and set speaker Volume
N//---------------------------------------------------------------------------------------------------------
Nvoid App_ReadVRInit(void)
N{
N	uint32_t u32Div;
N	
N	/* Reset IP */
N	CLK_EnableModuleClock(ADC_MODULE);
X	CLK_EnableModuleClock(((1UL<<30)|(0<<28)|(0x0<<25)|( 0<<20)|(0<<18)|( 0xFF<<10)|(16<<5)|(28)));
N	CLK_EnableModuleClock(ANA_MODULE);
X	CLK_EnableModuleClock(((1UL<<30)|(0<<28)|(0x0<<25)|( 0<<20)|(0<<18)|(0x0<<10)|( 0<<5)|(30)));
N    SYS_ResetModule(EADC_RST);
X    SYS_ResetModule(((0x4<<24) | (28) ));
N	SYS_ResetModule(ANA_RST);
X	SYS_ResetModule(((0x4<<24) | (30) ));
N	
N	/* Enable Analog block power */
N	ADC_ENABLE_SIGNALPOWER(ADC,
N	                       ADC_SIGCTL_ADCMOD_POWER|
N						   ADC_SIGCTL_IBGEN_POWER|
N	                       ADC_SIGCTL_BUFADC_POWER|
N	                       ADC_SIGCTL_BUFPGA_POWER);
X	(((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->SIGCTL = (((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->SIGCTL&(~0x1F))|(((0x1ul << (4)))| ((0x1ul << (3)))| ((0x1ul << (2)))| ((0x1ul << (1)))&(0x1F)));
N	
N	/* PGA Setting */
N	ADC_MUTEON_PGA(ADC, ADC_SIGCTL_MUTE_PGA);
X	(((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->SIGCTL |= (((0x1ul << (5)))&((0x1ul << (5))|(0x1ul << (6)))));
N	ADC_MUTEOFF_PGA(ADC, ADC_SIGCTL_MUTE_IPBOOST);
X	(((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->SIGCTL &= ~(((0x1ul << (6)))&((0x1ul << (5))|(0x1ul << (6)))));
N
N	ADC_ENABLE_PGA(ADC, ADC_PGACTL_REFSEL_VMID, ADC_PGACTL_BOSST_GAIN_0DB);
X	(((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->PGACTL = (((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->PGACTL&~((0x1ul << (3))|(0x1ul << (0))))|((0x1ul << (1))|(0x1ul << (2))|(0x0ul << (0))|(0x0ul << (3))));
N	ADC_SetPGAGaindB(0); // system default 600dB   
N
N
N	/* MIC circuit configuration */
N	ADC_ENABLE_VMID(ADC, ADC_VMID_HIRES_DISCONNECT, ADC_VMID_LORES_CONNECT);
X	(((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->VMID = (0x0|(0x1ul << (2))|(0x0ul << (1))));
N	ADC_EnableMICBias(ADC_MICBSEL_90_VCCA);
X	ADC_EnableMICBias(((0x0ul << (2))|0x0));
N	ADC_SetAMUX(ADC_MUXCTL_MIC_PATH, ADC_MUXCTL_POSINSEL_NONE, ADC_MUXCTL_NEGINSEL_NONE);
X	ADC_SetAMUX(((0x1ul << (13))), (0x0ul << (8)), (0x00ul << (0)));
N	
N	/* Open ADC block */
N	ADC_Open();
N	ADC_SET_OSRATION(ADC, ADC_OSR_RATION_192);
X	(((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->DCICTL = (((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->DCICTL&(~(0xful << (0))))|(2&0xf));
N	u32Div = CLK_GetHIRCFreq()/ADC_SAMPLE_RATE/192;
X	u32Div = CLK_GetHIRCFreq()/(12000)/192;
N	ADC_SET_SDCLKDIV(ADC, u32Div);
X	(((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->CLKDIV = (u32Div&0xff));
N	ADC_SET_FIFOINTLEVEL(ADC, 7);
X	(((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->INTCTL = (((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->INTCTL&(~(0x7ul << (0))))|(7&0x7));
N	
N	ADC_MUTEOFF_PGA(ADC, ADC_SIGCTL_MUTE_PGA);
X	(((ANA_T *) ((( uint32_t)0x40000000) + 0x80000))->SIGCTL &= ~(((0x1ul << (5)))&((0x1ul << (5))|(0x1ul << (6)))));
N	
N}
N
N
Nvoid App_ReadVR()
N{
N    //uint32_t u32ConversionDatas[16];
N	uint32_t u32ConversionData;
N	uint8_t j;    
N    
N	printf("\n\n=== ADC single mode test ===\n");
N	
N	/* Init ADC */
N	App_ReadVRInit();
N				
N    ADC_SetGPIOChannel(ADC_GPIO_SINGLEEND_CH5_N);
X    ADC_SetGPIOChannel(((0x00000020 << 12) | (0x20ul << (0)) | (0x0ul << (8))));
N            
N    // Enable ADC Interrupt function
N    ADC_EnableInt(ADC_FIFO_INT);
X    ADC_EnableInt((1));
N
N    // Start A/D conversion 
N    ADC_START_CONV(ADC);
X    (((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->CHEN = (0x1ul << (0)));
N
N    // Wait ADC interrupt 
N    while(ADC_GetIntFlag(ADC_FIFO_INT));
X    while(ADC_GetIntFlag((1)));
N			//while(1){
N    for(j=0;j<=16;j++) {
N        u32ConversionData = ADC_GET_FIFODATA(ADC);
X        u32ConversionData = (((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->DAT&0xffff);
N        CLK_SysTickDelay(500);
N    }
N	
N    g_adcVR2volume = u32ConversionData/4000;
N    printf(" everage = (%ul)\n", g_adcVR2volume);
N	
N	// stop A/D conversion 
N    ADC_STOP_CONV(ADC);
X    (((ADC_T*) ((( uint32_t)0x40000000) + 0xE0000))->CHEN = ~(0x1ul << (0)));
N		
N	CLK_SysTickDelay(100000);
N
N	//Init MIC 
N
N	//SYSCLK_INITIATE();				// Configure CPU clock source and operation clock frequency.
N									// The configuration functions are in "SysClkConfig.h"
N	
N	CLK_EnableLDO(CLK_LDOSEL_3_3V);	// Enable ISD9100 interl 3.3 LDO.
X	CLK_EnableLDO((0x3ul<<(0)));	
N	
N//	if (! SPIFlash_Initiate())		// Initiate SPI interface and checking flows for accessing SPI flash.
N//		while(1); 					// loop here for easy debug
N
N	SPK_INITIATE();					// Initiate speaker including pop-sound canceling.
X	SPK_Open();					
N									// After initiation, the APU is paused.
N									// Use SPK_Resume(0) to start APU operation.
N									// Reference "MicSpk.h" for speaker related APIs.
N
N	MIC_INITIATE();					// Initiate MIC.
X	MIC_Open();					
N									// After initiation, the ADC is paused.
N									// Use ADC_Resume() to start ADC operation.
N									// Reference "MicSpk.h" for MIC related APIs.
N	
N																	
N	//App_Initiate();					// Initiate application for audio decode.			
N
N//	Playback_SetVolumeDB(0, PLAYBACK_VOLUME_10_DB);   // added bylambor
N	
N}
N
N
