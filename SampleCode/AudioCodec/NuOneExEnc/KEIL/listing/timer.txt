; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\timer.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\timer.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\timer.crf ..\..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;72       */
;;;73     void TIMER_Close(TMR_T *timer)
000000  2100              MOVS     r1,#0
;;;74     {
;;;75         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;76     }
000004  4770              BX       lr
;;;77     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;85       */
;;;86     void TIMER_Delay(TMR_T *timer, uint32_t u32Usec)
000000  b5f0              PUSH     {r4-r7,lr}
;;;87     {
000002  b087              SUB      sp,sp,#0x1c
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;88         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       TIMER_GetModuleClock
00000e  4604              MOV      r4,r0
;;;89         uint32_t u32Prescale = 0, delay = SystemCoreClock / u32Clk + 1;
000010  2000              MOVS     r0,#0
000012  9005              STR      r0,[sp,#0x14]
000014  4621              MOV      r1,r4
000016  4830              LDR      r0,|L2.216|
000018  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001a  f7fffffe          BL       __aeabi_uidivmod
00001e  1c40              ADDS     r0,r0,#1
000020  9004              STR      r0,[sp,#0x10]
;;;90         double fCmpr;
;;;91     
;;;92         // Clear current timer configuration
;;;93         timer->CTL = 0;
000022  2000              MOVS     r0,#0
000024  6028              STR      r0,[r5,#0]
;;;94     
;;;95         if(u32Clk == 10000) {         // min delay is 100us if timer clock source is LIRC 10k
000026  482d              LDR      r0,|L2.220|
000028  4284              CMP      r4,r0
00002a  d108              BNE      |L2.62|
;;;96             u32Usec = ((u32Usec + 99) / 100) * 100;
00002c  2164              MOVS     r1,#0x64
00002e  4630              MOV      r0,r6
000030  3063              ADDS     r0,r0,#0x63
000032  f7fffffe          BL       __aeabi_uidivmod
000036  2164              MOVS     r1,#0x64
000038  4348              MULS     r0,r1,r0
00003a  4606              MOV      r6,r0
00003c  e007              B        |L2.78|
                  |L2.62|
;;;97         } else {    // 10 usec every step
;;;98             u32Usec = ((u32Usec + 9) / 10) * 10;
00003e  210a              MOVS     r1,#0xa
000040  4630              MOV      r0,r6
000042  3009              ADDS     r0,r0,#9
000044  f7fffffe          BL       __aeabi_uidivmod
000048  210a              MOVS     r1,#0xa
00004a  4348              MULS     r0,r1,r0
00004c  4606              MOV      r6,r0
                  |L2.78|
;;;99         }
;;;100    
;;;101        if(u32Clk >= 0x4000000) {
00004e  2001              MOVS     r0,#1
000050  0680              LSLS     r0,r0,#26
000052  4284              CMP      r4,r0
000054  d303              BCC      |L2.94|
;;;102            u32Prescale = 7;    // real prescaler value is 8
000056  2007              MOVS     r0,#7
000058  9005              STR      r0,[sp,#0x14]
;;;103            u32Clk >>= 3;
00005a  08e4              LSRS     r4,r4,#3
00005c  e00e              B        |L2.124|
                  |L2.94|
;;;104        } else if(u32Clk >= 0x2000000) {
00005e  2001              MOVS     r0,#1
000060  0640              LSLS     r0,r0,#25
000062  4284              CMP      r4,r0
000064  d303              BCC      |L2.110|
;;;105            u32Prescale = 3;    // real prescaler value is 4
000066  2003              MOVS     r0,#3
000068  9005              STR      r0,[sp,#0x14]
;;;106            u32Clk >>= 2;
00006a  08a4              LSRS     r4,r4,#2
00006c  e006              B        |L2.124|
                  |L2.110|
;;;107        } else if(u32Clk >= 0x1000000) {
00006e  2001              MOVS     r0,#1
000070  0600              LSLS     r0,r0,#24
000072  4284              CMP      r4,r0
000074  d302              BCC      |L2.124|
;;;108            u32Prescale = 1;    // real prescaler value is 2
000076  2001              MOVS     r0,#1
000078  9005              STR      r0,[sp,#0x14]
;;;109            u32Clk >>= 1;
00007a  0864              LSRS     r4,r4,#1
                  |L2.124|
;;;110        }
;;;111    
;;;112        // u32Usec * u32Clk might overflow if using uint32_t
;;;113        fCmpr = (u32Usec/1000) * (u32Clk/1000);
00007c  217d              MOVS     r1,#0x7d
00007e  00c9              LSLS     r1,r1,#3
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       __aeabi_uidivmod
000086  4607              MOV      r7,r0
000088  217d              MOVS     r1,#0x7d
00008a  00c9              LSLS     r1,r1,#3
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  4347              MULS     r7,r0,r7
000094  4638              MOV      r0,r7
000096  9701              STR      r7,[sp,#4]
000098  f7fffffe          BL       __aeabi_ui2d
00009c  9103              STR      r1,[sp,#0xc]
00009e  9002              STR      r0,[sp,#8]
;;;114    
;;;115        timer->CMP = (uint32_t)fCmpr;
0000a0  9903              LDR      r1,[sp,#0xc]
0000a2  9802              LDR      r0,[sp,#8]
0000a4  f7fffffe          BL       __aeabi_d2uiz
0000a8  6068              STR      r0,[r5,#4]
;;;116        timer->CTL = TMR_CTL_CNTEN_Msk | u32Prescale; // one shot mode
0000aa  2101              MOVS     r1,#1
0000ac  0789              LSLS     r1,r1,#30
0000ae  9805              LDR      r0,[sp,#0x14]
0000b0  4308              ORRS     r0,r0,r1
0000b2  6028              STR      r0,[r5,#0]
;;;117    
;;;118        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;119        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;120        for(; delay > 0; delay--) {
0000b4  e003              B        |L2.190|
                  |L2.182|
;;;121            __NOP();
0000b6  bf00              NOP      
0000b8  9804              LDR      r0,[sp,#0x10]         ;120
0000ba  1e40              SUBS     r0,r0,#1              ;120
0000bc  9004              STR      r0,[sp,#0x10]         ;120
                  |L2.190|
0000be  9804              LDR      r0,[sp,#0x10]         ;120
0000c0  2800              CMP      r0,#0                 ;120
0000c2  d1f8              BNE      |L2.182|
;;;122        }
;;;123    
;;;124        while(timer->CTL & TMR_CTL_ACTSTS_Msk);
0000c4  bf00              NOP      
                  |L2.198|
0000c6  6828              LDR      r0,[r5,#0]
0000c8  2101              MOVS     r1,#1
0000ca  0649              LSLS     r1,r1,#25
0000cc  4008              ANDS     r0,r0,r1
0000ce  2800              CMP      r0,#0
0000d0  d1f9              BNE      |L2.198|
;;;125    }
0000d2  b007              ADD      sp,sp,#0x1c
0000d4  bdf0              POP      {r4-r7,pc}
;;;126    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L2.216|
                          DCD      SystemCoreClock
                  |L2.220|
                          DCD      0x00002710

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;132      */
;;;133    uint32_t TIMER_GetModuleClock(TMR_T *timer)
000000  b530              PUSH     {r4,r5,lr}
;;;134    {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
;;;135        uint32_t u32Src;
;;;136        const uint32_t au32Clk[] = {__LIRC, __LXT, 0, 0, __HIRC};
000006  2214              MOVS     r2,#0x14
000008  4912              LDR      r1,|L3.84|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;137    
;;;138        if(timer == TIMER0)
000010  4811              LDR      r0,|L3.88|
000012  4285              CMP      r5,r0
000014  d106              BNE      |L3.36|
;;;139            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
000016  4811              LDR      r0,|L3.92|
000018  6940              LDR      r0,[r0,#0x14]
00001a  2107              MOVS     r1,#7
00001c  0209              LSLS     r1,r1,#8
00001e  4008              ANDS     r0,r0,r1
000020  0a04              LSRS     r4,r0,#8
000022  e00d              B        |L3.64|
                  |L3.36|
;;;140        else if(timer == TIMER1)
000024  480c              LDR      r0,|L3.88|
000026  3020              ADDS     r0,r0,#0x20
000028  4285              CMP      r5,r0
00002a  d106              BNE      |L3.58|
;;;141            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
00002c  480b              LDR      r0,|L3.92|
00002e  6940              LDR      r0,[r0,#0x14]
000030  2107              MOVS     r1,#7
000032  0309              LSLS     r1,r1,#12
000034  4008              ANDS     r0,r0,r1
000036  0b04              LSRS     r4,r0,#12
000038  e002              B        |L3.64|
                  |L3.58|
;;;142    	else
;;;143    		return 0;
00003a  2000              MOVS     r0,#0
                  |L3.60|
;;;144    
;;;145        if(u32Src == 2) 
;;;146            return(SystemCoreClock);
;;;147    
;;;148        return(au32Clk[u32Src]);
;;;149    }
00003c  b005              ADD      sp,sp,#0x14
00003e  bd30              POP      {r4,r5,pc}
                  |L3.64|
000040  2c02              CMP      r4,#2                 ;145
000042  d102              BNE      |L3.74|
000044  4806              LDR      r0,|L3.96|
000046  6800              LDR      r0,[r0,#0]            ;146  ; SystemCoreClock
000048  e7f8              B        |L3.60|
                  |L3.74|
00004a  00a0              LSLS     r0,r4,#2              ;148
00004c  4669              MOV      r1,sp                 ;148
00004e  5808              LDR      r0,[r1,r0]            ;148
000050  e7f4              B        |L3.60|
;;;150    /**
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
                          DCD      ||.constdata||
                  |L3.88|
                          DCD      0x40010000
                  |L3.92|
                          DCD      0x50000200
                  |L3.96|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_GetWorkingFreq||, CODE, READONLY, ALIGN=1

                  TIMER_GetWorkingFreq PROC
;;;154      */
;;;155    uint32_t TIMER_GetWorkingFreq(TMR_T *timer)
000000  b570              PUSH     {r4-r6,lr}
;;;156    {
000002  4604              MOV      r4,r0
;;;157        return TIMER_GetModuleClock(timer)/((timer->CMP)*((timer->CTL&TMR_CTL_PSC_Msk)+1));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4605              MOV      r5,r0
00000c  6860              LDR      r0,[r4,#4]
00000e  6822              LDR      r2,[r4,#0]
000010  b2d2              UXTB     r2,r2
000012  1c52              ADDS     r2,r2,#1
000014  4350              MULS     r0,r2,r0
000016  4601              MOV      r1,r0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       __aeabi_uidivmod
;;;158    }
00001e  bd70              POP      {r4-r6,pc}
;;;159    
                          ENDP


                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;38       */
;;;39     uint32_t TIMER_Open(TMR_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5fe              PUSH     {r1-r7,lr}
;;;40     {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;41         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       TIMER_GetModuleClock
00000e  4604              MOV      r4,r0
;;;42         uint32_t u32Cmpr = 0, u32Prescale = 0;
000010  2000              MOVS     r0,#0
000012  9001              STR      r0,[sp,#4]
000014  9000              STR      r0,[sp,#0]
;;;43     
;;;44         // Fastest possible timer working freq is u32Clk / 2. While cmpr = 2, pre-scale = 0
;;;45         if(u32Freq > (u32Clk / 2)) {
000016  0860              LSRS     r0,r4,#1
000018  42b0              CMP      r0,r6
00001a  d202              BCS      |L5.34|
;;;46             u32Cmpr = 2;
00001c  2002              MOVS     r0,#2
00001e  9001              STR      r0,[sp,#4]
000020  e01b              B        |L5.90|
                  |L5.34|
;;;47         } else {
;;;48             if(u32Clk >= 0x4000000) {
000022  2001              MOVS     r0,#1
000024  0680              LSLS     r0,r0,#26
000026  4284              CMP      r4,r0
000028  d303              BCC      |L5.50|
;;;49                 u32Prescale = 7;    // real prescaler value is 8
00002a  2007              MOVS     r0,#7
00002c  9000              STR      r0,[sp,#0]
;;;50                 u32Clk >>= 3;
00002e  08e4              LSRS     r4,r4,#3
000030  e00e              B        |L5.80|
                  |L5.50|
;;;51             } else if(u32Clk >= 0x2000000) {
000032  2001              MOVS     r0,#1
000034  0640              LSLS     r0,r0,#25
000036  4284              CMP      r4,r0
000038  d303              BCC      |L5.66|
;;;52                 u32Prescale = 3;    // real prescaler value is 4
00003a  2003              MOVS     r0,#3
00003c  9000              STR      r0,[sp,#0]
;;;53                 u32Clk >>= 2;
00003e  08a4              LSRS     r4,r4,#2
000040  e006              B        |L5.80|
                  |L5.66|
;;;54             } else if(u32Clk >= 0x1000000) {
000042  2001              MOVS     r0,#1
000044  0600              LSLS     r0,r0,#24
000046  4284              CMP      r4,r0
000048  d302              BCC      |L5.80|
;;;55                 u32Prescale = 1;    // real prescaler value is 2
00004a  2001              MOVS     r0,#1
00004c  9000              STR      r0,[sp,#0]
;;;56                 u32Clk >>= 1;
00004e  0864              LSRS     r4,r4,#1
                  |L5.80|
;;;57             }
;;;58     
;;;59             u32Cmpr = u32Clk / u32Freq;
000050  4631              MOV      r1,r6
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       __aeabi_uidivmod
000058  9001              STR      r0,[sp,#4]
                  |L5.90|
;;;60         }
;;;61     
;;;62         timer->CTL = u32Mode | u32Prescale;
00005a  9800              LDR      r0,[sp,#0]
00005c  4338              ORRS     r0,r0,r7
00005e  6028              STR      r0,[r5,#0]
;;;63         timer->CMP = u32Cmpr;
000060  9801              LDR      r0,[sp,#4]
000062  6068              STR      r0,[r5,#4]
;;;64     
;;;65         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000064  9a00              LDR      r2,[sp,#0]
000066  1c52              ADDS     r2,r2,#1
000068  9801              LDR      r0,[sp,#4]
00006a  4350              MULS     r0,r2,r0
00006c  4601              MOV      r1,r0
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       __aeabi_uidivmod
;;;66     }
000074  bdfe              POP      {r1-r7,pc}
;;;67     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00003e80
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x02ee0000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 132
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
