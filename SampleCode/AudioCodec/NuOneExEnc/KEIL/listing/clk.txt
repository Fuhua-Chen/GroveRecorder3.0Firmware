; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\clk.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\clk.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DeepPowerDown||, CODE, READONLY, ALIGN=2

                  CLK_DeepPowerDown PROC
;;;291      */
;;;292    void CLK_DeepPowerDown(uint32_t u32DPDWakeupMode, uint32_t u32TimerSel)
000000  b570              PUSH     {r4-r6,lr}
;;;293    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;294    	uint8_t u8Lock = SYS_Unlock();
000006  f7fffffe          BL       SYS_Unlock
00000a  4606              MOV      r6,r0
;;;295    		
;;;296    	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;		
00000c  481f              LDR      r0,|L1.140|
00000e  6900              LDR      r0,[r0,#0x10]
000010  2104              MOVS     r1,#4
000012  4308              ORRS     r0,r0,r1
000014  491d              LDR      r1,|L1.140|
000016  6108              STR      r0,[r1,#0x10]
;;;297    	CLK->PWRCTL &= 0xFF0000FF;		
000018  481d              LDR      r0,|L1.144|
00001a  6800              LDR      r0,[r0,#0]
00001c  491d              LDR      r1,|L1.148|
00001e  4008              ANDS     r0,r0,r1
000020  491b              LDR      r1,|L1.144|
000022  6008              STR      r0,[r1,#0]
;;;298    	CLK->PWRCTL |= 0x1ul << CLK_PWRCTL_DPDEN_Pos; //Go into Deep Power Down upon WFI/WFE command	
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  2101              MOVS     r1,#1
00002a  02c9              LSLS     r1,r1,#11
00002c  4308              ORRS     r0,r0,r1
00002e  4918              LDR      r1,|L1.144|
000030  6008              STR      r0,[r1,#0]
;;;299    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_STOP_Pos; //Don't go into stop mode upon WFI/WFE command	
;;;300    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_SPDEN_Pos; //Don't go into Standby Power Down upon WFI/WFE command	
;;;301    	//Power On Wakeup wakeup cannot be disabled
;;;302    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_WKPINEN_Pos;	 //Wakeup Pin (Pin 1): 0 Enabled 1 Disabled
;;;303    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_LIRCDPDEN_Pos;  //16k Oscillator: 0 Enabled 1 Disabled (No timed wakeup possible)	
;;;304    	CLK->PWRCTL |= u32TimerSel << CLK_PWRCTL_SELWKTMR_Pos;	 //Sets wakeup timer time
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]
000036  0529              LSLS     r1,r5,#20
000038  4308              ORRS     r0,r0,r1
00003a  4915              LDR      r1,|L1.144|
00003c  6008              STR      r0,[r1,#0]
;;;305    		
;;;306    	switch(u32DPDWakeupMode)
00003e  2c00              CMP      r4,#0
000040  d006              BEQ      |L1.80|
000042  2c01              CMP      r4,#1
000044  d005              BEQ      |L1.82|
000046  2c02              CMP      r4,#2
000048  d00b              BEQ      |L1.98|
00004a  2c03              CMP      r4,#3
00004c  d119              BNE      |L1.130|
00004e  e010              B        |L1.114|
                  |L1.80|
;;;307    	{
;;;308    		case CLK_DPDWAKEUP_PINOSC16K:	    //Wakeup by Pin or OSC10k count 
;;;309    			break;                         //Pin and OSC10K are enabled above
000050  e017              B        |L1.130|
                  |L1.82|
;;;310    		    
;;;311    		case CLK_DPDWAKEUP_PIN:		                              //Wakeup by Pin 
;;;312    			CLK->PWRCTL |= 0x1ul << CLK_PWRCTL_LIRCDPDEN_Pos;   //Disable OSC16K Wakeup
000052  480f              LDR      r0,|L1.144|
000054  6800              LDR      r0,[r0,#0]
000056  2101              MOVS     r1,#1
000058  0449              LSLS     r1,r1,#17
00005a  4308              ORRS     r0,r0,r1
00005c  490c              LDR      r1,|L1.144|
00005e  6008              STR      r0,[r1,#0]
;;;313    			break;
000060  e00f              B        |L1.130|
                  |L1.98|
;;;314    
;;;315    		case CLK_DPDWAKEUP_OSC16K:	                            //Wakeup by OSC10k count 
;;;316     			CLK->PWRCTL |= 0x1ul << CLK_PWRCTL_WKPINEN_Pos;    //Disable PIN Wakeup
000062  480b              LDR      r0,|L1.144|
000064  6800              LDR      r0,[r0,#0]
000066  2101              MOVS     r1,#1
000068  0409              LSLS     r1,r1,#16
00006a  4308              ORRS     r0,r0,r1
00006c  4908              LDR      r1,|L1.144|
00006e  6008              STR      r0,[r1,#0]
;;;317    			break;
000070  e007              B        |L1.130|
                  |L1.114|
;;;318    			
;;;319    		case CLK_DPDWAKEUP_POR:          	//Wakeup by Power On Wakeup only  
;;;320    		    CLK->PWRCTL |= (CLK_PWRCTL_LIRCDPDEN_Msk|CLK_PWRCTL_WKPINEN_Msk);    //Disable PIN Wakeup and OSC10K Wakeup
000072  4807              LDR      r0,|L1.144|
000074  6800              LDR      r0,[r0,#0]
000076  2103              MOVS     r1,#3
000078  0409              LSLS     r1,r1,#16
00007a  4308              ORRS     r0,r0,r1
00007c  4904              LDR      r1,|L1.144|
00007e  6008              STR      r0,[r1,#0]
;;;321    		    break;
000080  bf00              NOP      
                  |L1.130|
000082  bf00              NOP                            ;309
;;;322    		
;;;323    	}
;;;324    		
;;;325    	SYS_Lock(u8Lock);
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       SYS_Lock
;;;326    }
00008a  bd70              POP      {r4-r6,pc}
;;;327    
                          ENDP

                  |L1.140|
                          DCD      0xe000ed00
                  |L1.144|
                          DCD      0x50000200
                  |L1.148|
                          DCD      0xff0000ff

                          AREA ||i.CLK_DeepSleep||, CODE, READONLY, ALIGN=2

                  CLK_DeepSleep PROC
;;;348      */
;;;349    void CLK_DeepSleep(void)
000000  b510              PUSH     {r4,lr}
;;;350    {
;;;351    	uint8_t u8Lock = SYS_Unlock();
000002  f7fffffe          BL       SYS_Unlock
000006  4604              MOV      r4,r0
;;;352    	
;;;353    	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;	
000008  480b              LDR      r0,|L2.56|
00000a  6900              LDR      r0,[r0,#0x10]
00000c  2104              MOVS     r1,#4
00000e  4308              ORRS     r0,r0,r1
000010  4909              LDR      r1,|L2.56|
000012  6108              STR      r0,[r1,#0x10]
;;;354    	CLK->PWRCTL &= 0xFF0000FF;		
000014  4809              LDR      r0,|L2.60|
000016  6800              LDR      r0,[r0,#0]
000018  4909              LDR      r1,|L2.64|
00001a  4008              ANDS     r0,r0,r1
00001c  4907              LDR      r1,|L2.60|
00001e  6008              STR      r0,[r1,#0]
;;;355    	CLK->PWRCTL |= 0x1ul << CLK_PWRCTL_STOP_Pos;  //Go into Stop mode upon upon WFI/WFE command
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]
000024  2101              MOVS     r1,#1
000026  0249              LSLS     r1,r1,#9
000028  4308              ORRS     r0,r0,r1
00002a  4904              LDR      r1,|L2.60|
00002c  6008              STR      r0,[r1,#0]
;;;356    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_SPDEN_Pos; //Don't go into Standby Power Down upon WFI/WFE command
;;;357    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_DPDEN_Pos;	 // Don't go into Deep Power Down upon WFI/WFE command
;;;358    	
;;;359    	SYS_Lock(u8Lock);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SYS_Lock
;;;360    }
000034  bd10              POP      {r4,pc}
;;;361    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0xe000ed00
                  |L2.60|
                          DCD      0x50000200
                  |L2.64|
                          DCD      0xff0000ff

                          AREA ||i.CLK_DisableLDO||, CODE, READONLY, ALIGN=2

                  CLK_DisableLDO PROC
;;;401      */
;;;402    void CLK_DisableLDO(void)
000000  b510              PUSH     {r4,lr}
;;;403    {
;;;404    	uint8_t u8Lock = SYS_Unlock();
000002  f7fffffe          BL       SYS_Unlock
000006  4604              MOV      r4,r0
;;;405    	
;;;406    	ANA->LDOPD |= ANA_LDOPD_PD_Msk;
000008  4804              LDR      r0,|L3.28|
00000a  6a40              LDR      r0,[r0,#0x24]
00000c  2101              MOVS     r1,#1
00000e  4308              ORRS     r0,r0,r1
000010  4902              LDR      r1,|L3.28|
000012  6248              STR      r0,[r1,#0x24]
;;;407    	
;;;408    	SYS_Lock(u8Lock);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SYS_Lock
;;;409    }
00001a  bd10              POP      {r4,pc}
;;;410    
                          ENDP

                  |L3.28|
                          DCD      0x40080000

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;82       */
;;;83     void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  0f81              LSRS     r1,r0,#30
;;;84     {
;;;85     	*(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_AHPBCLK(u32ModuleIdx)*4))  &= ~(1<<MODULE_IP_EN_Pos(u32ModuleIdx));
000002  0089              LSLS     r1,r1,#2
000004  4a06              LDR      r2,|L4.32|
000006  1889              ADDS     r1,r1,r2
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2101              MOVS     r1,#1
000010  4099              LSLS     r1,r1,r3
000012  438a              BICS     r2,r2,r1
000014  0f81              LSRS     r1,r0,#30
000016  0089              LSLS     r1,r1,#2
000018  4b01              LDR      r3,|L4.32|
00001a  18c9              ADDS     r1,r1,r3
00001c  604a              STR      r2,[r1,#4]
;;;86     }
00001e  4770              BX       lr
;;;87     
                          ENDP

                  |L4.32|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;95       */
;;;96     void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
000002  4604              MOV      r4,r0
;;;98     	uint8_t u8Lock = SYS_Unlock();
000004  f7fffffe          BL       SYS_Unlock
000008  4605              MOV      r5,r0
;;;99     	
;;;100        CLK->PWRCTL &= ~u32ClkMask;
00000a  4804              LDR      r0,|L5.28|
00000c  6800              LDR      r0,[r0,#0]
00000e  43a0              BICS     r0,r0,r4
000010  4902              LDR      r1,|L5.28|
000012  6008              STR      r0,[r1,#0]
;;;101    	
;;;102    	SYS_Lock(u8Lock);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SYS_Lock
;;;103    }
00001a  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP

                  |L5.28|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableLDO||, CODE, READONLY, ALIGN=2

                  CLK_EnableLDO PROC
;;;387      */
;;;388    void CLK_EnableLDO( uint32_t u32LDOSel )
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
000002  4604              MOV      r4,r0
;;;390    	uint8_t u8Lock = SYS_Unlock();
000004  f7fffffe          BL       SYS_Unlock
000008  4605              MOV      r5,r0
;;;391    	
;;;392    	CLK->APBCLK0 |= CLK_APBCLK0_ANACKEN_Msk;
00000a  480b              LDR      r0,|L6.56|
00000c  6880              LDR      r0,[r0,#8]
00000e  2101              MOVS     r1,#1
000010  0789              LSLS     r1,r1,#30
000012  4308              ORRS     r0,r0,r1
000014  4908              LDR      r1,|L6.56|
000016  6088              STR      r0,[r1,#8]
;;;393    	ANA->LDOPD &= ~ANA_LDOPD_PD_Msk;
000018  4808              LDR      r0,|L6.60|
00001a  6a40              LDR      r0,[r0,#0x24]
00001c  0840              LSRS     r0,r0,#1
00001e  0040              LSLS     r0,r0,#1
000020  4906              LDR      r1,|L6.60|
000022  6248              STR      r0,[r1,#0x24]
;;;394    	ANA->LDOSEL = (ANA->LDOSEL&~ANA_LDOSEL_LDOSEL_Msk)|u32LDOSel; 
000024  4608              MOV      r0,r1
000026  6a00              LDR      r0,[r0,#0x20]
000028  0880              LSRS     r0,r0,#2
00002a  0080              LSLS     r0,r0,#2
00002c  4320              ORRS     r0,r0,r4
00002e  6208              STR      r0,[r1,#0x20]
;;;395    	
;;;396    	SYS_Lock(u8Lock);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       SYS_Lock
;;;397    }
000036  bd70              POP      {r4-r6,pc}
;;;398    
                          ENDP

                  |L6.56|
                          DCD      0x50000200
                  |L6.60|
                          DCD      0x40080000

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;127      */
;;;128    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  0f81              LSRS     r1,r0,#30
;;;129    {
;;;130    	*(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_AHPBCLK(u32ModuleIdx)*4))  |= 1<<MODULE_IP_EN_Pos(u32ModuleIdx);
000002  0089              LSLS     r1,r1,#2
000004  4a06              LDR      r2,|L7.32|
000006  1889              ADDS     r1,r1,r2
000008  6849              LDR      r1,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4311              ORRS     r1,r1,r2
000014  0f82              LSRS     r2,r0,#30
000016  0092              LSLS     r2,r2,#2
000018  4b01              LDR      r3,|L7.32|
00001a  18d2              ADDS     r2,r2,r3
00001c  6051              STR      r1,[r2,#4]
;;;131    }
00001e  4770              BX       lr
;;;132    
                          ENDP

                  |L7.32|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;140      */
;;;141    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
000002  4604              MOV      r4,r0
;;;143    	uint8_t u8Lock = SYS_Unlock();
000004  f7fffffe          BL       SYS_Unlock
000008  4605              MOV      r5,r0
;;;144    	
;;;145        CLK->PWRCTL |= u32ClkMask;
00000a  4804              LDR      r0,|L8.28|
00000c  6800              LDR      r0,[r0,#0]
00000e  4320              ORRS     r0,r0,r4
000010  4902              LDR      r1,|L8.28|
000012  6008              STR      r0,[r1,#0]
;;;146    	
;;;147    	SYS_Lock(u8Lock);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       SYS_Lock
;;;148    }
00001a  bd70              POP      {r4-r6,pc}
;;;149    
                          ENDP

                  |L8.28|
                          DCD      0x50000200

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;43       */
;;;44     uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46     	SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;47     	return SystemCoreClock;
000006  4801              LDR      r0,|L9.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;48     }
00000a  bd10              POP      {r4,pc}
;;;49     
                          ENDP

                  |L9.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHIRCFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHIRCFreq PROC
;;;54       */
;;;55     uint32_t CLK_GetHIRCFreq(void)
000000  4804              LDR      r0,|L10.20|
;;;56     {
;;;57     	return gau32HiRCSrcTbl[(CLK->CLKSEL0 & CLK_CLKSEL0_HIRCFSEL_Msk)>>CLK_CLKSEL0_HIRCFSEL_Pos];
000002  6900              LDR      r0,[r0,#0x10]
000004  2140              MOVS     r1,#0x40
000006  4008              ANDS     r0,r0,r1
000008  0980              LSRS     r0,r0,#6
00000a  0080              LSLS     r0,r0,#2
00000c  4902              LDR      r1,|L10.24|
00000e  5808              LDR      r0,[r1,r0]
;;;58     }
000010  4770              BX       lr
;;;59     
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x50000200
                  |L10.24|
                          DCD      gau32HiRCSrcTbl

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;30       */
;;;31     uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L11.20|
;;;32     {
;;;33     	if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk )
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L11.16|
;;;34     		return __LXT;
00000c  0388              LSLS     r0,r1,#14
                  |L11.14|
;;;35     	else
;;;36     		return 0;
;;;37     }
00000e  4770              BX       lr
                  |L11.16|
000010  2000              MOVS     r0,#0                 ;36
000012  e7fc              B        |L11.14|
;;;38     
                          ENDP

                  |L11.20|
                          DCD      0x50000200

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;229      */
;;;230    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32HIRCType, uint32_t u32ClkDiv)
000000  b5f8              PUSH     {r3-r7,lr}
;;;231    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;232    	uint8_t u8Lock = SYS_Unlock();
000008  f7fffffe          BL       SYS_Unlock
00000c  4607              MOV      r7,r0
;;;233    	
;;;234    	CLK->CLKSEL0 = (CLK->CLKSEL0 & ~(CLK_CLKSEL0_HCLKSEL_Msk|CLK_CLKSEL0_HIRCFSEL_Msk)) | u32ClkSrc | u32HIRCType;
00000e  480d              LDR      r0,|L12.68|
000010  6900              LDR      r0,[r0,#0x10]
000012  2147              MOVS     r1,#0x47
000014  4388              BICS     r0,r0,r1
000016  4320              ORRS     r0,r0,r4
000018  4328              ORRS     r0,r0,r5
00001a  490a              LDR      r1,|L12.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;235    	CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLKSEL_Msk) | u32ClkSrc;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  08c0              LSRS     r0,r0,#3
000024  00c0              LSLS     r0,r0,#3
000026  4320              ORRS     r0,r0,r4
000028  6108              STR      r0,[r1,#0x10]
;;;236    	CLK->CLKDIV0 = (CLK->CLKDIV0 & ~CLK_CLKDIV0_HCLKDIV_Msk) | u32ClkDiv;
00002a  4608              MOV      r0,r1
00002c  6980              LDR      r0,[r0,#0x18]
00002e  0900              LSRS     r0,r0,#4
000030  0100              LSLS     r0,r0,#4
000032  4330              ORRS     r0,r0,r6
000034  6188              STR      r0,[r1,#0x18]
;;;237    	
;;;238    	SYS_Lock(u8Lock);
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       SYS_Lock
;;;239    	
;;;240    	SystemCoreClockUpdate();
00003c  f7fffffe          BL       SystemCoreClockUpdate
;;;241    }
000040  bdf8              POP      {r3-r7,pc}
;;;242    
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;195      */
;;;196    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;197    {
000002  460b              MOV      r3,r1
;;;198    	uint32_t u32tmp=0,u32sel=0,u32div=0;
000004  2100              MOVS     r1,#0
000006  2400              MOVS     r4,#0
000008  2500              MOVS     r5,#0
;;;199        
;;;200    	if(MODULE_CLKDIV_Msk(u32ModuleIdx)!=MODULE_NoMsk)
00000a  0386              LSLS     r6,r0,#14
00000c  0e36              LSRS     r6,r6,#24
00000e  2e00              CMP      r6,#0
000010  d00f              BEQ      |L13.50|
;;;201    	{
;;;202    		u32div =(uint32_t)&CLK->CLKDIV0+((MODULE_CLKDIV(u32ModuleIdx))*4);
000012  0306              LSLS     r6,r0,#12
000014  0fb6              LSRS     r6,r6,#30
000016  00b6              LSLS     r6,r6,#2
000018  4f11              LDR      r7,|L13.96|
00001a  19f5              ADDS     r5,r6,r7
;;;203    		u32tmp = *(volatile uint32_t *)(u32div);
00001c  6829              LDR      r1,[r5,#0]
;;;204    		u32tmp = ( u32tmp & ~(MODULE_CLKDIV_Msk(u32ModuleIdx)<<MODULE_CLKDIV_Pos(u32ModuleIdx)) ) | u32ClkDiv;
00001e  0386              LSLS     r6,r0,#14
000020  0e37              LSRS     r7,r6,#24
000022  0586              LSLS     r6,r0,#22
000024  0ef6              LSRS     r6,r6,#27
000026  40b7              LSLS     r7,r7,r6
000028  460e              MOV      r6,r1
00002a  43be              BICS     r6,r6,r7
00002c  4316              ORRS     r6,r6,r2
00002e  4631              MOV      r1,r6
;;;205    		*(volatile uint32_t *)(u32div) = u32tmp;
000030  6029              STR      r1,[r5,#0]
                  |L13.50|
;;;206        }
;;;207    		
;;;208    	if(MODULE_CLKSEL_Msk(u32ModuleIdx)!=MODULE_NoMsk)
000032  0106              LSLS     r6,r0,#4
000034  0f76              LSRS     r6,r6,#29
000036  2e00              CMP      r6,#0
000038  d010              BEQ      |L13.92|
;;;209    	{
;;;210    		u32sel = (uint32_t)&CLK->CLKSEL0+((MODULE_CLKSEL(u32ModuleIdx))*4);
00003a  0086              LSLS     r6,r0,#2
00003c  0fb6              LSRS     r6,r6,#30
00003e  00b6              LSLS     r6,r6,#2
000040  4f07              LDR      r7,|L13.96|
000042  3f08              SUBS     r7,r7,#8
000044  19f4              ADDS     r4,r6,r7
;;;211    		u32tmp = *(volatile uint32_t *)(u32sel);
000046  6821              LDR      r1,[r4,#0]
;;;212    		u32tmp = ( u32tmp & ~(MODULE_CLKSEL_Msk(u32ModuleIdx)<<MODULE_CLKSEL_Pos(u32ModuleIdx)) ) | u32ClkSrc;
000048  0106              LSLS     r6,r0,#4
00004a  0f77              LSRS     r7,r6,#29
00004c  01c6              LSLS     r6,r0,#7
00004e  0ef6              LSRS     r6,r6,#27
000050  40b7              LSLS     r7,r7,r6
000052  460e              MOV      r6,r1
000054  43be              BICS     r6,r6,r7
000056  431e              ORRS     r6,r6,r3
000058  4631              MOV      r1,r6
;;;213    		*(volatile uint32_t *)(u32sel) = u32tmp;
00005a  6021              STR      r1,[r4,#0]
                  |L13.92|
;;;214    	}
;;;215    }
00005c  bdf0              POP      {r4-r7,pc}
;;;216    
                          ENDP

00005e  0000              DCW      0x0000
                  |L13.96|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;252      */
;;;253    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {                         
000002  4604              MOV      r4,r0
;;;255    	uint8_t u8Lock = SYS_Unlock();
000004  f7fffffe          BL       SYS_Unlock
000008  4605              MOV      r5,r0
;;;256    	CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc ;
00000a  4805              LDR      r0,|L14.32|
00000c  6900              LDR      r0,[r0,#0x10]
00000e  2138              MOVS     r1,#0x38
000010  4388              BICS     r0,r0,r1
000012  4320              ORRS     r0,r0,r4
000014  4902              LDR      r1,|L14.32|
000016  6108              STR      r0,[r1,#0x10]
;;;257    	SYS_Lock(u8Lock);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       SYS_Lock
;;;258    }
00001e  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP

                  |L14.32|
                          DCD      0x50000200

                          AREA ||i.CLK_Sleep||, CODE, READONLY, ALIGN=2

                  CLK_Sleep PROC
;;;365      */
;;;366    void CLK_Sleep(void)
000000  b510              PUSH     {r4,lr}
;;;367    {
;;;368    	uint8_t u8Lock = SYS_Unlock();
000002  f7fffffe          BL       SYS_Unlock
000006  4604              MOV      r4,r0
;;;369    		
;;;370    	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;		
000008  4807              LDR      r0,|L15.40|
00000a  6900              LDR      r0,[r0,#0x10]
00000c  2104              MOVS     r1,#4
00000e  4308              ORRS     r0,r0,r1
000010  4905              LDR      r1,|L15.40|
000012  6108              STR      r0,[r1,#0x10]
;;;371    	CLK->PWRCTL &= 0xFF0000FF;	
000014  4805              LDR      r0,|L15.44|
000016  6800              LDR      r0,[r0,#0]
000018  4905              LDR      r1,|L15.48|
00001a  4008              ANDS     r0,r0,r1
00001c  4903              LDR      r1,|L15.44|
00001e  6008              STR      r0,[r1,#0]
;;;372    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_STOP_Pos;  //Don't go into Stop mode upon WFI/WFE command
;;;373    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_SPDEN_Pos; //Don't go into Standby Power Down upon WFI/WFE command
;;;374    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_DPDEN_Pos; // Don't go into Deep Power Down upon WFI/WFE command
;;;375    		
;;;376    	SYS_Lock(u8Lock);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SYS_Lock
;;;377    }
000026  bd10              POP      {r4,pc}
;;;378    
                          ENDP

                  |L15.40|
                          DCD      0xe000ed00
                  |L15.44|
                          DCD      0x50000200
                  |L15.48|
                          DCD      0xff0000ff

                          AREA ||i.CLK_StandbyPowerDown||, CODE, READONLY, ALIGN=2

                  CLK_StandbyPowerDown PROC
;;;331      */
;;;332    void CLK_StandbyPowerDown(void)
000000  b510              PUSH     {r4,lr}
;;;333    {
;;;334    	uint8_t u8Lock = SYS_Unlock();
000002  f7fffffe          BL       SYS_Unlock
000006  4604              MOV      r4,r0
;;;335    		
;;;336    	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;	
000008  480b              LDR      r0,|L16.56|
00000a  6900              LDR      r0,[r0,#0x10]
00000c  2104              MOVS     r1,#4
00000e  4308              ORRS     r0,r0,r1
000010  4909              LDR      r1,|L16.56|
000012  6108              STR      r0,[r1,#0x10]
;;;337    	CLK->PWRCTL &= 0xFF0000FF;		
000014  4809              LDR      r0,|L16.60|
000016  6800              LDR      r0,[r0,#0]
000018  4909              LDR      r1,|L16.64|
00001a  4008              ANDS     r0,r0,r1
00001c  4907              LDR      r1,|L16.60|
00001e  6008              STR      r0,[r1,#0]
;;;338    	CLK->PWRCTL |= 0x1ul << CLK_PWRCTL_SPDEN_Pos; //Go into Standby Power Down	upon WFI/WFE command
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]
000024  2101              MOVS     r1,#1
000026  0289              LSLS     r1,r1,#10
000028  4308              ORRS     r0,r0,r1
00002a  4904              LDR      r1,|L16.60|
00002c  6008              STR      r0,[r1,#0]
;;;339    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_STOP_Pos;	//Don't go into Stop mode upon WFI/WFE command
;;;340    	//CLK->PWRCTL |= 0x0ul << CLK_PWRCTL_DPDEN_Pos;	// Don't go into Deep Power Down upon WFI/WFE command
;;;341    			
;;;342    	SYS_Lock(u8Lock);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       SYS_Lock
;;;343    }
000034  bd10              POP      {r4,pc}
;;;344    
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
                          DCD      0xe000ed00
                  |L16.60|
                          DCD      0x50000200
                  |L16.64|
                          DCD      0xff0000ff

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;267      */
;;;268    void CLK_SysTickDelay(uint32_t us)
000000  4908              LDR      r1,|L17.36|
;;;269    {
;;;270    	SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4341              MULS     r1,r0,r1
000006  4a08              LDR      r2,|L17.40|
000008  6151              STR      r1,[r2,#0x14]
;;;271    	SysTick->VAL  =  (0x00);
00000a  2100              MOVS     r1,#0
00000c  6191              STR      r1,[r2,#0x18]
;;;272    	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2105              MOVS     r1,#5
000010  6111              STR      r1,[r2,#0x10]
;;;273    
;;;274        /* Waiting for down-count to zero */
;;;275    	while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  bf00              NOP      
                  |L17.20|
000014  4904              LDR      r1,|L17.40|
000016  6909              LDR      r1,[r1,#0x10]
000018  2201              MOVS     r2,#1
00001a  0412              LSLS     r2,r2,#16
00001c  4011              ANDS     r1,r1,r2
00001e  2900              CMP      r1,#0
000020  d0f8              BEQ      |L17.20|
;;;276    }
000022  4770              BX       lr
;;;277    
                          ENDP

                  |L17.36|
                          DCD      CyclesPerUs
                  |L17.40|
                          DCD      0xe000e000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_5b0c67f2____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_clk_c_5b0c67f2____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_5b0c67f2____REVSH|
#line 132
|__asm___5_clk_c_5b0c67f2____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
