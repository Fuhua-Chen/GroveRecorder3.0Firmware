; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\uart.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\uart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;36      */
;;;37     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  2201              MOVS     r2,#1
;;;38     {
;;;39         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)      /* clear Receive Line Status Interrupt */
000002  0292              LSLS     r2,r2,#10
000004  400a              ANDS     r2,r2,r1
000006  2a00              CMP      r2,#0
000008  d003              BEQ      |L1.18|
;;;40             uart->FIFOSTS |= UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
00000a  6982              LDR      r2,[r0,#0x18]
00000c  2370              MOVS     r3,#0x70
00000e  431a              ORRS     r2,r2,r3
000010  6182              STR      r2,[r0,#0x18]
                  |L1.18|
;;;41     
;;;42         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)    /* clear Modem Interrupt */
000012  2201              MOVS     r2,#1
000014  02d2              LSLS     r2,r2,#11
000016  400a              ANDS     r2,r2,r1
000018  2a00              CMP      r2,#0
00001a  d003              BEQ      |L1.36|
;;;43             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00001c  6942              LDR      r2,[r0,#0x14]
00001e  2301              MOVS     r3,#1
000020  431a              ORRS     r2,r2,r3
000022  6142              STR      r2,[r0,#0x14]
                  |L1.36|
;;;44     
;;;45         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* clear Buffer Error Interrupt */
000024  2201              MOVS     r2,#1
000026  0352              LSLS     r2,r2,#13
000028  400a              ANDS     r2,r2,r1
00002a  2a00              CMP      r2,#0
00002c  d003              BEQ      |L1.54|
;;;46             uart->FIFOSTS |= ( UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk );
00002e  6982              LDR      r2,[r0,#0x18]
000030  4b06              LDR      r3,|L1.76|
000032  431a              ORRS     r2,r2,r3
000034  6182              STR      r2,[r0,#0x18]
                  |L1.54|
;;;47     
;;;48         if(u32InterruptFlag & UART_INTSTS_RXTOINT_Msk)     /* clear Modem Interrupt */
000036  2201              MOVS     r2,#1
000038  0312              LSLS     r2,r2,#12
00003a  400a              ANDS     r2,r2,r1
00003c  2a00              CMP      r2,#0
00003e  d003              BEQ      |L1.72|
;;;49             uart->INTSTS |= UART_INTSTS_RXTOIF_Msk;
000040  69c2              LDR      r2,[r0,#0x1c]
000042  2310              MOVS     r3,#0x10
000044  431a              ORRS     r2,r2,r3
000046  61c2              STR      r2,[r0,#0x1c]
                  |L1.72|
;;;50     }
000048  4770              BX       lr
;;;51     
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;58      */
;;;59     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;60     {
;;;61         uart->INTEN = 0;
000002  6041              STR      r1,[r0,#4]
;;;62     }
000004  4770              BX       lr
;;;63     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;70      */
;;;71     void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;72     {
;;;73         uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;74     }
00000a  4770              BX       lr
;;;75     
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;82      */
;;;83     void UART_EnableFlowCtrl(UART_T* uart )
000000  6901              LDR      r1,[r0,#0x10]
;;;84     {
;;;85         uart->MODEM    |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;86         uart->MODEM    &= UART_MODEM_RTS_Msk;
00000a  6901              LDR      r1,[r0,#0x10]
00000c  2202              MOVS     r2,#2
00000e  4011              ANDS     r1,r1,r2
000010  6101              STR      r1,[r0,#0x10]
;;;87         uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000012  6941              LDR      r1,[r0,#0x14]
000014  01d2              LSLS     r2,r2,#7
000016  4311              ORRS     r1,r1,r2
000018  6141              STR      r1,[r0,#0x14]
;;;88         uart->INTEN    |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
00001a  6841              LDR      r1,[r0,#4]
00001c  2203              MOVS     r2,#3
00001e  0312              LSLS     r2,r2,#12
000020  4311              ORRS     r1,r1,r2
000022  6041              STR      r1,[r0,#4]
;;;89     }
000024  4770              BX       lr
;;;90     
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;98      */
;;;99     void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b5f8              PUSH     {r3-r7,lr}
;;;100    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;101        uint32_t u32Clk;
;;;102        uint32_t u32Baud_Div;
;;;103    
;;;104        uart->FUNCSEL = UART_FUNCSEL_UART;
000006  2000              MOVS     r0,#0
000008  6320              STR      r0,[r4,#0x30]
;;;105        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
00000a  2003              MOVS     r0,#3
00000c  60e0              STR      r0,[r4,#0xc]
;;;106        uart->FIFO = UART_FIFO_RFITL_1BYTE | UART_FIFO_RTSTRGLV_1BYTE;
00000e  2000              MOVS     r0,#0
000010  60a0              STR      r0,[r4,#8]
;;;107    
;;;108        u32Clk = CLK_GetHCLKFreq() / (((CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos) + 1);
000012  f7fffffe          BL       CLK_GetHCLKFreq
000016  9000              STR      r0,[sp,#0]
000018  4811              LDR      r0,|L5.96|
00001a  6980              LDR      r0,[r0,#0x18]
00001c  220f              MOVS     r2,#0xf
00001e  0212              LSLS     r2,r2,#8
000020  4010              ANDS     r0,r0,r2
000022  0a00              LSRS     r0,r0,#8
000024  1c41              ADDS     r1,r0,#1
000026  9800              LDR      r0,[sp,#0]
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4607              MOV      r7,r0
;;;109    
;;;110        if(u32baudrate != 0) 
00002e  2d00              CMP      r5,#0
000030  d015              BEQ      |L5.94|
;;;111    	{
;;;112            u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
000032  0869              LSRS     r1,r5,#1
000034  19c8              ADDS     r0,r1,r7
000036  4629              MOV      r1,r5
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  1e86              SUBS     r6,r0,#2
;;;113    
;;;114            if(u32Baud_Div > 0xFFFF)
00003e  4809              LDR      r0,|L5.100|
000040  4286              CMP      r6,r0
000042  d908              BLS      |L5.86|
;;;115                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
000044  00e9              LSLS     r1,r5,#3
000046  19c8              ADDS     r0,r1,r7
000048  4629              MOV      r1,r5
00004a  f7fffffe          BL       __aeabi_uidivmod
00004e  0900              LSRS     r0,r0,#4
000050  1e80              SUBS     r0,r0,#2
000052  6260              STR      r0,[r4,#0x24]
000054  e003              B        |L5.94|
                  |L5.86|
;;;116            else
;;;117                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000056  2003              MOVS     r0,#3
000058  0700              LSLS     r0,r0,#28
00005a  4330              ORRS     r0,r0,r6
00005c  6260              STR      r0,[r4,#0x24]
                  |L5.94|
;;;118        }
;;;119    }
00005e  bdf8              POP      {r3-r7,pc}
;;;120    
                          ENDP

                  |L5.96|
                          DCD      0x50000200
                  |L5.100|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;130     */
;;;131    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b530              PUSH     {r4,r5,lr}
;;;132    {
000002  4603              MOV      r3,r0
;;;133        uint32_t  u32Count;
;;;134    
;;;135        for(u32Count=0; u32Count < u32ReadBytes; u32Count++) 
000004  2000              MOVS     r0,#0
000006  e009              B        |L6.28|
                  |L6.8|
;;;136    	{
;;;137            if(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)  /* Check RX empty => failed */
000008  699c              LDR      r4,[r3,#0x18]
00000a  2501              MOVS     r5,#1
00000c  03ad              LSLS     r5,r5,#14
00000e  402c              ANDS     r4,r4,r5
000010  2c00              CMP      r4,#0
000012  d000              BEQ      |L6.22|
                  |L6.20|
;;;138                return u32Count;
;;;139            
;;;140            pu8RxBuf[u32Count] = uart->DAT;               /* Get Data from UART RX  */
;;;141        }
;;;142    
;;;143        return u32Count;
;;;144    }
000014  bd30              POP      {r4,r5,pc}
                  |L6.22|
000016  681c              LDR      r4,[r3,#0]            ;140
000018  540c              STRB     r4,[r1,r0]            ;140
00001a  1c40              ADDS     r0,r0,#1              ;135
                  |L6.28|
00001c  4290              CMP      r0,r2                 ;135
00001e  d3f3              BCC      |L6.8|
000020  bf00              NOP                            ;143
000022  e7f7              B        |L6.20|
;;;145    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=1

                  UART_SelectIrDAMode PROC
;;;202     */
;;;203    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b510              PUSH     {r4,lr}
;;;204    {
000002  460b              MOV      r3,r1
;;;205        uart->BAUD = UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(12000000, 57600);
000004  210b              MOVS     r1,#0xb
000006  6241              STR      r1,[r0,#0x24]
;;;206    
;;;207        uart->IRDA    &= ~UART_IRDA_TXINV_Msk;
000008  6a81              LDR      r1,[r0,#0x28]
00000a  2420              MOVS     r4,#0x20
00000c  43a1              BICS     r1,r1,r4
00000e  6281              STR      r1,[r0,#0x28]
;;;208        uart->IRDA    |=  UART_IRDA_RXINV_Msk;
000010  6a81              LDR      r1,[r0,#0x28]
000012  2440              MOVS     r4,#0x40
000014  4321              ORRS     r1,r1,r4
000016  6281              STR      r1,[r0,#0x28]
;;;209        uart->IRDA     =  u32Direction ? uart->IRDA | UART_IRDA_TXEN_Msk : uart->IRDA &~ UART_IRDA_TXEN_Msk;
000018  2a00              CMP      r2,#0
00001a  d003              BEQ      |L7.36|
00001c  6a81              LDR      r1,[r0,#0x28]
00001e  2402              MOVS     r4,#2
000020  4321              ORRS     r1,r1,r4
000022  e002              B        |L7.42|
                  |L7.36|
000024  6a81              LDR      r1,[r0,#0x28]
000026  2402              MOVS     r4,#2
000028  43a1              BICS     r1,r1,r4
                  |L7.42|
00002a  6281              STR      r1,[r0,#0x28]
;;;210        uart->FUNCSEL  =  UART_FUNCSEL_IrDA;
00002c  2102              MOVS     r1,#2
00002e  6301              STR      r1,[r0,#0x30]
;;;211    }
000030  bd10              POP      {r4,pc}
;;;212    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;157     */
;;;158    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5fe              PUSH     {r1-r7,lr}
;;;159    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;160        uint32_t u32Clk;
;;;161        uint32_t u32Baud_Div = 0;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;162    	
;;;163        u32Clk = CLK_GetHCLKFreq() / (((CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos) + 1);
00000e  f7fffffe          BL       CLK_GetHCLKFreq
000012  9000              STR      r0,[sp,#0]
000014  4816              LDR      r0,|L8.112|
000016  6980              LDR      r0,[r0,#0x18]
000018  220f              MOVS     r2,#0xf
00001a  0212              LSLS     r2,r2,#8
00001c  4010              ANDS     r0,r0,r2
00001e  0a00              LSRS     r0,r0,#8
000020  1c41              ADDS     r1,r0,#1
000022  9800              LDR      r0,[sp,#0]
000024  f7fffffe          BL       __aeabi_uidivmod
000028  9002              STR      r0,[sp,#8]
;;;164    
;;;165        if(u32baudrate != 0) 
00002a  2d00              CMP      r5,#0
00002c  d01a              BEQ      |L8.100|
;;;166    	{
;;;167            u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
00002e  086a              LSRS     r2,r5,#1
000030  9902              LDR      r1,[sp,#8]
000032  1850              ADDS     r0,r2,r1
000034  4629              MOV      r1,r5
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  1e80              SUBS     r0,r0,#2
00003c  9001              STR      r0,[sp,#4]
;;;168    
;;;169            if(u32Baud_Div > 0xFFFF)
00003e  490d              LDR      r1,|L8.116|
000040  9801              LDR      r0,[sp,#4]
000042  4288              CMP      r0,r1
000044  d909              BLS      |L8.90|
;;;170                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
000046  00ea              LSLS     r2,r5,#3
000048  9902              LDR      r1,[sp,#8]
00004a  1850              ADDS     r0,r2,r1
00004c  4629              MOV      r1,r5
00004e  f7fffffe          BL       __aeabi_uidivmod
000052  0900              LSRS     r0,r0,#4
000054  1e80              SUBS     r0,r0,#2
000056  6260              STR      r0,[r4,#0x24]
000058  e004              B        |L8.100|
                  |L8.90|
;;;171            else
;;;172                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
00005a  2103              MOVS     r1,#3
00005c  0709              LSLS     r1,r1,#28
00005e  9801              LDR      r0,[sp,#4]
000060  4308              ORRS     r0,r0,r1
000062  6260              STR      r0,[r4,#0x24]
                  |L8.100|
;;;173        }
;;;174    
;;;175        uart->LINE = u32data_width | u32parity | u32stop_bits;
000064  4630              MOV      r0,r6
000066  4338              ORRS     r0,r0,r7
000068  9908              LDR      r1,[sp,#0x20]
00006a  4308              ORRS     r0,r0,r1
00006c  60e0              STR      r0,[r4,#0xc]
;;;176    }
00006e  bdfe              POP      {r1-r7,pc}
;;;177    
                          ENDP

                  |L8.112|
                          DCD      0x50000200
                  |L8.116|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;186     */
;;;187    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;188    {
;;;189        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk)| (u32TOC);
000002  09d2              LSRS     r2,r2,#7
000004  01d2              LSLS     r2,r2,#7
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;190        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6842              LDR      r2,[r0,#4]
00000c  2301              MOVS     r3,#1
00000e  02db              LSLS     r3,r3,#11
000010  431a              ORRS     r2,r2,r3
000012  6042              STR      r2,[r0,#4]
;;;191    }
000014  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;221     */
;;;222    uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b530              PUSH     {r4,r5,lr}
;;;223    {
000002  4603              MOV      r3,r0
;;;224        uint32_t  u32Count;
;;;225    
;;;226        for(u32Count=0; u32Count != u32WriteBytes; u32Count++) 
000004  2000              MOVS     r0,#0
000006  e009              B        |L10.28|
                  |L10.8|
;;;227    	{
;;;228            if(uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk) /* Wait Tx empty and Time-out manner */
000008  699c              LDR      r4,[r3,#0x18]
00000a  2501              MOVS     r5,#1
00000c  05ed              LSLS     r5,r5,#23
00000e  402c              ANDS     r4,r4,r5
000010  2c00              CMP      r4,#0
000012  d000              BEQ      |L10.22|
                  |L10.20|
;;;229                return u32Count;
;;;230    
;;;231            uart->DAT = pu8TxBuf[u32Count];             /* Send UART Data from buffer */
;;;232        }
;;;233    
;;;234        return u32Count;
;;;235    }
000014  bd30              POP      {r4,r5,pc}
                  |L10.22|
000016  5c0c              LDRB     r4,[r1,r0]            ;231
000018  601c              STR      r4,[r3,#0]            ;231
00001a  1c40              ADDS     r0,r0,#1              ;226
                  |L10.28|
00001c  4290              CMP      r0,r2                 ;226
00001e  d1f3              BNE      |L10.8|
000020  bf00              NOP                            ;234
000022  e7f7              B        |L10.20|
;;;236    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 132
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
