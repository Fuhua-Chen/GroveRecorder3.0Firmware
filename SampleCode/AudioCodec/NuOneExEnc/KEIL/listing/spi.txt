; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\spi.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\spi.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\spi.crf ..\..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;63       */
;;;64     void SPI_Close(SPI_T *spi)
000000  4909              LDR      r1,|L1.40|
;;;65     {
;;;66         /* Reset SPI */
;;;67         if((uint32_t)spi == SPI0_BASE) 
000002  4288              CMP      r0,r1
000004  d10e              BNE      |L1.36|
;;;68     	{
;;;69             SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
000006  2105              MOVS     r1,#5
000008  0709              LSLS     r1,r1,#28
00000a  68c9              LDR      r1,[r1,#0xc]
00000c  1482              ASRS     r2,r0,#18
00000e  4311              ORRS     r1,r1,r2
000010  2205              MOVS     r2,#5
000012  0712              LSLS     r2,r2,#28
000014  60d1              STR      r1,[r2,#0xc]
;;;70             SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
000016  4611              MOV      r1,r2
000018  68c9              LDR      r1,[r1,#0xc]
00001a  1482              ASRS     r2,r0,#18
00001c  4391              BICS     r1,r1,r2
00001e  2205              MOVS     r2,#5
000020  0712              LSLS     r2,r2,#28
000022  60d1              STR      r1,[r2,#0xc]
                  |L1.36|
;;;71         }
;;;72     }
000024  4770              BX       lr
;;;73     
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40030000

                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=1

                  SPI_GetBusClock PROC
;;;127      */
;;;128    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
000002  4604              MOV      r4,r0
;;;130        uint32_t u32Div;
;;;131        uint32_t u32ApbClock;
;;;132    
;;;133        u32ApbClock = CLK_GetHCLKFreq();
000004  f7fffffe          BL       CLK_GetHCLKFreq
000008  4606              MOV      r6,r0
;;;134        u32Div = spi->CLKDIV & SPI_CLKDIV_DIVIDER0_Msk;
00000a  6860              LDR      r0,[r4,#4]
00000c  b285              UXTH     r5,r0
;;;135        return ((u32ApbClock>>1) / (u32Div + 1));
00000e  0870              LSRS     r0,r6,#1
000010  1c69              ADDS     r1,r5,#1
000012  f7fffffe          BL       __aeabi_uidivmod
;;;136    }
000016  bd70              POP      {r4-r6,pc}
;;;137    
                          ENDP


                          AREA ||i.SPI_GetVarClock||, CODE, READONLY, ALIGN=1

                  SPI_GetVarClock PROC
;;;142      */
;;;143    uint32_t SPI_GetVarClock(SPI_T *spi)
000000  b570              PUSH     {r4-r6,lr}
;;;144    {
000002  4604              MOV      r4,r0
;;;145    	uint32_t u32Div;
;;;146    	uint32_t u32ApbClock;
;;;147    
;;;148    	u32ApbClock = CLK_GetHCLKFreq();
000004  f7fffffe          BL       CLK_GetHCLKFreq
000008  4606              MOV      r6,r0
;;;149    	u32Div = (spi->CLKDIV&SPI_CLKDIV_DIVIDER1_Msk)>>SPI_CLKDIV_DIVIDER1_Pos;
00000a  6860              LDR      r0,[r4,#4]
00000c  0c05              LSRS     r5,r0,#16
;;;150    	return ((u32ApbClock>>1) / (u32Div+1));	
00000e  0870              LSRS     r0,r6,#1
000010  1c69              ADDS     r1,r5,#1
000012  f7fffffe          BL       __aeabi_uidivmod
;;;151    }
000016  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=1

                  SPI_Open PROC
;;;44       */
;;;45     uint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32BusClock, uint32_t u32VarClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;46     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;47     	/* Set configuration of master/slave mode, trigger mode */
;;;48     	spi->CTL = u32MasterSlave | u32SPIMode;
00000a  4628              MOV      r0,r5
00000c  4330              ORRS     r0,r0,r6
00000e  6020              STR      r0,[r4,#0]
;;;49     	
;;;50     	/* Set SPI variable clock */
;;;51     	SPI_SetVarClock(spi,u32VarClock);	
000010  4620              MOV      r0,r4
000012  9906              LDR      r1,[sp,#0x18]
000014  f7fffffe          BL       SPI_SetVarClock
;;;52     	
;;;53     	/* Set SPI bus clock */
;;;54     	SPI_SetBusClock(spi,u32BusClock);
000018  4639              MOV      r1,r7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_SetBusClock
;;;55     	
;;;56     	return SPI_GetBusClock(spi);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPI_GetBusClock
;;;57     }
000026  bdf8              POP      {r3-r7,pc}
;;;58     
                          ENDP


                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;79       */
;;;80     uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;81     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;82         uint32_t u32Pclk = CLK_GetHCLKFreq();
000006  f7fffffe          BL       CLK_GetHCLKFreq
00000a  4607              MOV      r7,r0
;;;83         uint32_t u32Div = 0xffff;
00000c  4d0f              LDR      r5,|L5.76|
;;;84     
;;;85         if(u32BusClock !=0 ) 
00000e  2e00              CMP      r6,#0
000010  d014              BEQ      |L5.60|
;;;86     	{
;;;87             u32Div = ((((2*u32Pclk)/u32BusClock)+1)>>2) - 1;
000012  0078              LSLS     r0,r7,#1
000014  4631              MOV      r1,r6
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1c40              ADDS     r0,r0,#1
00001c  0880              LSRS     r0,r0,#2
00001e  1e45              SUBS     r5,r0,#1
;;;88             if(u32Div > 0xFFFF)
000020  480a              LDR      r0,|L5.76|
000022  4285              CMP      r5,r0
000024  d901              BLS      |L5.42|
;;;89                 u32Div = 0xFFFF;
000026  4605              MOV      r5,r0
000028  e002              B        |L5.48|
                  |L5.42|
;;;90     		else if(u32Div < 1)
00002a  2d00              CMP      r5,#0
00002c  d100              BNE      |L5.48|
;;;91     			u32Div = 1;
00002e  2501              MOVS     r5,#1
                  |L5.48|
;;;92             spi->CLKDIV = (spi->CLKDIV & ~SPI_CLKDIV_DIVIDER0_Msk) | u32Div;
000030  6860              LDR      r0,[r4,#4]
000032  0c00              LSRS     r0,r0,#16
000034  0400              LSLS     r0,r0,#16
000036  4328              ORRS     r0,r0,r5
000038  6060              STR      r0,[r4,#4]
00003a  e001              B        |L5.64|
                  |L5.60|
;;;93         } 
;;;94     	else
;;;95             spi->CLKDIV = 0;
00003c  2000              MOVS     r0,#0
00003e  6060              STR      r0,[r4,#4]
                  |L5.64|
;;;96     
;;;97         return ( u32Pclk / ((u32Div+1)*2) );
000040  1c68              ADDS     r0,r5,#1
000042  0041              LSLS     r1,r0,#1
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       __aeabi_uidivmod
;;;98     }
00004a  bdf8              POP      {r3-r7,pc}
;;;99     
                          ENDP

                  |L5.76|
                          DCD      0x0000ffff

                          AREA ||i.SPI_SetVarClock||, CODE, READONLY, ALIGN=2

                  SPI_SetVarClock PROC
;;;105      */
;;;106    void SPI_SetVarClock(SPI_T *spi, uint32_t u32VarClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;107    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;108        uint32_t u32Pclk = CLK_GetHCLKFreq();
000006  f7fffffe          BL       CLK_GetHCLKFreq
00000a  4607              MOV      r7,r0
;;;109        uint32_t u32Div = 0xffff;
00000c  4d0d              LDR      r5,|L6.68|
;;;110    
;;;111        if(u32VarClock !=0 ) 
00000e  2e00              CMP      r6,#0
000010  d014              BEQ      |L6.60|
;;;112    	{
;;;113            u32Div = ((( u32Pclk / u32VarClock ) + 1) >> 1 ) - 1;
000012  4631              MOV      r1,r6
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1c40              ADDS     r0,r0,#1
00001c  0840              LSRS     r0,r0,#1
00001e  1e45              SUBS     r5,r0,#1
;;;114            if(u32Div > 0xFFFF)
000020  4808              LDR      r0,|L6.68|
000022  4285              CMP      r5,r0
000024  d901              BLS      |L6.42|
;;;115                u32Div = 0xFFFF;
000026  4605              MOV      r5,r0
000028  e002              B        |L6.48|
                  |L6.42|
;;;116    		else if(u32Div < 1)
00002a  2d00              CMP      r5,#0
00002c  d100              BNE      |L6.48|
;;;117    			u32Div = 1;
00002e  2501              MOVS     r5,#1
                  |L6.48|
;;;118            spi->CLKDIV = (spi->CLKDIV & ~SPI_CLKDIV_DIVIDER1_Msk) | (u32Div<<SPI_CLKDIV_DIVIDER1_Pos);
000030  6860              LDR      r0,[r4,#4]
000032  b280              UXTH     r0,r0
000034  0429              LSLS     r1,r5,#16
000036  4308              ORRS     r0,r0,r1
000038  6060              STR      r0,[r4,#4]
00003a  e001              B        |L6.64|
                  |L6.60|
;;;119        } else
;;;120            spi->CLKDIV = 0;
00003c  2000              MOVS     r0,#0
00003e  6060              STR      r0,[r4,#4]
                  |L6.64|
;;;121    }
000040  bdf8              POP      {r3-r7,pc}
;;;122    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x0000ffff

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 132
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
