; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\powerdown.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\powerdown.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\powerdown.crf ..\Powerdown.c]
                          THUMB

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;515     */
;;;516    __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;517    {
;;;518      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L1.16|
00000a  6011              STR      r1,[r2,#0]
;;;519    }
00000c  4770              BX       lr
;;;520    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;503     */
;;;504    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;505    {
;;;506      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;507    }
00000c  4770              BX       lr
;;;508    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe000e100

                          AREA ||i.PowerDown||, CODE, READONLY, ALIGN=1

                  PowerDown PROC
;;;273    
;;;274    void PowerDown(void)
000000  b510              PUSH     {r4,lr}
;;;275    {
;;;276    	
;;;277    	CLK_DeepSleep();
000002  f7fffffe          BL       CLK_DeepSleep
;;;278    	__wfi();
000006  bf30              WFI      
;;;279    	__isb(0);
000008  f3bf8f60          ISB      #0x0
;;;280    
;;;281    }
00000c  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.PowerDown_Enter||, CODE, READONLY, ALIGN=2

                  PowerDown_Enter PROC
;;;186    //---------------------------------------------------------------------------------------------------------
;;;187    void PowerDown_Enter(void)
000000  b510              PUSH     {r4,lr}
;;;188    {
;;;189    	// Add code for close IP function
;;;190    	
;;;191    #if( !defined(SPIFLASH_NONE) )
;;;192    	SPIFlash_PowerDown(&g_sSpiFlash,1);
000002  2101              MOVS     r1,#1
000004  481d              LDR      r0,|L4.124|
000006  f7fffffe          BL       SPIFlash_PowerDown
;;;193    	SPIFlash_Close(&g_sSpiFlash);
00000a  bf00              NOP      
00000c  491b              LDR      r1,|L4.124|
00000e  6808              LDR      r0,[r1,#0]
000010  f7fffffe          BL       SPI_Close
000014  bf00              NOP      
;;;194    	#if (defined(SPIFLASH_SPI1_DEVICE1))
;;;195    	CLK_DisableModuleClock(SPI1_MODULE);
;;;196    	#elif (defined(SPIFLASH_SPI0_DEVICE1))
;;;197    	CLK_DisableModuleClock(SPI0_MODULE);
000016  481a              LDR      r0,|L4.128|
000018  f7fffffe          BL       CLK_DisableModuleClock
;;;198    	#endif
;;;199    #endif
;;;200    	
;;;201    	SPK_UNINITIATE();
00001c  f7fffffe          BL       SPK_Close
;;;202    	MIC_UNINITIATE();
000020  f7fffffe          BL       MIC_Close
;;;203    	PDMA_UNINITIATE();
000024  f7fffffe          BL       PdmaCtrl_UnInit
;;;204    	TRIGGER_KEY_RESET();
000028  f7fffffe          BL       Keypad_ResetTgr
;;;205    	MATRIX_KEY_RESET();
;;;206    	NVIC_DisableIRQ(TMR1_IRQn);
00002c  2009              MOVS     r0,#9
00002e  f7fffffe          BL       NVIC_DisableIRQ
;;;207    	
;;;208    
;;;209    	// LED and key GPIO change output and driver hgih.
;;;210    	GPIO_SetMode(PA, MATRIX_PORTA_INPUT_PINS_MASK|MATRIX_PORTA_OUTPUT_PINS_MASK|TRIGGER_PORTA_PINS_MASK|OUTPUT_PORTA_PINS_MASK, GPIO_MODE_OUTPUT);
000032  2201              MOVS     r2,#1
000034  210f              MOVS     r1,#0xf
000036  0309              LSLS     r1,r1,#12
000038  4812              LDR      r0,|L4.132|
00003a  f7fffffe          BL       GPIO_SetMode
;;;211    	GPIO_SetMode(PB, MATRIX_PORTB_INPUT_PINS_MASK|MATRIX_PORTB_OUTPUT_PINS_MASK|TRIGGER_PORTB_PINS_MASK|OUTPUT_PORTB_PINS_MASK, GPIO_MODE_OUTPUT);
00003e  2201              MOVS     r2,#1
000040  21ff              MOVS     r1,#0xff
000042  4810              LDR      r0,|L4.132|
000044  3040              ADDS     r0,r0,#0x40
000046  f7fffffe          BL       GPIO_SetMode
;;;212    	GPIO_SET_OUT_DATA(PA, GPIO_GET_OUT_DATA(PA)|(MATRIX_PORTA_INPUT_PINS_MASK|MATRIX_PORTA_OUTPUT_PINS_MASK|TRIGGER_PORTA_PINS_MASK|OUTPUT_PORTA_PINS_MASK));
00004a  480e              LDR      r0,|L4.132|
00004c  6880              LDR      r0,[r0,#8]
00004e  210f              MOVS     r1,#0xf
000050  0309              LSLS     r1,r1,#12
000052  4308              ORRS     r0,r0,r1
000054  490b              LDR      r1,|L4.132|
000056  6088              STR      r0,[r1,#8]
;;;213    	GPIO_SET_OUT_DATA(PB, GPIO_GET_OUT_DATA(PB)|(MATRIX_PORTB_INPUT_PINS_MASK|MATRIX_PORTB_OUTPUT_PINS_MASK|TRIGGER_PORTB_PINS_MASK|OUTPUT_PORTB_PINS_MASK));
000058  480a              LDR      r0,|L4.132|
00005a  3040              ADDS     r0,r0,#0x40
00005c  6880              LDR      r0,[r0,#8]
00005e  21ff              MOVS     r1,#0xff
000060  4308              ORRS     r0,r0,r1
000062  4908              LDR      r1,|L4.132|
000064  3140              ADDS     r1,r1,#0x40
000066  6088              STR      r0,[r1,#8]
;;;214    
;;;215    	SYS->GPA_MFP = 0;
000068  2000              MOVS     r0,#0
00006a  2105              MOVS     r1,#5
00006c  0709              LSLS     r1,r1,#28
00006e  6388              STR      r0,[r1,#0x38]
;;;216    	SYS->GPB_MFP = 0;
000070  63c8              STR      r0,[r1,#0x3c]
;;;217    	
;;;218    	#if(WAKEUP_GPIO_TRIGGER)
;;;219    	PowerDown_GPIOPreProc();
000072  f7fffffe          BL       PowerDown_GPIOPreProc
;;;220    	#endif
;;;221    	
;;;222    	#if(WAKEUP_RTC_TRIGGER)
;;;223    	PowerDown_RTCPreProc();
;;;224    	#endif
;;;225    	
;;;226    	#if(WAKEUP_WDT_TRIGGER)
;;;227    	PowerDown_WDTPreProc();
;;;228    	#endif
;;;229    	
;;;230    	CLK_DisableLDO();
000076  f7fffffe          BL       CLK_DisableLDO
;;;231    
;;;232    }
00007a  bd10              POP      {r4,pc}
;;;233    
                          ENDP

                  |L4.124|
                          DCD      g_sSpiFlash
                  |L4.128|
                          DCD      0x4000000c
                  |L4.132|
                          DCD      0x50004000

                          AREA ||i.PowerDown_Exit||, CODE, READONLY, ALIGN=2

                  PowerDown_Exit PROC
;;;239    //---------------------------------------------------------------------------------------------------------
;;;240    void PowerDown_Exit(void)
000000  b510              PUSH     {r4,lr}
;;;241    {	
;;;242    	// Add code for open IP function
;;;243    	CLK_EnableLDO(CLK_LDOSEL_3_3V);
000002  2003              MOVS     r0,#3
000004  f7fffffe          BL       CLK_EnableLDO
;;;244    	
;;;245    #if(WAKEUP_WDT_TRIGGER)
;;;246    	PowerDown_WDTPostProc();
;;;247    #endif
;;;248    	
;;;249    #if(WAKEUP_RTC_TRIGGER)
;;;250    	PowerDown_RTCPostProc();
;;;251    #endif
;;;252    	
;;;253    #if(WAKEUP_GPIO_TRIGGER)
;;;254    	PowerDown_GPIOPostProc();
000008  f7fffffe          BL       PowerDown_GPIOPostProc
;;;255    #endif	
;;;256    	
;;;257    	OUTPUTPIN_INITIATE();
00000c  f7fffffe          BL       OutputPin_Initiate
;;;258    	KEYPAD_INITIATE();
000010  f7fffffe          BL       InputKey_Initiate
;;;259    	ULTRAIO_INITIATE();
;;;260    	PDMA_INITIATE();
000014  f7fffffe          BL       PdmaCtrl_Init
;;;261    	SPK_INITIATE();
000018  f7fffffe          BL       SPK_Open
;;;262    	MIC_INITIATE();
00001c  f7fffffe          BL       MIC_Open
;;;263    
;;;264    	
;;;265    #if( !defined(SPIFLASH_NONE) )
;;;266    	SPIFlash_Initiate();	
000020  f7fffffe          BL       SPIFlash_Initiate
;;;267    #endif
;;;268    
;;;269    	// Light stand by(PB8) led for initial ready().
;;;270    	OUT3(0);
000024  2200              MOVS     r2,#0
000026  2101              MOVS     r1,#1
000028  0389              LSLS     r1,r1,#14
00002a  4802              LDR      r0,|L5.52|
00002c  f7fffffe          BL       OutputPin_Set
;;;271    	
;;;272    }
000030  bd10              POP      {r4,pc}
;;;273    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x50004000

                          AREA ||i.PowerDown_GPIOConfigWakePin||, CODE, READONLY, ALIGN=2

                  PowerDown_GPIOConfigWakePin PROC
;;;42     //---------------------------------------------------------------------------------------------------------
;;;43     void PowerDown_GPIOConfigWakePin(GPIO_T *gpio, UINT32 u32PinMask, BOOL bEnable)
000000  b5f8              PUSH     {r3-r7,lr}
;;;44     {	
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;45     	UINT8 u8Tmp = 0;
000008  2400              MOVS     r4,#0
;;;46     	
;;;47     	while(u32PinMask>>u8Tmp)
00000a  e013              B        |L6.52|
                  |L6.12|
;;;48     	{
;;;49     		if((u32PinMask>>u8Tmp)&0x01)
00000c  4628              MOV      r0,r5
00000e  40e0              LSRS     r0,r0,r4
000010  07c0              LSLS     r0,r0,#31
000012  0fc0              LSRS     r0,r0,#31
000014  2800              CMP      r0,#0
000016  d00b              BEQ      |L6.48|
;;;50     		{
;;;51     			if(bEnable)
000018  2e00              CMP      r6,#0
00001a  d005              BEQ      |L6.40|
;;;52     				GPIO_EnableInt(gpio, u8Tmp, GPIO_INT_BOTH_EDGE);
00001c  4a08              LDR      r2,|L6.64|
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       GPIO_EnableInt
000026  e003              B        |L6.48|
                  |L6.40|
;;;53     			else
;;;54     				GPIO_DisableInt(gpio, u8Tmp);
000028  4621              MOV      r1,r4
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       GPIO_DisableInt
                  |L6.48|
;;;55     		}
;;;56     		u8Tmp++;
000030  1c60              ADDS     r0,r4,#1
000032  b2c4              UXTB     r4,r0
                  |L6.52|
000034  4628              MOV      r0,r5                 ;47
000036  40e0              LSRS     r0,r0,r4              ;47
000038  2800              CMP      r0,#0                 ;47
00003a  d1e7              BNE      |L6.12|
;;;57     	}
;;;58     }
00003c  bdf8              POP      {r3-r7,pc}
;;;59     
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x00010001

                          AREA ||i.PowerDown_GPIOPostProc||, CODE, READONLY, ALIGN=2

                  PowerDown_GPIOPostProc PROC
;;;90     //---------------------------------------------------------------------------------------------------------
;;;91     void PowerDown_GPIOPostProc(void)
000000  b510              PUSH     {r4,lr}
;;;92     {		
;;;93     	// Disable interrupt after wake up.
;;;94     	NVIC_DisableIRQ(GPAB_IRQn);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       NVIC_DisableIRQ
;;;95     	
;;;96     	#if(WAKEUP_GPIO_TRG_PA)
;;;97     	PowerDown_GPIOConfigWakePin(PA,WAKEUP_GPIO_TRG_PA,FALSE);
;;;98     	#endif
;;;99     	#if(WAKEUP_GPIO_TRG_PB)
;;;100    	PowerDown_GPIOConfigWakePin(PB,WAKEUP_GPIO_TRG_PB,FALSE);
000008  2200              MOVS     r2,#0
00000a  2108              MOVS     r1,#8
00000c  4803              LDR      r0,|L7.28|
00000e  f7fffffe          BL       PowerDown_GPIOConfigWakePin
;;;101    	#endif
;;;102    	
;;;103    	PowerDown_GPIOStableCount(WAKEUP_GPIO_TRG_PA,WAKEUP_GPIO_TRG_PB);
000012  2108              MOVS     r1,#8
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       PowerDown_GPIOStableCount
;;;104    }
00001a  bd10              POP      {r4,pc}
;;;105    
                          ENDP

                  |L7.28|
                          DCD      0x50004040

                          AREA ||i.PowerDown_GPIOPreProc||, CODE, READONLY, ALIGN=2

                  PowerDown_GPIOPreProc PROC
;;;63     //---------------------------------------------------------------------------------------------------------
;;;64     void PowerDown_GPIOPreProc(void)
000000  b510              PUSH     {r4,lr}
;;;65     {			
;;;66     	// If IO pin value is 0, system can't be wakeup by falling trigger, therefore wait for trigger pins value are all 1.
;;;67     	PowerDown_GPIOStableCount(WAKEUP_GPIO_TRG_PA,WAKEUP_GPIO_TRG_PB);
000002  2108              MOVS     r1,#8
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       PowerDown_GPIOStableCount
;;;68     	GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_HCLK, GPIO_DBCTL_DBCLKSEL_8);
00000a  2023              MOVS     r0,#0x23
00000c  490d              LDR      r1,|L8.68|
00000e  6008              STR      r0,[r1,#0]
;;;69     	
;;;70     	// set GPIO wakeup bit and GPIO QUASI mode
;;;71     	#if(WAKEUP_GPIO_TRG_PA)
;;;72     	GPIO_SetMode(PA, WAKEUP_GPIO_TRG_PA, GPIO_MODE_QUASI);
;;;73     	GPIO_ENABLE_DEBOUNCE(PA,WAKEUP_GPIO_TRG_PA);
;;;74     	PowerDown_GPIOConfigWakePin(PA,WAKEUP_GPIO_TRG_PA,TRUE);
;;;75     	#endif
;;;76     	#if(WAKEUP_GPIO_TRG_PB)
;;;77     	GPIO_SetMode(PB, WAKEUP_GPIO_TRG_PB, GPIO_MODE_QUASI);
000010  2203              MOVS     r2,#3
000012  2108              MOVS     r1,#8
000014  480c              LDR      r0,|L8.72|
000016  f7fffffe          BL       GPIO_SetMode
;;;78     	GPIO_ENABLE_DEBOUNCE(PB,WAKEUP_GPIO_TRG_PB);
00001a  480b              LDR      r0,|L8.72|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  2108              MOVS     r1,#8
000020  4308              ORRS     r0,r0,r1
000022  4909              LDR      r1,|L8.72|
000024  6148              STR      r0,[r1,#0x14]
;;;79     	PowerDown_GPIOConfigWakePin(PB,WAKEUP_GPIO_TRG_PB,TRUE);
000026  2201              MOVS     r2,#1
000028  2108              MOVS     r1,#8
00002a  4807              LDR      r0,|L8.72|
00002c  f7fffffe          BL       PowerDown_GPIOConfigWakePin
;;;80     	#endif
;;;81     
;;;82     	//Clear GPIO pending IRQ flag, enable interrupt for wake up.
;;;83     	NVIC_ClearPendingIRQ(GPAB_IRQn);
000030  2004              MOVS     r0,#4
000032  2101              MOVS     r1,#1
000034  4081              LSLS     r1,r1,r0
000036  4a05              LDR      r2,|L8.76|
000038  6011              STR      r1,[r2,#0]
00003a  bf00              NOP      
;;;84     	NVIC_EnableIRQ(GPAB_IRQn);
00003c  f7fffffe          BL       NVIC_EnableIRQ
;;;85     }
000040  bd10              POP      {r4,pc}
;;;86     
                          ENDP

000042  0000              DCW      0x0000
                  |L8.68|
                          DCD      0x50004180
                  |L8.72|
                          DCD      0x50004040
                  |L8.76|
                          DCD      0xe000e280

                          AREA ||i.PowerDown_GPIOStableCount||, CODE, READONLY, ALIGN=2

                  PowerDown_GPIOStableCount PROC
;;;20     //---------------------------------------------------------------------------------------------------------
;;;21     void PowerDown_GPIOStableCount(UINT32 u32GPAPinMask, UINT32 u32GPBPinMask)
000000  b570              PUSH     {r4-r6,lr}
;;;22     {	
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;23     	UINT32 u32Tmp = 0;	
000006  2600              MOVS     r6,#0
;;;24     	
;;;25     	// GPIO stable Count.
;;;26     	while( ++u32Tmp < POWERDOWN_GPIO_PIN_STABLE_COUNT )
000008  e00c              B        |L9.36|
                  |L9.10|
;;;27     	{
;;;28     		while( ( (GPIO_GET_IN_DATA(PA)&u32GPAPinMask) != u32GPAPinMask) || 
00000a  e000              B        |L9.14|
                  |L9.12|
;;;29     			   ( (GPIO_GET_IN_DATA(PB)&u32GPBPinMask) != u32GPBPinMask) )
;;;30     			u32Tmp = 0;
00000c  2600              MOVS     r6,#0
                  |L9.14|
00000e  480b              LDR      r0,|L9.60|
000010  6900              LDR      r0,[r0,#0x10]         ;28
000012  4020              ANDS     r0,r0,r4              ;28
000014  42a0              CMP      r0,r4                 ;28
000016  d1f9              BNE      |L9.12|
000018  4808              LDR      r0,|L9.60|
00001a  3040              ADDS     r0,r0,#0x40           ;29
00001c  6900              LDR      r0,[r0,#0x10]         ;29
00001e  4028              ANDS     r0,r0,r5              ;29
000020  42a8              CMP      r0,r5                 ;29
000022  d1f3              BNE      |L9.12|
                  |L9.36|
000024  1c70              ADDS     r0,r6,#1              ;26
000026  4606              MOV      r6,r0                 ;26
000028  4905              LDR      r1,|L9.64|
00002a  4288              CMP      r0,r1                 ;26
00002c  d3ed              BCC      |L9.10|
;;;31     	}
;;;32     	
;;;33     	// Delay 100 ms to wait.
;;;34     	CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLKSEL_HCLK_DIV2);
00002e  2038              MOVS     r0,#0x38
000030  f7fffffe          BL       CLK_SetSysTickClockSrc
;;;35     	CLK_SysTickDelay(100000);
000034  4803              LDR      r0,|L9.68|
000036  f7fffffe          BL       CLK_SysTickDelay
;;;36     }
00003a  bd70              POP      {r4-r6,pc}
;;;37     
                          ENDP

                  |L9.60|
                          DCD      0x50004000
                  |L9.64|
                          DCD      0x00001388
                  |L9.68|
                          DCD      0x000186a0

                          AREA ||i.PowerDown_RTCPostProc||, CODE, READONLY, ALIGN=2

                  PowerDown_RTCPostProc PROC
;;;142    //---------------------------------------------------------------------------------------------------------
;;;143    void PowerDown_RTCPostProc(void)
000000  b510              PUSH     {r4,lr}
;;;144    {
;;;145    	// Disable RTC interrupt and clock.
;;;146    	NVIC_DisableIRQ(RTC_IRQn);
000002  201f              MOVS     r0,#0x1f
000004  f7fffffe          BL       NVIC_DisableIRQ
;;;147    	RTC_DisableInt(RTC_INTEN_ALMIEN_Msk);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       RTC_DisableInt
;;;148    	RTC_Close();			  					
00000e  f7fffffe          BL       RTC_Close
;;;149    	CLK_DisableModuleClock(RTC_MODULE);
000012  4802              LDR      r0,|L10.28|
000014  f7fffffe          BL       CLK_DisableModuleClock
;;;150    }
000018  bd10              POP      {r4,pc}
;;;151    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40000005

                          AREA ||i.PowerDown_RTCPreProc||, CODE, READONLY, ALIGN=2

                  PowerDown_RTCPreProc PROC
;;;109    //---------------------------------------------------------------------------------------------------------
;;;110    void PowerDown_RTCPreProc(void)
000000  b500              PUSH     {lr}
;;;111    {	
000002  b089              SUB      sp,sp,#0x24
;;;112    	S_RTC_TIME_DATA_T sTime;
;;;113    	
;;;114    	sTime.u32Year = RTC_SYSTEM_TIME_YEAR;
000004  4816              LDR      r0,|L11.96|
000006  9000              STR      r0,[sp,#0]
;;;115    	sTime.u32Month = RTC_SYSTEM_TIME_MONTH;
000008  200c              MOVS     r0,#0xc
00000a  9001              STR      r0,[sp,#4]
;;;116    	sTime.u32Day = RTC_SYSTEM_TIME_DAY;
00000c  2001              MOVS     r0,#1
00000e  9002              STR      r0,[sp,#8]
;;;117    	sTime.u32DayOfWeek = RTC_SYSTEM_TIME_DAYOFWEEK;
000010  9003              STR      r0,[sp,#0xc]
;;;118    	sTime.u32Hour = RTC_SYSTEM_TIME_HOUR;
000012  2000              MOVS     r0,#0
000014  9004              STR      r0,[sp,#0x10]
;;;119    	sTime.u32Minute = RTC_SYSTEM_TIME_MINUTE;
000016  9005              STR      r0,[sp,#0x14]
;;;120    	sTime.u32Second = RTC_SYSTEM_TIME_SECOND;
000018  9006              STR      r0,[sp,#0x18]
;;;121    	sTime.u32TimeScale = RTC_CLOCK_24;
00001a  2001              MOVS     r0,#1
00001c  9007              STR      r0,[sp,#0x1c]
;;;122    	/* Initiate RTC & setting configuration */
;;;123    	CLK_EnableModuleClock(RTC_MODULE);
00001e  4811              LDR      r0,|L11.100|
000020  f7fffffe          BL       CLK_EnableModuleClock
;;;124    	CLK_SetModuleClock(RTC_MODULE,MODULE_NoMsk,MODULE_NoMsk);	
000024  2200              MOVS     r2,#0
000026  4611              MOV      r1,r2
000028  480e              LDR      r0,|L11.100|
00002a  f7fffffe          BL       CLK_SetModuleClock
;;;125    	RTC_Open(&sTime);
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       RTC_Open
;;;126    
;;;127    	sTime.u32Year = RTC_SYSTEM_TIME_YEAR+WAKEUP_RTC_TRG_TIME_YEAR;
000034  480a              LDR      r0,|L11.96|
000036  9000              STR      r0,[sp,#0]
;;;128    	sTime.u32Month = RTC_SYSTEM_TIME_MONTH+WAKEUP_RTC_TRG_TIME_MONTH;
000038  200c              MOVS     r0,#0xc
00003a  9001              STR      r0,[sp,#4]
;;;129    	sTime.u32Day = RTC_SYSTEM_TIME_DAY+WAKEUP_RTC_TRG_TIME_DAY;
00003c  2001              MOVS     r0,#1
00003e  9002              STR      r0,[sp,#8]
;;;130    	sTime.u32Hour = RTC_SYSTEM_TIME_HOUR+WAKEUP_RTC_TRG_TIME_HOUR;
000040  2000              MOVS     r0,#0
000042  9004              STR      r0,[sp,#0x10]
;;;131    	sTime.u32Minute = RTC_SYSTEM_TIME_MINUTE+WAKEUP_RTC_TRG_TIME_MINUTE;
000044  9005              STR      r0,[sp,#0x14]
;;;132    	sTime.u32Second = RTC_SYSTEM_TIME_SECOND+WAKEUP_RTC_TRG_TIME_SECOND;
000046  9006              STR      r0,[sp,#0x18]
;;;133        /* Enable RTC Alarm Interrupt */
;;;134    	RTC_SetAlarmDateAndTime(&sTime);
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       RTC_SetAlarmDateAndTime
;;;135        RTC_EnableInt(RTC_INTEN_ALMIEN_Msk);
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       RTC_EnableInt
;;;136        NVIC_EnableIRQ(RTC_IRQn);
000054  201f              MOVS     r0,#0x1f
000056  f7fffffe          BL       NVIC_EnableIRQ
;;;137    }
00005a  b009              ADD      sp,sp,#0x24
00005c  bd00              POP      {pc}
;;;138    
                          ENDP

00005e  0000              DCW      0x0000
                  |L11.96|
                          DCD      0x000007de
                  |L11.100|
                          DCD      0x40000005

                          AREA ||i.PowerDown_WDTPostProc||, CODE, READONLY, ALIGN=2

                  PowerDown_WDTPostProc PROC
;;;172    //---------------------------------------------------------------------------------------------------------
;;;173    void PowerDown_WDTPostProc(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175    	NVIC_DisableIRQ(WDT_IRQn);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       NVIC_DisableIRQ
;;;176    	WDT_DisableInt();
000008  f7fffffe          BL       WDT_DisableInt
;;;177    	WDT_Close();
00000c  f7fffffe          BL       WDT_Close
;;;178    	CLK_DisableModuleClock(WDT_MODULE);
000010  4801              LDR      r0,|L12.24|
000012  f7fffffe          BL       CLK_DisableModuleClock
;;;179    }
000016  bd10              POP      {r4,pc}
;;;180    
                          ENDP

                  |L12.24|
                          DCD      0x56000004

                          AREA ||i.PowerDown_WDTPreProc||, CODE, READONLY, ALIGN=2

                  PowerDown_WDTPreProc PROC
;;;155    //---------------------------------------------------------------------------------------------------------
;;;156    void PowerDown_WDTPreProc(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158    	CLK_EnableModuleClock(WDT_MODULE);
000002  480d              LDR      r0,|L13.56|
000004  f7fffffe          BL       CLK_EnableModuleClock
;;;159    	// Use RC OSC(max speed) to setting.
;;;160    	CLK_SetModuleClock(WDT_MODULE, CLK_CLKSEL1_WDTSEL_HIRC, MODULE_NoMsk); 	
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  480a              LDR      r0,|L13.56|
00000e  f7fffffe          BL       CLK_SetModuleClock
;;;161    	WDT_RESET_COUNTER();
000012  f7fffffe          BL       WDT_ResetCounter
;;;162    	WDT_CLEAR_TIMEOUT_INT_FLAG();
000016  f7fffffe          BL       WDT_ClearTimeOutIntFlag
;;;163     	WDT_Open(WAKEUP_WDT_TRG_TIMEOUT, 0);
00001a  2100              MOVS     r1,#0
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       WDT_Open
;;;164    	WDT_EnableInt();
000022  f7fffffe          BL       WDT_EnableInt
;;;165    	NVIC_EnableIRQ(WDT_IRQn);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       NVIC_EnableIRQ
;;;166    	CLK_SetModuleClock(WDT_MODULE, CLK_CLKSEL1_WDTSEL_LIRC, MODULE_NoMsk);
00002c  2200              MOVS     r2,#0
00002e  2103              MOVS     r1,#3
000030  4801              LDR      r0,|L13.56|
000032  f7fffffe          BL       CLK_SetModuleClock
;;;167    }
000036  bd10              POP      {r4,pc}
;;;168    
                          ENDP

                  |L13.56|
                          DCD      0x56000004

;*** Start embedded assembler ***

#line 1 "..\\Powerdown.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_Powerdown_c_d44ed6a2____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_Powerdown_c_d44ed6a2____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_Powerdown_c_d44ed6a2____REVSH|
#line 132
|__asm___11_Powerdown_c_d44ed6a2____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
