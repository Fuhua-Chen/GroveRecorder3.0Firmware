; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\object\pwm.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\object\pwm.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\..\..\..\Library\Device\Nuvoton\ISD9100\Include -I..\..\..\..\Library\Framework\inc -I..\..\..\..\Library\IO\inc -I..\..\..\..\Library\Audio\inc -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\Storage\inc -I..\..\..\..\Library\CMSIS\Include -I..\ -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -D__ISD9100__ --omf_browse=.\object\pwm.crf ..\..\..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearCaptureIntFlag PROC
;;;411     */
;;;412    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  b530              PUSH     {r4,r5,lr}
;;;413    {
;;;414        //clear capture interrupt flag, and clear CRLR or CFLR latched indicator
;;;415        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d20c              BCS      |L1.32|
;;;416            (pwm)->CAPCTL01 = ((pwm)->CAPCTL01 & PWM_CCR_MASK) | (PWM_CAPCTL01_CAPIF0_Msk << (u32ChannelNum * 16)) | (u32Edge << (u32ChannelNum * 16 + 5));
000006  6d03              LDR      r3,[r0,#0x50]
000008  4c06              LDR      r4,|L1.36|
00000a  4023              ANDS     r3,r3,r4
00000c  010d              LSLS     r5,r1,#4
00000e  2410              MOVS     r4,#0x10
000010  40ac              LSLS     r4,r4,r5
000012  4323              ORRS     r3,r3,r4
000014  010c              LSLS     r4,r1,#4
000016  1d64              ADDS     r4,r4,#5
000018  4615              MOV      r5,r2
00001a  40a5              LSLS     r5,r5,r4
00001c  432b              ORRS     r3,r3,r5
00001e  6503              STR      r3,[r0,#0x50]
                  |L1.32|
;;;417    }
000020  bd30              POP      {r4,r5,pc}
;;;418    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x000f000f

                          AREA ||i.PWM_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearIntFlag PROC
;;;473     */
;;;474    void PWM_ClearIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;475    {
;;;476        (pwm)->INTSTS = PWM_INTSTS_PIF0_Msk << u32ChannelNum;
000002  408a              LSLS     r2,r2,r1
000004  6442              STR      r2,[r0,#0x44]
;;;477    }
000006  4770              BX       lr
;;;478    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;34      */
;;;35     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;36                                       uint32_t u32ChannelNum,
;;;37                                       uint32_t u32UnitTimeNsec,
;;;38                                       uint32_t u32CaptureEdge)
;;;39     {
000002  b099              SUB      sp,sp,#0x64
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;40         uint32_t u32Src = 0;
000008  2000              MOVS     r0,#0
00000a  9018              STR      r0,[sp,#0x60]
;;;41         uint32_t u32PWMClockSrc;
;;;42         uint32_t u32PWMClkTbl[4] = {__LIRC, __LXT, 0, __HIRC};
00000c  4847              LDR      r0,|L3.300|
00000e  4601              MOV      r1,r0
000010  c90e              LDM      r1,{r1-r3}
000012  68c0              LDR      r0,[r0,#0xc]  ; <Data1>
000014  ae13              ADD      r6,sp,#0x4c
000016  c60e              STM      r6!,{r1-r3}
000018  9016              STR      r0,[sp,#0x58]
;;;43         uint32_t u32NearestUnitTimeNsec;
;;;44         uint8_t  u8Divider = 1;
00001a  2701              MOVS     r7,#1
;;;45         /* this table is mapping divider value to register configuration */
;;;46         uint32_t u32PWMDividerToRegTbl[17] = {NULL, 4, 0, NULL, 1, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 3};
00001c  2244              MOVS     r2,#0x44
00001e  4943              LDR      r1,|L3.300|
000020  3110              ADDS     r1,r1,#0x10
000022  a801              ADD      r0,sp,#4
000024  f7fffffe          BL       __aeabi_memcpy4
;;;47         uint16_t u16Prescale = 2;
000028  2602              MOVS     r6,#2
;;;48         uint16_t u16CNR = 0xFFFF;
00002a  4841              LDR      r0,|L3.304|
00002c  9000              STR      r0,[sp,#0]
;;;49     
;;;50         if(pwm == PWM0)
00002e  4841              LDR      r0,|L3.308|
000030  4284              CMP      r4,r0
000032  d10b              BNE      |L3.76|
;;;51             u32Src = (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM0CH01CKSEL_Msk << (u32ChannelNum >> 1))) >> (CLK_CLKSEL1_PWM0CH01CKSEL_Pos << (u32ChannelNum >> 1));
000034  4840              LDR      r0,|L3.312|
000036  6940              LDR      r0,[r0,#0x14]
000038  086a              LSRS     r2,r5,#1
00003a  2103              MOVS     r1,#3
00003c  0709              LSLS     r1,r1,#28
00003e  4091              LSLS     r1,r1,r2
000040  4008              ANDS     r0,r0,r1
000042  086a              LSRS     r2,r5,#1
000044  211c              MOVS     r1,#0x1c
000046  4091              LSLS     r1,r1,r2
000048  40c8              LSRS     r0,r0,r1
00004a  9018              STR      r0,[sp,#0x60]
                  |L3.76|
;;;52     
;;;53         if(u32Src == 2)
00004c  9818              LDR      r0,[sp,#0x60]
00004e  2802              CMP      r0,#2
000050  d105              BNE      |L3.94|
;;;54         {
;;;55             SystemCoreClockUpdate();
000052  f7fffffe          BL       SystemCoreClockUpdate
;;;56             u32PWMClockSrc = CLK_GetHCLKFreq();
000056  f7fffffe          BL       CLK_GetHCLKFreq
00005a  9017              STR      r0,[sp,#0x5c]
00005c  e004              B        |L3.104|
                  |L3.94|
;;;57         }
;;;58         else
;;;59         {
;;;60             u32PWMClockSrc = u32PWMClkTbl[u32Src];
00005e  9818              LDR      r0,[sp,#0x60]
000060  0080              LSLS     r0,r0,#2
000062  a913              ADD      r1,sp,#0x4c
000064  5808              LDR      r0,[r1,r0]
000066  9017              STR      r0,[sp,#0x5c]
                  |L3.104|
;;;61         }
;;;62     
;;;63         u32PWMClockSrc /= 1000;
000068  217d              MOVS     r1,#0x7d
00006a  00c9              LSLS     r1,r1,#3
00006c  9817              LDR      r0,[sp,#0x5c]
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  9017              STR      r0,[sp,#0x5c]
;;;64         for(; u16Prescale <= 0x100; u16Prescale++)
000074  e02a              B        |L3.204|
                  |L3.118|
;;;65         {
;;;66             u32NearestUnitTimeNsec = (1000000 * u16Prescale * u8Divider) / u32PWMClockSrc;
000076  4631              MOV      r1,r6
000078  4a30              LDR      r2,|L3.316|
00007a  4351              MULS     r1,r2,r1
00007c  4379              MULS     r1,r7,r1
00007e  4608              MOV      r0,r1
000080  9917              LDR      r1,[sp,#0x5c]
000082  f7fffffe          BL       __aeabi_uidivmod
000086  9012              STR      r0,[sp,#0x48]
;;;67             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
000088  991b              LDR      r1,[sp,#0x6c]
00008a  9812              LDR      r0,[sp,#0x48]
00008c  4288              CMP      r0,r1
00008e  d21a              BCS      |L3.198|
;;;68             {
;;;69                 if((u16Prescale == 0x100) && (u8Divider == 16))  //limit to the maximum unit time(nano second)
000090  20ff              MOVS     r0,#0xff
000092  3001              ADDS     r0,#1
000094  4286              CMP      r6,r0
000096  d102              BNE      |L3.158|
000098  2f10              CMP      r7,#0x10
00009a  d100              BNE      |L3.158|
;;;70                     break;
00009c  e01a              B        |L3.212|
                  |L3.158|
;;;71                 if(u16Prescale == 0x100)
00009e  20ff              MOVS     r0,#0xff
0000a0  3001              ADDS     r0,#1
0000a2  4286              CMP      r6,r0
0000a4  d103              BNE      |L3.174|
;;;72                 {
;;;73                     u16Prescale = 2;
0000a6  2602              MOVS     r6,#2
;;;74                     u8Divider <<= 1; // clk divider could only be 1, 2, 4, 8, 16
0000a8  0678              LSLS     r0,r7,#25
0000aa  0e07              LSRS     r7,r0,#24
;;;75                     continue;
0000ac  e00c              B        |L3.200|
                  |L3.174|
;;;76                 }
;;;77                 if(!((1000000  * ((u16Prescale * u8Divider) + 1)) > (u32NearestUnitTimeNsec * u32PWMClockSrc)))
0000ae  4630              MOV      r0,r6
0000b0  4378              MULS     r0,r7,r0
0000b2  1c40              ADDS     r0,r0,#1
0000b4  4921              LDR      r1,|L3.316|
0000b6  4341              MULS     r1,r0,r1
0000b8  9a17              LDR      r2,[sp,#0x5c]
0000ba  9812              LDR      r0,[sp,#0x48]
0000bc  4350              MULS     r0,r2,r0
0000be  4281              CMP      r1,r0
0000c0  d800              BHI      |L3.196|
;;;78                     break;
0000c2  e007              B        |L3.212|
                  |L3.196|
;;;79                 continue;
0000c4  e000              B        |L3.200|
                  |L3.198|
;;;80             }
;;;81             break;
0000c6  e005              B        |L3.212|
                  |L3.200|
0000c8  1c70              ADDS     r0,r6,#1              ;64
0000ca  b286              UXTH     r6,r0                 ;64
                  |L3.204|
0000cc  20ff              MOVS     r0,#0xff              ;64
0000ce  3001              ADDS     r0,#1                 ;64
0000d0  4286              CMP      r6,r0                 ;64
0000d2  ddd0              BLE      |L3.118|
                  |L3.212|
0000d4  bf00              NOP                            ;70
;;;82         }
;;;83     
;;;84         // Store return value here 'cos we're gonna change u8Divider & u16Prescale & u16CNR to the real value to fill into register
;;;85         u16Prescale -= 1;
0000d6  1e70              SUBS     r0,r6,#1
0000d8  b286              UXTH     r6,r0
;;;86     
;;;87         // convert to real register value
;;;88         u8Divider = u32PWMDividerToRegTbl[u8Divider];
0000da  00b8              LSLS     r0,r7,#2
0000dc  a901              ADD      r1,sp,#4
0000de  5c0f              LDRB     r7,[r1,r0]
;;;89     
;;;90         // every two channels share a prescaler
;;;91         (pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << ((u32ChannelNum >> 1) * 8))) | (u16Prescale << ((u32ChannelNum >> 1) * 8));
0000e0  6820              LDR      r0,[r4,#0]
0000e2  0869              LSRS     r1,r5,#1
0000e4  00ca              LSLS     r2,r1,#3
0000e6  21ff              MOVS     r1,#0xff
0000e8  4091              LSLS     r1,r1,r2
0000ea  4388              BICS     r0,r0,r1
0000ec  0869              LSRS     r1,r5,#1
0000ee  00ca              LSLS     r2,r1,#3
0000f0  4631              MOV      r1,r6
0000f2  4091              LSLS     r1,r1,r2
0000f4  4308              ORRS     r0,r0,r1
0000f6  6020              STR      r0,[r4,#0]
;;;92         (pwm)->CLKDIV = ((pwm)->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
0000f8  6860              LDR      r0,[r4,#4]
0000fa  00aa              LSLS     r2,r5,#2
0000fc  2107              MOVS     r1,#7
0000fe  4091              LSLS     r1,r1,r2
000100  4388              BICS     r0,r0,r1
000102  00aa              LSLS     r2,r5,#2
000104  4639              MOV      r1,r7
000106  4091              LSLS     r1,r1,r2
000108  4308              ORRS     r0,r0,r1
00010a  6060              STR      r0,[r4,#4]
;;;93         // set PWM to edge aligned type
;;;94         //(pwm)->CTL &= ~(PWM_PCR_PWM01TYPE_Msk << (u32ChannelNum >> 1));
;;;95         (pwm)->CTL |= PWM_CTL_CNTMODE0_Msk << (8 * u32ChannelNum);
00010c  68a0              LDR      r0,[r4,#8]
00010e  00ea              LSLS     r2,r5,#3
000110  2108              MOVS     r1,#8
000112  4091              LSLS     r1,r1,r2
000114  4308              ORRS     r0,r0,r1
000116  60a0              STR      r0,[r4,#8]
;;;96         *((__IO uint32_t *)((((uint32_t) & ((pwm)->PERIOD0)) + (u32ChannelNum) * 12))) = u16CNR;
000118  210c              MOVS     r1,#0xc
00011a  4369              MULS     r1,r5,r1
00011c  4622              MOV      r2,r4
00011e  320c              ADDS     r2,r2,#0xc
000120  9800              LDR      r0,[sp,#0]
000122  5050              STR      r0,[r2,r1]
;;;97     
;;;98         return (u32NearestUnitTimeNsec);
000124  9812              LDR      r0,[sp,#0x48]
;;;99     }
000126  b01d              ADD      sp,sp,#0x74
000128  bdf0              POP      {r4-r7,pc}
;;;100    
                          ENDP

00012a  0000              DCW      0x0000
                  |L3.300|
                          DCD      ||.constdata||
                  |L3.304|
                          DCD      0x0000ffff
                  |L3.308|
                          DCD      0x40040000
                  |L3.312|
                          DCD      0x50000200
                  |L3.316|
                          DCD      0x000f4240

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;111     */
;;;112    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;113                                     uint32_t u32ChannelNum,
;;;114                                     uint32_t u32Frequency,
;;;115                                     uint32_t u32DutyCycle)
;;;116    {
000002  b09b              SUB      sp,sp,#0x6c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;117        uint32_t u32Src = 0;
000008  2000              MOVS     r0,#0
00000a  901a              STR      r0,[sp,#0x68]
;;;118        uint32_t u32PWMClockSrc;
;;;119        uint32_t u32PWMClkTbl[4] = {__LIRC, __LXT, 0, __HIRC};
00000c  4852              LDR      r0,|L4.344|
00000e  4601              MOV      r1,r0
000010  c90e              LDM      r1,{r1-r3}
000012  68c0              LDR      r0,[r0,#0xc]  ; <Data5>
000014  ae15              ADD      r6,sp,#0x54
000016  c60e              STM      r6!,{r1-r3}
000018  9018              STR      r0,[sp,#0x60]
;;;120        uint32_t i;
;;;121        uint8_t  u8Divider = 1, u8Prescale = 0xFF;
00001a  2701              MOVS     r7,#1
00001c  20ff              MOVS     r0,#0xff
00001e  9014              STR      r0,[sp,#0x50]
;;;122        /* this table is mapping divider value to register configuration */
;;;123        uint32_t u32PWMDividerToRegTbl[17] = {NULL, 4, 0, NULL, 1, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 3};
000020  2244              MOVS     r2,#0x44
000022  494d              LDR      r1,|L4.344|
000024  3110              ADDS     r1,r1,#0x10
000026  a803              ADD      r0,sp,#0xc
000028  f7fffffe          BL       __aeabi_memcpy4
;;;124        uint16_t u16CNR = 0xFFFF;
00002c  484b              LDR      r0,|L4.348|
00002e  9002              STR      r0,[sp,#8]
;;;125    
;;;126        if(pwm == PWM0)
000030  484b              LDR      r0,|L4.352|
000032  4284              CMP      r4,r0
000034  d10b              BNE      |L4.78|
;;;127            u32Src = (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM0CH01CKSEL_Msk << (u32ChannelNum >> 1))) >> (CLK_CLKSEL1_PWM0CH01CKSEL_Pos << (u32ChannelNum >> 1));
000036  484b              LDR      r0,|L4.356|
000038  6940              LDR      r0,[r0,#0x14]
00003a  086a              LSRS     r2,r5,#1
00003c  2103              MOVS     r1,#3
00003e  0709              LSLS     r1,r1,#28
000040  4091              LSLS     r1,r1,r2
000042  4008              ANDS     r0,r0,r1
000044  086a              LSRS     r2,r5,#1
000046  211c              MOVS     r1,#0x1c
000048  4091              LSLS     r1,r1,r2
00004a  40c8              LSRS     r0,r0,r1
00004c  901a              STR      r0,[sp,#0x68]
                  |L4.78|
;;;128    
;;;129        if(u32Src == 2)
00004e  981a              LDR      r0,[sp,#0x68]
000050  2802              CMP      r0,#2
000052  d105              BNE      |L4.96|
;;;130        {
;;;131            SystemCoreClockUpdate();
000054  f7fffffe          BL       SystemCoreClockUpdate
;;;132            u32PWMClockSrc = CLK_GetHCLKFreq();
000058  f7fffffe          BL       CLK_GetHCLKFreq
00005c  9019              STR      r0,[sp,#0x64]
00005e  e004              B        |L4.106|
                  |L4.96|
;;;133        }
;;;134        else
;;;135        {
;;;136            u32PWMClockSrc = u32PWMClkTbl[u32Src];
000060  981a              LDR      r0,[sp,#0x68]
000062  0080              LSLS     r0,r0,#2
000064  a915              ADD      r1,sp,#0x54
000066  5808              LDR      r0,[r1,r0]
000068  9019              STR      r0,[sp,#0x64]
                  |L4.106|
;;;137        }
;;;138    
;;;139        for(; u8Divider < 17; u8Divider <<= 1)    // clk divider could only be 1, 2, 4, 8, 16
00006a  e02b              B        |L4.196|
                  |L4.108|
;;;140        {
;;;141            i = (u32PWMClockSrc / u32Frequency) / u8Divider;
00006c  991d              LDR      r1,[sp,#0x74]
00006e  9819              LDR      r0,[sp,#0x64]
000070  f7fffffe          BL       __aeabi_uidivmod
000074  4639              MOV      r1,r7
000076  9001              STR      r0,[sp,#4]
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  4606              MOV      r6,r0
;;;142            // If target value is larger than CNR * prescale, need to use a larger divider
;;;143            if(i > (0x10000 * 0x100))
00007e  2001              MOVS     r0,#1
000080  0600              LSLS     r0,r0,#24
000082  4286              CMP      r6,r0
000084  d900              BLS      |L4.136|
;;;144                continue;
000086  e01b              B        |L4.192|
                  |L4.136|
;;;145    
;;;146            // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;147            u8Prescale = (i + 0xFFFF) / 0x10000;
000088  4834              LDR      r0,|L4.348|
00008a  1830              ADDS     r0,r6,r0
00008c  0200              LSLS     r0,r0,#8
00008e  0e00              LSRS     r0,r0,#24
000090  9014              STR      r0,[sp,#0x50]
;;;148    
;;;149            // u8Prescale must at least be 2, otherwise the output stop
;;;150            if(u8Prescale < 3)
000092  9814              LDR      r0,[sp,#0x50]
000094  2803              CMP      r0,#3
000096  da01              BGE      |L4.156|
;;;151                u8Prescale = 2;
000098  2002              MOVS     r0,#2
00009a  9014              STR      r0,[sp,#0x50]
                  |L4.156|
;;;152    
;;;153            i /= u8Prescale;
00009c  4630              MOV      r0,r6
00009e  9914              LDR      r1,[sp,#0x50]
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  4606              MOV      r6,r0
;;;154    
;;;155            if(i <= 0x10000)
0000a6  2001              MOVS     r0,#1
0000a8  0400              LSLS     r0,r0,#16
0000aa  4286              CMP      r6,r0
0000ac  d807              BHI      |L4.190|
;;;156            {
;;;157                if(i == 1)
0000ae  2e01              CMP      r6,#1
0000b0  d102              BNE      |L4.184|
;;;158                    u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
0000b2  2001              MOVS     r0,#1
0000b4  9002              STR      r0,[sp,#8]
0000b6  e001              B        |L4.188|
                  |L4.184|
;;;159                else
;;;160                    u16CNR = i;
0000b8  b2b0              UXTH     r0,r6
0000ba  9002              STR      r0,[sp,#8]
                  |L4.188|
;;;161                break;
0000bc  e004              B        |L4.200|
                  |L4.190|
0000be  bf00              NOP                            ;144
                  |L4.192|
0000c0  0678              LSLS     r0,r7,#25             ;139
0000c2  0e07              LSRS     r7,r0,#24             ;139
                  |L4.196|
0000c4  2f11              CMP      r7,#0x11              ;139
0000c6  dbd1              BLT      |L4.108|
                  |L4.200|
0000c8  bf00              NOP      
;;;162            }
;;;163        }
;;;164        // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;165        i = u32PWMClockSrc / (u8Prescale * u8Divider * u16CNR);
0000ca  9814              LDR      r0,[sp,#0x50]
0000cc  4378              MULS     r0,r7,r0
0000ce  9a02              LDR      r2,[sp,#8]
0000d0  4350              MULS     r0,r2,r0
0000d2  4601              MOV      r1,r0
0000d4  9819              LDR      r0,[sp,#0x64]
0000d6  f7fffffe          BL       __aeabi_uidivmod
0000da  4606              MOV      r6,r0
;;;166    
;;;167        u8Prescale -= 1;
0000dc  9814              LDR      r0,[sp,#0x50]
0000de  1e40              SUBS     r0,r0,#1
0000e0  b2c0              UXTB     r0,r0
0000e2  9014              STR      r0,[sp,#0x50]
;;;168        u16CNR -= 1;
0000e4  9802              LDR      r0,[sp,#8]
0000e6  1e40              SUBS     r0,r0,#1
0000e8  b280              UXTH     r0,r0
0000ea  9002              STR      r0,[sp,#8]
;;;169        // convert to real register value
;;;170        u8Divider = u32PWMDividerToRegTbl[u8Divider];
0000ec  00b8              LSLS     r0,r7,#2
0000ee  a903              ADD      r1,sp,#0xc
0000f0  5c0f              LDRB     r7,[r1,r0]
;;;171    
;;;172        // every two channels share a prescaler
;;;173        (pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
0000f2  6820              LDR      r0,[r4,#0]
0000f4  0869              LSRS     r1,r5,#1
0000f6  00ca              LSLS     r2,r1,#3
0000f8  21ff              MOVS     r1,#0xff
0000fa  4091              LSLS     r1,r1,r2
0000fc  4388              BICS     r0,r0,r1
0000fe  0869              LSRS     r1,r5,#1
000100  00ca              LSLS     r2,r1,#3
000102  9914              LDR      r1,[sp,#0x50]
000104  4091              LSLS     r1,r1,r2
000106  4308              ORRS     r0,r0,r1
000108  6020              STR      r0,[r4,#0]
;;;174        (pwm)->CLKDIV = ((pwm)->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
00010a  6860              LDR      r0,[r4,#4]
00010c  00aa              LSLS     r2,r5,#2
00010e  2107              MOVS     r1,#7
000110  4091              LSLS     r1,r1,r2
000112  4388              BICS     r0,r0,r1
000114  00aa              LSLS     r2,r5,#2
000116  4639              MOV      r1,r7
000118  4091              LSLS     r1,r1,r2
00011a  4308              ORRS     r0,r0,r1
00011c  6060              STR      r0,[r4,#4]
;;;175        // set PWM to edge aligned type
;;;176        //(pwm)->CTL &= ~(PWM_PCR_PWM01TYPE_Msk << (u32ChannelNum >> 1));
;;;177        (pwm)->CTL |= PWM_CTL_CNTMODE0_Msk << (8 * u32ChannelNum);
00011e  68a0              LDR      r0,[r4,#8]
000120  00ea              LSLS     r2,r5,#3
000122  2108              MOVS     r1,#8
000124  4091              LSLS     r1,r1,r2
000126  4308              ORRS     r0,r0,r1
000128  60a0              STR      r0,[r4,#8]
;;;178        *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMPDAT0)) + u32ChannelNum * 12))) = u32DutyCycle * (u16CNR + 1) / 100 - 1;
00012a  9a02              LDR      r2,[sp,#8]
00012c  1c52              ADDS     r2,r2,#1
00012e  991e              LDR      r1,[sp,#0x78]
000130  4351              MULS     r1,r2,r1
000132  4608              MOV      r0,r1
000134  2164              MOVS     r1,#0x64
000136  f7fffffe          BL       __aeabi_uidivmod
00013a  1e40              SUBS     r0,r0,#1
00013c  210c              MOVS     r1,#0xc
00013e  4369              MULS     r1,r5,r1
000140  4622              MOV      r2,r4
000142  3210              ADDS     r2,r2,#0x10
000144  5050              STR      r0,[r2,r1]
;;;179        *((__IO uint32_t *)((((uint32_t) & ((pwm)->PERIOD0)) + (u32ChannelNum) * 12))) = u16CNR;
000146  210c              MOVS     r1,#0xc
000148  4369              MULS     r1,r5,r1
00014a  1f12              SUBS     r2,r2,#4
00014c  9802              LDR      r0,[sp,#8]
00014e  5050              STR      r0,[r2,r1]
;;;180    
;;;181        return(i);
000150  4630              MOV      r0,r6
;;;182    }
000152  b01f              ADD      sp,sp,#0x7c
000154  bdf0              POP      {r4-r7,pc}
;;;183    
                          ENDP

000156  0000              DCW      0x0000
                  |L4.344|
                          DCD      ||.constdata||+0x54
                  |L4.348|
                          DCD      0x0000ffff
                  |L4.352|
                          DCD      0x40040000
                  |L4.356|
                          DCD      0x50000200

                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;285     */
;;;286    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;287    {
000002  460a              MOV      r2,r1
;;;288        uint32_t i;
;;;289        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  2100              MOVS     r1,#0
000006  e00d              B        |L5.36|
                  |L5.8|
;;;290        {
;;;291            if(u32ChannelMask & (1 << i))
000008  2301              MOVS     r3,#1
00000a  408b              LSLS     r3,r3,r1
00000c  4013              ANDS     r3,r3,r2
00000e  2b00              CMP      r3,#0
000010  d007              BEQ      |L5.34|
;;;292            {
;;;293                if(i < 2)
000012  2902              CMP      r1,#2
000014  d205              BCS      |L5.34|
;;;294                {
;;;295                    (pwm)->CAPCTL01 &= ~(PWM_CAPCTL01_CAPEN0_Msk << (i * 16));
000016  6d03              LDR      r3,[r0,#0x50]
000018  010d              LSLS     r5,r1,#4
00001a  2408              MOVS     r4,#8
00001c  40ac              LSLS     r4,r4,r5
00001e  43a3              BICS     r3,r3,r4
000020  6503              STR      r3,[r0,#0x50]
                  |L5.34|
000022  1c49              ADDS     r1,r1,#1              ;289
                  |L5.36|
000024  2902              CMP      r1,#2                 ;289
000026  d3ef              BCC      |L5.8|
;;;296                }
;;;297            }
;;;298        }
;;;299        (pwm)->CAPINEN &= ~u32ChannelMask;
000028  6f83              LDR      r3,[r0,#0x78]
00002a  4393              BICS     r3,r3,r2
00002c  6783              STR      r3,[r0,#0x78]
;;;300    }
00002e  bd30              POP      {r4,r5,pc}
;;;301    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;394     */
;;;395    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  b530              PUSH     {r4,r5,lr}
;;;396    {
;;;397        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d206              BCS      |L6.20|
;;;398            (pwm)->CAPCTL01 &= u32Edge << ~(u32ChannelNum * 16);
000006  6d03              LDR      r3,[r0,#0x50]
000008  010c              LSLS     r4,r1,#4
00000a  43e5              MVNS     r5,r4
00000c  4614              MOV      r4,r2
00000e  40ac              LSLS     r4,r4,r5
000010  4023              ANDS     r3,r3,r4
000012  6503              STR      r3,[r0,#0x50]
                  |L6.20|
;;;399    }
000014  bd30              POP      {r4,r5,pc}
;;;400    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;357     */
;;;358    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
000000  0849              LSRS     r1,r1,#1
;;;359    {
;;;360        // every two channels shares the same setting
;;;361        u32ChannelNum >>= 1;
;;;362        // enable dead zone
;;;363        (pwm)->CTL &= ~(PWM_CTL_DTEN01_Msk << u32ChannelNum);
000002  6882              LDR      r2,[r0,#8]
000004  2310              MOVS     r3,#0x10
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6082              STR      r2,[r0,#8]
;;;364    }
00000c  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.PWM_DisableInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableInt PROC
;;;460     */
;;;461    void PWM_DisableInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c02              LDR      r2,[r0,#0x40]
;;;462    {
;;;463        (pwm)->INTEN &= ~(PWM_INTEN_PIEN0_Msk << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  6402              STR      r2,[r0,#0x40]
;;;464    }
00000a  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;324     */
;;;325    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  6fc2              LDR      r2,[r0,#0x7c]
;;;326    {
;;;327        (pwm)->POEN &= ~u32ChannelMask;
000002  438a              BICS     r2,r2,r1
000004  67c2              STR      r2,[r0,#0x7c]
;;;328    }
000006  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;260     */
;;;261    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;262    {
000002  460a              MOV      r2,r1
;;;263        uint32_t i;
;;;264        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  2100              MOVS     r1,#0
000006  e00d              B        |L10.36|
                  |L10.8|
;;;265        {
;;;266            if(u32ChannelMask & (1 << i))
000008  2301              MOVS     r3,#1
00000a  408b              LSLS     r3,r3,r1
00000c  4013              ANDS     r3,r3,r2
00000e  2b00              CMP      r3,#0
000010  d007              BEQ      |L10.34|
;;;267            {
;;;268                if(i < 2)
000012  2902              CMP      r1,#2
000014  d205              BCS      |L10.34|
;;;269                {
;;;270                    (pwm)->CAPCTL01 |= PWM_CAPCTL01_CAPEN0_Msk << (i * 16);
000016  6d03              LDR      r3,[r0,#0x50]
000018  010d              LSLS     r5,r1,#4
00001a  2408              MOVS     r4,#8
00001c  40ac              LSLS     r4,r4,r5
00001e  4323              ORRS     r3,r3,r4
000020  6503              STR      r3,[r0,#0x50]
                  |L10.34|
000022  1c49              ADDS     r1,r1,#1              ;264
                  |L10.36|
000024  2902              CMP      r1,#2                 ;264
000026  d3ef              BCC      |L10.8|
;;;271                }
;;;272            }
;;;273        }
;;;274        (pwm)->CAPINEN |= u32ChannelMask;
000028  6f83              LDR      r3,[r0,#0x78]
00002a  4313              ORRS     r3,r3,r2
00002c  6783              STR      r3,[r0,#0x78]
;;;275    }
00002e  bd30              POP      {r4,r5,pc}
;;;276    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;376     */
;;;377    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  b530              PUSH     {r4,r5,lr}
;;;378    {
;;;379        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d205              BCS      |L11.18|
;;;380            (pwm)->CAPCTL01 |= u32Edge << (u32ChannelNum * 16);
000006  6d03              LDR      r3,[r0,#0x50]
000008  010d              LSLS     r5,r1,#4
00000a  4614              MOV      r4,r2
00000c  40ac              LSLS     r4,r4,r5
00000e  4323              ORRS     r3,r3,r4
000010  6503              STR      r3,[r0,#0x50]
                  |L11.18|
;;;381    
;;;382    }
000012  bd30              POP      {r4,r5,pc}
;;;383    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;339     */
;;;340    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  b530              PUSH     {r4,r5,lr}
;;;341    {
;;;342        // every two channels shares the same setting
;;;343        u32ChannelNum >>= 1;
000002  0849              LSRS     r1,r1,#1
;;;344        // set duration
;;;345        (pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_DTCNT01_Msk << (8 * u32ChannelNum))) | (u32Duration << (PWM_CLKPSC_DTCNT01_Pos + 8 * u32ChannelNum));
000004  6803              LDR      r3,[r0,#0]
000006  00cd              LSLS     r5,r1,#3
000008  24ff              MOVS     r4,#0xff
00000a  0424              LSLS     r4,r4,#16
00000c  40ac              LSLS     r4,r4,r5
00000e  43a3              BICS     r3,r3,r4
000010  00cc              LSLS     r4,r1,#3
000012  3410              ADDS     r4,r4,#0x10
000014  4615              MOV      r5,r2
000016  40a5              LSLS     r5,r5,r4
000018  432b              ORRS     r3,r3,r5
00001a  6003              STR      r3,[r0,#0]
;;;346        // enable dead zone
;;;347        (pwm)->CTL |= (PWM_CTL_DTEN01_Msk << u32ChannelNum);
00001c  6883              LDR      r3,[r0,#8]
00001e  2410              MOVS     r4,#0x10
000020  408c              LSLS     r4,r4,r1
000022  4323              ORRS     r3,r3,r4
000024  6083              STR      r3,[r0,#8]
;;;348    }
000026  bd30              POP      {r4,r5,pc}
;;;349    
                          ENDP


                          AREA ||i.PWM_EnableInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableInt PROC
;;;447     */
;;;448    void PWM_EnableInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntType)
000000  b510              PUSH     {r4,lr}
;;;449    {
;;;450        (pwm)->INTEN |= (PWM_INTEN_PIEN0_Msk << u32ChannelNum);
000002  6c03              LDR      r3,[r0,#0x40]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  4323              ORRS     r3,r3,r4
00000a  6403              STR      r3,[r0,#0x40]
;;;451    }
00000c  bd10              POP      {r4,pc}
;;;452    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;310     */
;;;311    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  6fc2              LDR      r2,[r0,#0x7c]
;;;312    {
;;;313        (pwm)->POEN |= u32ChannelMask;
000002  430a              ORRS     r2,r2,r1
000004  67c2              STR      r2,[r0,#0x7c]
;;;314    }
000006  4770              BX       lr
;;;315    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;237     */
;;;238    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;239    {
000002  4602              MOV      r2,r0
;;;240        uint32_t u32Mask = 0, i;
000004  2300              MOVS     r3,#0
;;;241        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000006  2000              MOVS     r0,#0
000008  e009              B        |L15.30|
                  |L15.10|
;;;242        {
;;;243            if(u32ChannelMask & (1 << i))
00000a  2401              MOVS     r4,#1
00000c  4084              LSLS     r4,r4,r0
00000e  400c              ANDS     r4,r4,r1
000010  2c00              CMP      r4,#0
000012  d003              BEQ      |L15.28|
;;;244            {
;;;245                u32Mask |= (PWM_CTL_CNTEN0_Msk << (i * 8));
000014  00c5              LSLS     r5,r0,#3
000016  2401              MOVS     r4,#1
000018  40ac              LSLS     r4,r4,r5
00001a  4323              ORRS     r3,r3,r4
                  |L15.28|
00001c  1c40              ADDS     r0,r0,#1              ;241
                  |L15.30|
00001e  2802              CMP      r0,#2                 ;241
000020  d3f3              BCC      |L15.10|
;;;246            }
;;;247        }
;;;248    
;;;249        (pwm)->CTL &= ~u32Mask;
000022  6894              LDR      r4,[r2,#8]
000024  439c              BICS     r4,r4,r3
000026  6094              STR      r4,[r2,#8]
;;;250    }
000028  bd30              POP      {r4,r5,pc}
;;;251    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;429     */
;;;430    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  b510              PUSH     {r4,lr}
;;;431    {
000002  4602              MOV      r2,r0
;;;432        if(u32ChannelNum < 2)
000004  2902              CMP      r1,#2
000006  d208              BCS      |L16.26|
;;;433        {
;;;434            return (((pwm)->CAPCTL01 & ((PWM_CAPCTL01_CRLIF0_Msk | PWM_CAPCTL01_CFLIF0_Msk) << (u32ChannelNum * 16))) >> (PWM_CAPCTL01_CRLIF0_Pos + u32ChannelNum * 16));
000008  6d10              LDR      r0,[r2,#0x50]
00000a  010c              LSLS     r4,r1,#4
00000c  23c0              MOVS     r3,#0xc0
00000e  40a3              LSLS     r3,r3,r4
000010  4018              ANDS     r0,r0,r3
000012  010b              LSLS     r3,r1,#4
000014  1d9b              ADDS     r3,r3,#6
000016  40d8              LSRS     r0,r0,r3
                  |L16.24|
;;;435        }
;;;436        return 0;
;;;437    }
000018  bd10              POP      {r4,pc}
                  |L16.26|
00001a  2000              MOVS     r0,#0                 ;436
00001c  e7fc              B        |L16.24|
;;;438    /**
                          ENDP


                          AREA ||i.PWM_GetIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetIntFlag PROC
;;;487     */
;;;488    uint32_t PWM_GetIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  4602              MOV      r2,r0
;;;489    {
;;;490        return (((pwm)->INTSTS & (PWM_INTSTS_PIF0_Msk << u32ChannelNum)) ? 1 : 0);
000002  6c50              LDR      r0,[r2,#0x44]
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  4018              ANDS     r0,r0,r3
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L17.18|
00000e  2001              MOVS     r0,#1
                  |L17.16|
;;;491    }
000010  4770              BX       lr
                  |L17.18|
000012  2000              MOVS     r0,#0                 ;490
000014  e7fc              B        |L17.16|
;;;492    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;193     */
;;;194    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;195    {
000002  4602              MOV      r2,r0
;;;196        uint32_t u32Mask = 0, i;
000004  2300              MOVS     r3,#0
;;;197        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000006  2000              MOVS     r0,#0
000008  e009              B        |L18.30|
                  |L18.10|
;;;198        {
;;;199            if(u32ChannelMask & (1 << i))
00000a  2401              MOVS     r4,#1
00000c  4084              LSLS     r4,r4,r0
00000e  400c              ANDS     r4,r4,r1
000010  2c00              CMP      r4,#0
000012  d003              BEQ      |L18.28|
;;;200            {
;;;201                u32Mask |= (PWM_CTL_CNTEN0_Msk << (i * 8));
000014  00c5              LSLS     r5,r0,#3
000016  2401              MOVS     r4,#1
000018  40ac              LSLS     r4,r4,r5
00001a  4323              ORRS     r3,r3,r4
                  |L18.28|
00001c  1c40              ADDS     r0,r0,#1              ;197
                  |L18.30|
00001e  2802              CMP      r0,#2                 ;197
000020  d3f3              BCC      |L18.10|
;;;202            }
;;;203        }
;;;204    
;;;205        (pwm)->CTL |= u32Mask;
000022  6894              LDR      r4,[r2,#8]
000024  431c              ORRS     r4,r4,r3
000026  6094              STR      r4,[r2,#8]
;;;206    }
000028  bd30              POP      {r4,r5,pc}
;;;207    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;216     */
;;;217    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;218    {
000002  4602              MOV      r2,r0
;;;219        uint32_t i;
;;;220        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  2000              MOVS     r0,#0
000006  e00b              B        |L19.32|
                  |L19.8|
;;;221        {
;;;222            if(u32ChannelMask & (1 << i))
000008  2301              MOVS     r3,#1
00000a  4083              LSLS     r3,r3,r0
00000c  400b              ANDS     r3,r3,r1
00000e  2b00              CMP      r3,#0
000010  d005              BEQ      |L19.30|
;;;223            {
;;;224                *((__IO uint32_t *)((((uint32_t) & ((pwm)->PERIOD0)) + i * 12))) = 0;
000012  2500              MOVS     r5,#0
000014  230c              MOVS     r3,#0xc
000016  4343              MULS     r3,r0,r3
000018  4614              MOV      r4,r2
00001a  340c              ADDS     r4,r4,#0xc
00001c  50e5              STR      r5,[r4,r3]
                  |L19.30|
00001e  1c40              ADDS     r0,r0,#1              ;220
                  |L19.32|
000020  2802              CMP      r0,#2                 ;220
000022  d3f1              BCC      |L19.8|
;;;225            }
;;;226        }
;;;227    }
000024  bd30              POP      {r4,r5,pc}
;;;228    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00003e80
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x02ee0000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00003e80
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x02ee0000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000003

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 132
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
